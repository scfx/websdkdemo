{"version":3,"file":"client.umd.min.js","sources":["../../src/realtime/MetaChannel.ts","../../../../node_modules/cometd/cometd.js","../../../../node_modules/isomorphic-cometd/browser.js","../../src/realtime/Realtime.ts","../../src/core/Paging.ts","../../src/core/Service.ts","../../../../node_modules/cross-fetch/dist/browser-ponyfill.js","../../src/core/FetchClient.ts","../../../../node_modules/b2a/es/common.js","../../../../node_modules/b2a/es/btoa.js","../../src/core/BasicAuth.ts","../../../../node_modules/b2a/es/atob.js","../../src/gettext.ts","../../src/core/Severity.ts","../../src/core/QueriesUtil.ts","../../src/event/EventService.ts","../../node_modules/form-data/lib/browser.js","../../src/inventory/InventoryBinaryService.ts","../../src/inventory/InventoryService.ts","../../src/measurement/ISeriesFilter.ts","../../src/measurement/MeasurementService.ts","../../src/alarm/AlarmStatus.ts","../../src/alarm/AlarmService.ts","../../src/operation/OperationService.ts","../../src/operation/OperationBulkStatus.ts","../../src/operation/OperationBulkGeneralStatus.ts","../../src/operation/OperationStatus.ts","../../src/operation/OperationBulkService.ts","../../src/tenant/TenantStatus.ts","../../src/tenant/TfaStrategy.ts","../../src/tenant/TenantService.ts","../../src/user/UserInventoryRoleService.ts","../../src/user/PasswordStrength.ts","../../src/user/UserService.ts","../../src/application/ApplicationType.ts","../../src/application/ApplicationBinaryService.ts","../../src/application/BillingMode.ts","../../src/application/Isolation.ts","../../src/application/ApplicationAvailability.ts","../../src/application/ApplicationService.ts","../../src/system-options/SystemOptionsService.ts","../../src/tenant-options/TenantOptionsService.ts","../../src/tenant-security-options/TenantSecurityOptionsService.ts","../../src/tenant-login-options/ITenantLoginOptions.ts","../../src/tenant-login-options/TenantLoginOptionsService.ts","../../src/audit/AuditRecordType.ts","../../src/audit/ChangeType.ts","../../src/audit/AuditService.ts","../../src/device-registration/DeviceRegistrationStatus.ts","../../src/inventory-role/InventoryRoleService.ts","../../src/device-registration/DeviceRegistrationService.ts","../../src/device-registration/DeviceRegistrationBulkService.ts","../../src/user-role/UserRoleService.ts","../../src/user-group/UserGroupService.ts","../../src/identity/IdentityService.ts","../../src/smart-groups/SmartGroupsService.ts","../../src/smart-rules/SmartRulesService.ts","../../src/Client.ts","../../src/core/CookieAuth.ts","../../src/core/MicroserviceClientRequestAuth.ts","../../src/trusted-certificates/TrustedCertificateService.ts","../../src/event/EventBinaryService.ts"],"sourcesContent":["export enum MetaChannel {\n  HANDSHAKE = '/meta/handshake',\n  CONNECT = '/meta/connect',\n  SUBSCRIBE = '/meta/subscribe',\n  UNSUBSCRIBE = '/meta/unsubscribe'\n}\n","/*\n * Copyright (c) 2008-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* CometD Version 4.0.8 */\n\n(function(root, factory) {\n    if (typeof exports === 'object') {\n        // CommonJS.\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD.\n        define([], factory);\n    } else {\n        // Globals.\n        root.org = root.org || {};\n        root.org.cometd = factory();\n    }\n}(this, function() {\n    /**\n     * Browsers may throttle the Window scheduler,\n     * so we may replace it with a Worker scheduler.\n     */\n    var Scheduler = function() {\n        var _ids = 0;\n        var _tasks = {};\n        this.register = function(funktion) {\n            var id = ++_ids;\n            _tasks[id] = funktion;\n            return id;\n        };\n        this.unregister = function(id) {\n            var funktion = _tasks[id];\n            delete _tasks[id];\n            return funktion;\n        };\n        this.setTimeout = function(funktion, delay) {\n            return window.setTimeout(funktion, delay);\n        };\n        this.clearTimeout = function(id) {\n            window.clearTimeout(id);\n        };\n    };\n\n    /**\n     * The scheduler code that will run in the Worker.\n     * Workers have a built-in `self` variable similar to `window`.\n     */\n    function WorkerScheduler() {\n        var _tasks = {};\n        self.onmessage = function(e) {\n            var cmd = e.data;\n            var id = _tasks[cmd.id];\n            switch (cmd.type) {\n                case 'setTimeout':\n                    _tasks[cmd.id] = self.setTimeout(function() {\n                        delete _tasks[cmd.id];\n                        self.postMessage({\n                            id: cmd.id\n                        });\n                    }, cmd.delay);\n                    break;\n                case 'clearTimeout':\n                    delete _tasks[cmd.id];\n                    if (id) {\n                        self.clearTimeout(id);\n                    }\n                    break;\n                default:\n                    throw 'Unknown command ' + cmd.type;\n            }\n        };\n    }\n\n\n    /**\n     * Utility functions.\n     */\n    var Utils = {\n        isString: function(value) {\n            if (value === undefined || value === null) {\n                return false;\n            }\n            return typeof value === 'string' || value instanceof String;\n        },\n        isArray: function(value) {\n            if (value === undefined || value === null) {\n                return false;\n            }\n            return value instanceof Array;\n        },\n        /**\n         * Returns whether the given element is contained into the given array.\n         * @param element the element to check presence for\n         * @param array the array to check for the element presence\n         * @return the index of the element, if present, or a negative index if the element is not present\n         */\n        inArray: function(element, array) {\n            for (var i = 0; i < array.length; ++i) {\n                if (element === array[i]) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    };\n\n\n    /**\n     * A registry for transports used by the CometD object.\n     */\n    var TransportRegistry = function() {\n        var _types = [];\n        var _transports = {};\n\n        this.getTransportTypes = function() {\n            return _types.slice(0);\n        };\n\n        this.findTransportTypes = function(version, crossDomain, url) {\n            var result = [];\n            for (var i = 0; i < _types.length; ++i) {\n                var type = _types[i];\n                if (_transports[type].accept(version, crossDomain, url) === true) {\n                    result.push(type);\n                }\n            }\n            return result;\n        };\n\n        this.negotiateTransport = function(types, version, crossDomain, url) {\n            for (var i = 0; i < _types.length; ++i) {\n                var type = _types[i];\n                for (var j = 0; j < types.length; ++j) {\n                    if (type === types[j]) {\n                        var transport = _transports[type];\n                        if (transport.accept(version, crossDomain, url) === true) {\n                            return transport;\n                        }\n                    }\n                }\n            }\n            return null;\n        };\n\n        this.add = function(type, transport, index) {\n            var existing = false;\n            for (var i = 0; i < _types.length; ++i) {\n                if (_types[i] === type) {\n                    existing = true;\n                    break;\n                }\n            }\n\n            if (!existing) {\n                if (typeof index !== 'number') {\n                    _types.push(type);\n                } else {\n                    _types.splice(index, 0, type);\n                }\n                _transports[type] = transport;\n            }\n\n            return !existing;\n        };\n\n        this.find = function(type) {\n            for (var i = 0; i < _types.length; ++i) {\n                if (_types[i] === type) {\n                    return _transports[type];\n                }\n            }\n            return null;\n        };\n\n        this.remove = function(type) {\n            for (var i = 0; i < _types.length; ++i) {\n                if (_types[i] === type) {\n                    _types.splice(i, 1);\n                    var transport = _transports[type];\n                    delete _transports[type];\n                    return transport;\n                }\n            }\n            return null;\n        };\n\n        this.clear = function() {\n            _types = [];\n            _transports = {};\n        };\n\n        this.reset = function(init) {\n            for (var i = 0; i < _types.length; ++i) {\n                _transports[_types[i]].reset(init);\n            }\n        };\n    };\n\n\n    /**\n     * Base object with the common functionality for transports.\n     */\n    var Transport = function() {\n        var _type;\n        var _cometd;\n        var _url;\n\n        /**\n         * Function invoked just after a transport has been successfully registered.\n         * @param type the type of transport (for example 'long-polling')\n         * @param cometd the cometd object this transport has been registered to\n         * @see #unregistered()\n         */\n        this.registered = function(type, cometd) {\n            _type = type;\n            _cometd = cometd;\n        };\n\n        /**\n         * Function invoked just after a transport has been successfully unregistered.\n         * @see #registered(type, cometd)\n         */\n        this.unregistered = function() {\n            _type = null;\n            _cometd = null;\n        };\n\n        this._debug = function() {\n            _cometd._debug.apply(_cometd, arguments);\n        };\n\n        this._mixin = function() {\n            return _cometd._mixin.apply(_cometd, arguments);\n        };\n\n        this.getConfiguration = function() {\n            return _cometd.getConfiguration();\n        };\n\n        this.getAdvice = function() {\n            return _cometd.getAdvice();\n        };\n\n        this.setTimeout = function(funktion, delay) {\n            return _cometd.setTimeout(funktion, delay);\n        };\n\n        this.clearTimeout = function(id) {\n            _cometd.clearTimeout(id);\n        };\n\n        /**\n         * Converts the given response into an array of bayeux messages\n         * @param response the response to convert\n         * @return an array of bayeux messages obtained by converting the response\n         */\n        this.convertToMessages = function(response) {\n            if (Utils.isString(response)) {\n                try {\n                    return JSON.parse(response);\n                } catch (x) {\n                    this._debug('Could not convert to JSON the following string', '\"' + response + '\"');\n                    throw x;\n                }\n            }\n            if (Utils.isArray(response)) {\n                return response;\n            }\n            if (response === undefined || response === null) {\n                return [];\n            }\n            if (response instanceof Object) {\n                return [response];\n            }\n            throw 'Conversion Error ' + response + ', typeof ' + (typeof response);\n        };\n\n        /**\n         * Returns whether this transport can work for the given version and cross domain communication case.\n         * @param version a string indicating the transport version\n         * @param crossDomain a boolean indicating whether the communication is cross domain\n         * @param url the URL to connect to\n         * @return true if this transport can work for the given version and cross domain communication case,\n         * false otherwise\n         */\n        this.accept = function(version, crossDomain, url) {\n            throw 'Abstract';\n        };\n\n        /**\n         * Returns the type of this transport.\n         * @see #registered(type, cometd)\n         */\n        this.getType = function() {\n            return _type;\n        };\n\n        this.getURL = function() {\n            return _url;\n        };\n\n        this.setURL = function(url) {\n            _url = url;\n        };\n\n        this.send = function(envelope, metaConnect) {\n            throw 'Abstract';\n        };\n\n        this.reset = function(init) {\n            this._debug('Transport', _type, 'reset', init ? 'initial' : 'retry');\n        };\n\n        this.abort = function() {\n            this._debug('Transport', _type, 'aborted');\n        };\n\n        this.toString = function() {\n            return this.getType();\n        };\n    };\n\n    Transport.derive = function(baseObject) {\n        function F() {\n        }\n\n        F.prototype = baseObject;\n        return new F();\n    };\n\n\n    /**\n     * Base object with the common functionality for transports based on requests.\n     * The key responsibility is to allow at most 2 outstanding requests to the server,\n     * to avoid that requests are sent behind a long poll.\n     * To achieve this, we have one reserved request for the long poll, and all other\n     * requests are serialized one after the other.\n     */\n    var RequestTransport = function() {\n        var _super = new Transport();\n        var _self = Transport.derive(_super);\n        var _requestIds = 0;\n        var _metaConnectRequest = null;\n        var _requests = [];\n        var _envelopes = [];\n\n        function _coalesceEnvelopes(envelope) {\n            while (_envelopes.length > 0) {\n                var envelopeAndRequest = _envelopes[0];\n                var newEnvelope = envelopeAndRequest[0];\n                var newRequest = envelopeAndRequest[1];\n                if (newEnvelope.url === envelope.url &&\n                    newEnvelope.sync === envelope.sync) {\n                    _envelopes.shift();\n                    envelope.messages = envelope.messages.concat(newEnvelope.messages);\n                    this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);\n                    continue;\n                }\n                break;\n            }\n        }\n\n        function _transportSend(envelope, request) {\n            this.transportSend(envelope, request);\n            request.expired = false;\n\n            if (!envelope.sync) {\n                var maxDelay = this.getConfiguration().maxNetworkDelay;\n                var delay = maxDelay;\n                if (request.metaConnect === true) {\n                    delay += this.getAdvice().timeout;\n                }\n\n                this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);\n\n                var self = this;\n                request.timeout = this.setTimeout(function() {\n                    request.expired = true;\n                    var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';\n                    var failure = {\n                        reason: errorMessage\n                    };\n                    var xhr = request.xhr;\n                    failure.httpCode = self.xhrStatus(xhr);\n                    self.abortXHR(xhr);\n                    self._debug(errorMessage);\n                    self.complete(request, false, request.metaConnect);\n                    envelope.onFailure(xhr, envelope.messages, failure);\n                }, delay);\n            }\n        }\n\n        function _queueSend(envelope) {\n            var requestId = ++_requestIds;\n            var request = {\n                id: requestId,\n                metaConnect: false,\n                envelope: envelope\n            };\n\n            // Consider the /meta/connect requests which should always be present.\n            if (_requests.length < this.getConfiguration().maxConnections - 1) {\n                _requests.push(request);\n                _transportSend.call(this, envelope, request);\n            } else {\n                this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);\n                _envelopes.push([envelope, request]);\n            }\n        }\n\n        function _metaConnectComplete(request) {\n            var requestId = request.id;\n            this._debug('Transport', this.getType(), '/meta/connect complete, request', requestId);\n            if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {\n                throw '/meta/connect request mismatch, completing request ' + requestId;\n            }\n            _metaConnectRequest = null;\n        }\n\n        function _complete(request, success) {\n            var index = Utils.inArray(request, _requests);\n            // The index can be negative if the request has been aborted\n            if (index >= 0) {\n                _requests.splice(index, 1);\n            }\n\n            if (_envelopes.length > 0) {\n                var envelopeAndRequest = _envelopes.shift();\n                var nextEnvelope = envelopeAndRequest[0];\n                var nextRequest = envelopeAndRequest[1];\n                this._debug('Transport dequeued request', nextRequest.id);\n                if (success) {\n                    if (this.getConfiguration().autoBatch) {\n                        _coalesceEnvelopes.call(this, nextEnvelope);\n                    }\n                    _queueSend.call(this, nextEnvelope);\n                    this._debug('Transport completed request', request.id, nextEnvelope);\n                } else {\n                    // Keep the semantic of calling response callbacks asynchronously after the request\n                    var self = this;\n                    this.setTimeout(function() {\n                        self.complete(nextRequest, false, nextRequest.metaConnect);\n                        var failure = {\n                            reason: 'Previous request failed'\n                        };\n                        var xhr = nextRequest.xhr;\n                        failure.httpCode = self.xhrStatus(xhr);\n                        nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);\n                    }, 0);\n                }\n            }\n        }\n\n        _self.complete = function(request, success, metaConnect) {\n            if (metaConnect) {\n                _metaConnectComplete.call(this, request);\n            } else {\n                _complete.call(this, request, success);\n            }\n        };\n\n        /**\n         * Performs the actual send depending on the transport type details.\n         * @param envelope the envelope to send\n         * @param request the request information\n         */\n        _self.transportSend = function(envelope, request) {\n            throw 'Abstract';\n        };\n\n        _self.transportSuccess = function(envelope, request, responses) {\n            if (!request.expired) {\n                this.clearTimeout(request.timeout);\n                this.complete(request, true, request.metaConnect);\n                if (responses && responses.length > 0) {\n                    envelope.onSuccess(responses);\n                } else {\n                    envelope.onFailure(request.xhr, envelope.messages, {\n                        httpCode: 204\n                    });\n                }\n            }\n        };\n\n        _self.transportFailure = function(envelope, request, failure) {\n            if (!request.expired) {\n                this.clearTimeout(request.timeout);\n                this.complete(request, false, request.metaConnect);\n                envelope.onFailure(request.xhr, envelope.messages, failure);\n            }\n        };\n\n        function _metaConnectSend(envelope) {\n            if (_metaConnectRequest !== null) {\n                throw 'Concurrent /meta/connect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';\n            }\n\n            var requestId = ++_requestIds;\n            this._debug('Transport', this.getType(), '/meta/connect send, request', requestId, 'envelope', envelope);\n            var request = {\n                id: requestId,\n                metaConnect: true,\n                envelope: envelope\n            };\n            _transportSend.call(this, envelope, request);\n            _metaConnectRequest = request;\n        }\n\n        _self.send = function(envelope, metaConnect) {\n            if (metaConnect) {\n                _metaConnectSend.call(this, envelope);\n            } else {\n                _queueSend.call(this, envelope);\n            }\n        };\n\n        _self.abort = function() {\n            _super.abort();\n            for (var i = 0; i < _requests.length; ++i) {\n                var request = _requests[i];\n                if (request) {\n                    this._debug('Aborting request', request);\n                    if (!this.abortXHR(request.xhr)) {\n                        this.transportFailure(request.envelope, request, {reason: 'abort'});\n                    }\n                }\n            }\n            var metaConnectRequest = _metaConnectRequest;\n            if (metaConnectRequest) {\n                this._debug('Aborting /meta/connect request', metaConnectRequest);\n                if (!this.abortXHR(metaConnectRequest.xhr)) {\n                    this.transportFailure(metaConnectRequest.envelope, metaConnectRequest, {reason: 'abort'});\n                }\n            }\n            this.reset(true);\n        };\n\n        _self.reset = function(init) {\n            _super.reset(init);\n            _metaConnectRequest = null;\n            _requests = [];\n            _envelopes = [];\n        };\n\n        _self.abortXHR = function(xhr) {\n            if (xhr) {\n                try {\n                    var state = xhr.readyState;\n                    xhr.abort();\n                    return state !== window.XMLHttpRequest.UNSENT;\n                } catch (x) {\n                    this._debug(x);\n                }\n            }\n            return false;\n        };\n\n        _self.xhrStatus = function(xhr) {\n            if (xhr) {\n                try {\n                    return xhr.status;\n                } catch (x) {\n                    this._debug(x);\n                }\n            }\n            return -1;\n        };\n\n        return _self;\n    };\n\n\n    var LongPollingTransport = function() {\n        var _super = new RequestTransport();\n        var _self = Transport.derive(_super);\n        // By default, support cross domain\n        var _supportsCrossDomain = true;\n\n        _self.accept = function(version, crossDomain, url) {\n            return _supportsCrossDomain || !crossDomain;\n        };\n\n        _self.newXMLHttpRequest = function() {\n            return new window.XMLHttpRequest();\n        };\n\n        function _copyContext(xhr) {\n            try {\n                // Copy external context, to be used in other environments.\n                xhr.context = _self.context;\n            } catch (e) {\n                // May happen if XHR is wrapped by Object.seal(),\n                // Object.freeze(), or Object.preventExtensions().\n                this._debug('Could not copy transport context into XHR', e);\n            }\n        }\n\n        _self.xhrSend = function(packet) {\n            var xhr = _self.newXMLHttpRequest();\n            _copyContext(xhr);\n            xhr.withCredentials = true;\n            xhr.open('POST', packet.url, packet.sync !== true);\n            var headers = packet.headers;\n            if (headers) {\n                for (var headerName in headers) {\n                    if (headers.hasOwnProperty(headerName)) {\n                        xhr.setRequestHeader(headerName, headers[headerName]);\n                    }\n                }\n            }\n            xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');\n            xhr.onload = function() {\n                if (xhr.status === 200) {\n                    packet.onSuccess(xhr.responseText);\n                } else {\n                    packet.onError(xhr.statusText);\n                }\n            };\n            xhr.onabort = xhr.onerror = function() {\n                packet.onError(xhr.statusText);\n            };\n            xhr.send(packet.body);\n            return xhr;\n        };\n\n        _self.transportSend = function(envelope, request) {\n            this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);\n\n            var self = this;\n            try {\n                var sameStack = true;\n                request.xhr = this.xhrSend({\n                    transport: this,\n                    url: envelope.url,\n                    sync: envelope.sync,\n                    headers: this.getConfiguration().requestHeaders,\n                    body: JSON.stringify(envelope.messages),\n                    onSuccess: function(response) {\n                        self._debug('Transport', self.getType(), 'received response', response);\n                        var success = false;\n                        try {\n                            var received = self.convertToMessages(response);\n                            if (received.length === 0) {\n                                _supportsCrossDomain = false;\n                                self.transportFailure(envelope, request, {\n                                    httpCode: 204\n                                });\n                            } else {\n                                success = true;\n                                self.transportSuccess(envelope, request, received);\n                            }\n                        } catch (x) {\n                            self._debug(x);\n                            if (!success) {\n                                _supportsCrossDomain = false;\n                                var failure = {\n                                    exception: x\n                                };\n                                failure.httpCode = self.xhrStatus(request.xhr);\n                                self.transportFailure(envelope, request, failure);\n                            }\n                        }\n                    },\n                    onError: function(reason, exception) {\n                        self._debug('Transport', self.getType(), 'received error', reason, exception);\n                        _supportsCrossDomain = false;\n                        var failure = {\n                            reason: reason,\n                            exception: exception\n                        };\n                        failure.httpCode = self.xhrStatus(request.xhr);\n                        if (sameStack) {\n                            // Keep the semantic of calling response callbacks asynchronously after the request\n                            self.setTimeout(function() {\n                                self.transportFailure(envelope, request, failure);\n                            }, 0);\n                        } else {\n                            self.transportFailure(envelope, request, failure);\n                        }\n                    }\n                });\n                sameStack = false;\n            } catch (x) {\n                _supportsCrossDomain = false;\n                // Keep the semantic of calling response callbacks asynchronously after the request\n                this.setTimeout(function() {\n                    self.transportFailure(envelope, request, {\n                        exception: x\n                    });\n                }, 0);\n            }\n        };\n\n        _self.reset = function(init) {\n            _super.reset(init);\n            _supportsCrossDomain = true;\n        };\n\n        return _self;\n    };\n\n\n    var CallbackPollingTransport = function() {\n        var _super = new RequestTransport();\n        var _self = Transport.derive(_super);\n        var jsonp = 0;\n\n        _self.accept = function(version, crossDomain, url) {\n            return true;\n        };\n\n        _self.jsonpSend = function(packet) {\n            var head = document.getElementsByTagName('head')[0];\n            var script = document.createElement('script');\n\n            var callbackName = '_cometd_jsonp_' + jsonp++;\n            window[callbackName] = function(responseText) {\n                head.removeChild(script);\n                delete window[callbackName];\n                packet.onSuccess(responseText);\n            };\n\n            var url = packet.url;\n            url += url.indexOf('?') < 0 ? '?' : '&';\n            url += 'jsonp=' + callbackName;\n            url += '&message=' + encodeURIComponent(packet.body);\n            script.src = url;\n            script.async = packet.sync !== true;\n            script.type = 'application/javascript';\n            script.onerror = function(e) {\n                packet.onError('jsonp ' + e.type);\n            };\n            head.appendChild(script);\n        };\n\n        function _failTransportFn(envelope, request, x) {\n            var self = this;\n            return function() {\n                self.transportFailure(envelope, request, 'error', x);\n            };\n        }\n\n        _self.transportSend = function(envelope, request) {\n            var self = this;\n\n            // Microsoft Internet Explorer has a 2083 URL max length\n            // We must ensure that we stay within that length\n            var start = 0;\n            var length = envelope.messages.length;\n            var lengths = [];\n            while (length > 0) {\n                // Encode the messages because all brackets, quotes, commas, colons, etc\n                // present in the JSON will be URL encoded, taking many more characters\n                var json = JSON.stringify(envelope.messages.slice(start, start + length));\n                var urlLength = envelope.url.length + encodeURI(json).length;\n\n                var maxLength = this.getConfiguration().maxURILength;\n                if (urlLength > maxLength) {\n                    if (length === 1) {\n                        var x = 'Bayeux message too big (' + urlLength + ' bytes, max is ' + maxLength + ') ' +\n                            'for transport ' + this.getType();\n                        // Keep the semantic of calling response callbacks asynchronously after the request\n                        this.setTimeout(_failTransportFn.call(this, envelope, request, x), 0);\n                        return;\n                    }\n\n                    --length;\n                    continue;\n                }\n\n                lengths.push(length);\n                start += length;\n                length = envelope.messages.length - start;\n            }\n\n            // Here we are sure that the messages can be sent within the URL limit\n\n            var envelopeToSend = envelope;\n            if (lengths.length > 1) {\n                var begin = 0;\n                var end = lengths[0];\n                this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));\n                envelopeToSend = this._mixin(false, {}, envelope);\n                envelopeToSend.messages = envelope.messages.slice(begin, end);\n                envelopeToSend.onSuccess = envelope.onSuccess;\n                envelopeToSend.onFailure = envelope.onFailure;\n\n                for (var i = 1; i < lengths.length; ++i) {\n                    var nextEnvelope = this._mixin(false, {}, envelope);\n                    begin = end;\n                    end += lengths[i];\n                    nextEnvelope.messages = envelope.messages.slice(begin, end);\n                    nextEnvelope.onSuccess = envelope.onSuccess;\n                    nextEnvelope.onFailure = envelope.onFailure;\n                    this.send(nextEnvelope, request.metaConnect);\n                }\n            }\n\n            this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);\n\n            try {\n                var sameStack = true;\n                this.jsonpSend({\n                    transport: this,\n                    url: envelopeToSend.url,\n                    sync: envelopeToSend.sync,\n                    headers: this.getConfiguration().requestHeaders,\n                    body: JSON.stringify(envelopeToSend.messages),\n                    onSuccess: function(responses) {\n                        var success = false;\n                        try {\n                            var received = self.convertToMessages(responses);\n                            if (received.length === 0) {\n                                self.transportFailure(envelopeToSend, request, {\n                                    httpCode: 204\n                                });\n                            } else {\n                                success = true;\n                                self.transportSuccess(envelopeToSend, request, received);\n                            }\n                        } catch (x) {\n                            self._debug(x);\n                            if (!success) {\n                                self.transportFailure(envelopeToSend, request, {\n                                    exception: x\n                                });\n                            }\n                        }\n                    },\n                    onError: function(reason, exception) {\n                        var failure = {\n                            reason: reason,\n                            exception: exception\n                        };\n                        if (sameStack) {\n                            // Keep the semantic of calling response callbacks asynchronously after the request\n                            self.setTimeout(function() {\n                                self.transportFailure(envelopeToSend, request, failure);\n                            }, 0);\n                        } else {\n                            self.transportFailure(envelopeToSend, request, failure);\n                        }\n                    }\n                });\n                sameStack = false;\n            } catch (xx) {\n                // Keep the semantic of calling response callbacks asynchronously after the request\n                this.setTimeout(function() {\n                    self.transportFailure(envelopeToSend, request, {\n                        exception: xx\n                    });\n                }, 0);\n            }\n        };\n\n        return _self;\n    };\n\n\n    var WebSocketTransport = function() {\n        var _super = new Transport();\n        var _self = Transport.derive(_super);\n        var _cometd;\n        // By default WebSocket is supported\n        var _webSocketSupported = true;\n        // Whether we were able to establish a WebSocket connection\n        var _webSocketConnected = false;\n        var _stickyReconnect = true;\n        // The context contains the envelopes that have been sent\n        // and the timeouts for the messages that have been sent.\n        var _context = null;\n        var _connecting = null;\n        var _connected = false;\n        var _successCallback = null;\n\n        _self.reset = function(init) {\n            _super.reset(init);\n            _webSocketSupported = true;\n            if (init) {\n                _webSocketConnected = false;\n            }\n            _stickyReconnect = true;\n            _context = null;\n            _connecting = null;\n            _connected = false;\n        };\n\n        function _forceClose(context, event) {\n            if (context) {\n                this.webSocketClose(context, event.code, event.reason);\n                // Force immediate failure of pending messages to trigger reconnect.\n                // This is needed because the server may not reply to our close()\n                // and therefore the onclose function is never called.\n                this.onClose(context, event);\n            }\n        }\n\n        function _sameContext(context) {\n            return context === _connecting || context === _context;\n        }\n\n        function _storeEnvelope(context, envelope, metaConnect) {\n            var messageIds = [];\n            for (var i = 0; i < envelope.messages.length; ++i) {\n                var message = envelope.messages[i];\n                if (message.id) {\n                    messageIds.push(message.id);\n                }\n            }\n            context.envelopes[messageIds.join(',')] = [envelope, metaConnect];\n            this._debug('Transport', this.getType(), 'stored envelope, envelopes', context.envelopes);\n        }\n\n        function _websocketConnect(context) {\n            // We may have multiple attempts to open a WebSocket\n            // connection, for example a /meta/connect request that\n            // may take time, along with a user-triggered publish.\n            // Early return if we are already connecting.\n            if (_connecting) {\n                return;\n            }\n\n            // Mangle the URL, changing the scheme from 'http' to 'ws'.\n            var url = _cometd.getURL().replace(/^http/, 'ws');\n            this._debug('Transport', this.getType(), 'connecting to URL', url);\n\n            try {\n                var protocol = _cometd.getConfiguration().protocol;\n                context.webSocket = protocol ? new window.WebSocket(url, protocol) : new window.WebSocket(url);\n                _connecting = context;\n            } catch (x) {\n                _webSocketSupported = false;\n                this._debug('Exception while creating WebSocket object', x);\n                throw x;\n            }\n\n            // By default use sticky reconnects.\n            _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;\n\n            var self = this;\n            var connectTimeout = _cometd.getConfiguration().connectTimeout;\n            if (connectTimeout > 0) {\n                context.connectTimer = this.setTimeout(function() {\n                    _cometd._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');\n                    // The connection was not opened, close anyway.\n                    _forceClose.call(self, context, {code: 1000, reason: 'Connect Timeout'});\n                }, connectTimeout);\n            }\n\n            var onopen = function() {\n                _cometd._debug('WebSocket onopen', context);\n                if (context.connectTimer) {\n                    self.clearTimeout(context.connectTimer);\n                }\n\n                if (_sameContext(context)) {\n                    _connecting = null;\n                    _context = context;\n                    _webSocketConnected = true;\n                    self.onOpen(context);\n                } else {\n                    // We have a valid connection already, close this one.\n                    _cometd._warn('Closing extra WebSocket connection', this, 'active connection', _context);\n                    _forceClose.call(self, context, {code: 1000, reason: 'Extra Connection'});\n                }\n            };\n\n            // This callback is invoked when the server sends the close frame.\n            // The close frame for a connection may arrive *after* another\n            // connection has been opened, so we must make sure that actions\n            // are performed only if it's the same connection.\n            var onclose = function(event) {\n                event = event || {code: 1000};\n                _cometd._debug('WebSocket onclose', context, event, 'connecting', _connecting, 'current', _context);\n\n                if (context.connectTimer) {\n                    self.clearTimeout(context.connectTimer);\n                }\n\n                self.onClose(context, event);\n            };\n\n            var onmessage = function(wsMessage) {\n                _cometd._debug('WebSocket onmessage', wsMessage, context);\n                self.onMessage(context, wsMessage);\n            };\n\n            context.webSocket.onopen = onopen;\n            context.webSocket.onclose = onclose;\n            context.webSocket.onerror = function() {\n                // Clients should call onclose(), but if they do not we do it here for safety.\n                onclose({code: 1000, reason: 'Error'});\n            };\n            context.webSocket.onmessage = onmessage;\n\n            this._debug('Transport', this.getType(), 'configured callbacks on', context);\n        }\n\n        function _webSocketSend(context, envelope, metaConnect) {\n            var json = JSON.stringify(envelope.messages);\n            context.webSocket.send(json);\n            this._debug('Transport', this.getType(), 'sent', envelope, '/meta/connect =', metaConnect);\n\n            // Manage the timeout waiting for the response.\n            var maxDelay = this.getConfiguration().maxNetworkDelay;\n            var delay = maxDelay;\n            if (metaConnect) {\n                delay += this.getAdvice().timeout;\n                _connected = true;\n            }\n\n            var self = this;\n            var messageIds = [];\n            for (var i = 0; i < envelope.messages.length; ++i) {\n                (function() {\n                    var message = envelope.messages[i];\n                    if (message.id) {\n                        messageIds.push(message.id);\n                        context.timeouts[message.id] = self.setTimeout(function() {\n                            _cometd._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', context);\n                            _forceClose.call(self, context, {code: 1000, reason: 'Message Timeout'});\n                        }, delay);\n                    }\n                })();\n            }\n\n            this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', context.timeouts);\n        }\n\n        _self._notifySuccess = function(fn, messages) {\n            fn.call(this, messages);\n        };\n\n        _self._notifyFailure = function(fn, context, messages, failure) {\n            fn.call(this, context, messages, failure);\n        };\n\n        function _send(context, envelope, metaConnect) {\n            try {\n                if (context === null) {\n                    context = _connecting || {\n                        envelopes: {},\n                        timeouts: {}\n                    };\n                    _storeEnvelope.call(this, context, envelope, metaConnect);\n                    _websocketConnect.call(this, context);\n                } else {\n                    _storeEnvelope.call(this, context, envelope, metaConnect);\n                    _webSocketSend.call(this, context, envelope, metaConnect);\n                }\n            } catch (x) {\n                // Keep the semantic of calling response callbacks asynchronously after the request.\n                var self = this;\n                this.setTimeout(function() {\n                    _forceClose.call(self, context, {\n                        code: 1000,\n                        reason: 'Exception',\n                        exception: x\n                    });\n                }, 0);\n            }\n        }\n\n        _self.onOpen = function(context) {\n            var envelopes = context.envelopes;\n            this._debug('Transport', this.getType(), 'opened', context, 'pending messages', envelopes);\n            for (var key in envelopes) {\n                if (envelopes.hasOwnProperty(key)) {\n                    var element = envelopes[key];\n                    var envelope = element[0];\n                    var metaConnect = element[1];\n                    // Store the success callback, which is independent from the envelope,\n                    // so that it can be used to notify arrival of messages.\n                    _successCallback = envelope.onSuccess;\n                    _webSocketSend.call(this, context, envelope, metaConnect);\n                }\n            }\n        };\n\n        _self.onMessage = function(context, wsMessage) {\n            this._debug('Transport', this.getType(), 'received websocket message', wsMessage, context);\n\n            var close = false;\n            var messages = this.convertToMessages(wsMessage.data);\n            var messageIds = [];\n            for (var i = 0; i < messages.length; ++i) {\n                var message = messages[i];\n\n                // Detect if the message is a response to a request we made.\n                // If it's a meta message, for sure it's a response; otherwise it's\n                // a publish message and publish responses don't have the data field.\n                if (/^\\/meta\\//.test(message.channel) || message.data === undefined) {\n                    if (message.id) {\n                        messageIds.push(message.id);\n\n                        var timeout = context.timeouts[message.id];\n                        if (timeout) {\n                            this.clearTimeout(timeout);\n                            delete context.timeouts[message.id];\n                            this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', context.timeouts);\n                        }\n                    }\n                }\n\n                if ('/meta/connect' === message.channel) {\n                    _connected = false;\n                }\n                if ('/meta/disconnect' === message.channel && !_connected) {\n                    close = true;\n                }\n            }\n\n            // Remove the envelope corresponding to the messages.\n            var removed = false;\n            var envelopes = context.envelopes;\n            for (var j = 0; j < messageIds.length; ++j) {\n                var id = messageIds[j];\n                for (var key in envelopes) {\n                    if (envelopes.hasOwnProperty(key)) {\n                        var ids = key.split(',');\n                        var index = Utils.inArray(id, ids);\n                        if (index >= 0) {\n                            removed = true;\n                            ids.splice(index, 1);\n                            var envelope = envelopes[key][0];\n                            var metaConnect = envelopes[key][1];\n                            delete envelopes[key];\n                            if (ids.length > 0) {\n                                envelopes[ids.join(',')] = [envelope, metaConnect];\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            if (removed) {\n                this._debug('Transport', this.getType(), 'removed envelope, envelopes', envelopes);\n            }\n\n            this._notifySuccess(_successCallback, messages);\n\n            if (close) {\n                this.webSocketClose(context, 1000, 'Disconnect');\n            }\n        };\n\n        _self.onClose = function(context, event) {\n            this._debug('Transport', this.getType(), 'closed', context, event);\n\n            if (_sameContext(context)) {\n                // Remember if we were able to connect.\n                // This close event could be due to server shutdown,\n                // and if it restarts we want to try websocket again.\n                _webSocketSupported = _stickyReconnect && _webSocketConnected;\n                _connecting = null;\n                _context = null;\n            }\n\n            var timeouts = context.timeouts;\n            context.timeouts = {};\n            for (var id in timeouts) {\n                if (timeouts.hasOwnProperty(id)) {\n                    this.clearTimeout(timeouts[id]);\n                }\n            }\n\n            var envelopes = context.envelopes;\n            context.envelopes = {};\n            for (var key in envelopes) {\n                if (envelopes.hasOwnProperty(key)) {\n                    var envelope = envelopes[key][0];\n                    var metaConnect = envelopes[key][1];\n                    if (metaConnect) {\n                        _connected = false;\n                    }\n                    var failure = {\n                        websocketCode: event.code,\n                        reason: event.reason\n                    };\n                    if (event.exception) {\n                        failure.exception = event.exception;\n                    }\n                    this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);\n                }\n            }\n        };\n\n        _self.registered = function(type, cometd) {\n            _super.registered(type, cometd);\n            _cometd = cometd;\n        };\n\n        _self.accept = function(version, crossDomain, url) {\n            this._debug('Transport', this.getType(), 'accept, supported:', _webSocketSupported);\n            // Using !! to return a boolean (and not the WebSocket object).\n            return _webSocketSupported && !!window.WebSocket && _cometd.websocketEnabled !== false;\n        };\n\n        _self.send = function(envelope, metaConnect) {\n            this._debug('Transport', this.getType(), 'sending', envelope, '/meta/connect =', metaConnect);\n            _send.call(this, _context, envelope, metaConnect);\n        };\n\n        _self.webSocketClose = function(context, code, reason) {\n            try {\n                if (context.webSocket) {\n                    context.webSocket.close(code, reason);\n                }\n            } catch (x) {\n                this._debug(x);\n            }\n        };\n\n        _self.abort = function() {\n            _super.abort();\n            _forceClose.call(this, _context, {code: 1000, reason: 'Abort'});\n            this.reset(true);\n        };\n\n        return _self;\n    };\n\n\n    /**\n     * The constructor for a CometD object, identified by an optional name.\n     * The default name is the string 'default'.\n     * @param name the optional name of this cometd object\n     */\n    var CometD = function(name) {\n        var _scheduler = new Scheduler();\n        var _cometd = this;\n        var _name = name || 'default';\n        var _crossDomain = false;\n        var _transports = new TransportRegistry();\n        var _transport;\n        var _status = 'disconnected';\n        var _messageId = 0;\n        var _clientId = null;\n        var _batch = 0;\n        var _messageQueue = [];\n        var _internalBatch = false;\n        var _listenerId = 0;\n        var _listeners = {};\n        var _backoff = 0;\n        var _scheduledSend = null;\n        var _extensions = [];\n        var _advice = {};\n        var _handshakeProps;\n        var _handshakeCallback;\n        var _callbacks = {};\n        var _remoteCalls = {};\n        var _reestablish = false;\n        var _connected = false;\n        var _unconnectTime = 0;\n        var _handshakeMessages = 0;\n        var _metaConnect = null;\n        var _config = {\n            useWorkerScheduler: true,\n            protocol: null,\n            stickyReconnect: true,\n            connectTimeout: 0,\n            maxConnections: 2,\n            backoffIncrement: 1000,\n            maxBackoff: 60000,\n            logLevel: 'info',\n            maxNetworkDelay: 10000,\n            requestHeaders: {},\n            appendMessageTypeToURL: true,\n            autoBatch: false,\n            urls: {},\n            maxURILength: 2000,\n            advice: {\n                timeout: 60000,\n                interval: 0,\n                reconnect: undefined,\n                maxInterval: 0\n            }\n        };\n\n        function _fieldValue(object, name) {\n            try {\n                return object[name];\n            } catch (x) {\n                return undefined;\n            }\n        }\n\n        /**\n         * Mixes in the given objects into the target object by copying the properties.\n         * @param deep if the copy must be deep\n         * @param target the target object\n         * @param objects the objects whose properties are copied into the target\n         */\n        this._mixin = function(deep, target, objects) {\n            var result = target || {};\n\n            // Skip first 2 parameters (deep and target), and loop over the others\n            for (var i = 2; i < arguments.length; ++i) {\n                var object = arguments[i];\n\n                if (object === undefined || object === null) {\n                    continue;\n                }\n\n                for (var propName in object) {\n                    if (object.hasOwnProperty(propName)) {\n                        var prop = _fieldValue(object, propName);\n                        var targ = _fieldValue(result, propName);\n\n                        // Avoid infinite loops\n                        if (prop === target) {\n                            continue;\n                        }\n                        // Do not mixin undefined values\n                        if (prop === undefined) {\n                            continue;\n                        }\n\n                        if (deep && typeof prop === 'object' && prop !== null) {\n                            if (prop instanceof Array) {\n                                result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);\n                            } else {\n                                var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};\n                                result[propName] = this._mixin(deep, source, prop);\n                            }\n                        } else {\n                            result[propName] = prop;\n                        }\n                    }\n                }\n            }\n\n            return result;\n        };\n\n        function _isString(value) {\n            return Utils.isString(value);\n        }\n\n        function _isFunction(value) {\n            if (value === undefined || value === null) {\n                return false;\n            }\n            return typeof value === 'function';\n        }\n\n        function _zeroPad(value, length) {\n            var result = '';\n            while (--length > 0) {\n                if (value >= Math.pow(10, length)) {\n                    break;\n                }\n                result += '0';\n            }\n            result += value;\n            return result;\n        }\n\n        function _log(level, args) {\n            if (window.console) {\n                var logger = window.console[level];\n                if (_isFunction(logger)) {\n                    var now = new Date();\n                    [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' +\n                        _zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));\n                    logger.apply(window.console, args);\n                }\n            }\n        }\n\n        this._warn = function() {\n            _log('warn', arguments);\n        };\n\n        this._info = function() {\n            if (_config.logLevel !== 'warn') {\n                _log('info', arguments);\n            }\n        };\n\n        this._debug = function() {\n            if (_config.logLevel === 'debug') {\n                _log('debug', arguments);\n            }\n        };\n\n        function _splitURL(url) {\n            // [1] = protocol://,\n            // [2] = host:port,\n            // [3] = host,\n            // [4] = IPv6_host,\n            // [5] = IPv4_host,\n            // [6] = :port,\n            // [7] = port,\n            // [8] = uri,\n            // [9] = rest (query / fragment)\n            return new RegExp('(^https?://)?(((\\\\[[^\\\\]]+])|([^:/?#]+))(:(\\\\d+))?)?([^?#]*)(.*)?').exec(url);\n        }\n\n        /**\n         * Returns whether the given hostAndPort is cross domain.\n         * The default implementation checks against window.location.host\n         * but this function can be overridden to make it work in non-browser\n         * environments.\n         *\n         * @param hostAndPort the host and port in format host:port\n         * @return whether the given hostAndPort is cross domain\n         */\n        this._isCrossDomain = function(hostAndPort) {\n            if (window.location && window.location.host) {\n                if (hostAndPort) {\n                    return hostAndPort !== window.location.host;\n                }\n            }\n            return false;\n        };\n\n        function _configure(configuration) {\n            _cometd._debug('Configuring cometd object with', configuration);\n            // Support old style param, where only the Bayeux server URL was passed.\n            if (_isString(configuration)) {\n                configuration = {\n                    url: configuration\n                };\n            }\n            if (!configuration) {\n                configuration = {};\n            }\n\n            _config = _cometd._mixin(false, _config, configuration);\n\n            var url = _cometd.getURL();\n            if (!url) {\n                throw 'Missing required configuration parameter \\'url\\' specifying the Bayeux server URL';\n            }\n\n            // Check if we're cross domain.\n            var urlParts = _splitURL(url);\n            var hostAndPort = urlParts[2];\n            var uri = urlParts[8];\n            var afterURI = urlParts[9];\n            _crossDomain = _cometd._isCrossDomain(hostAndPort);\n\n            // Check if appending extra path is supported.\n            if (_config.appendMessageTypeToURL) {\n                if (afterURI !== undefined && afterURI.length > 0) {\n                    _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n                    _config.appendMessageTypeToURL = false;\n                } else {\n                    var uriSegments = uri.split('/');\n                    var lastSegmentIndex = uriSegments.length - 1;\n                    if (uri.match(/\\/$/)) {\n                        lastSegmentIndex -= 1;\n                    }\n                    if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {\n                        // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd\n                        // It will be difficult to add the extra path in this case\n                        _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n                        _config.appendMessageTypeToURL = false;\n                    }\n                }\n            }\n\n            if (window.Worker && window.Blob && window.URL && _config.useWorkerScheduler) {\n                var code = WorkerScheduler.toString();\n                // Remove the function declaration, the opening brace and the closing brace.\n                code = code.substring(code.indexOf('{') + 1, code.lastIndexOf('}'));\n                var blob = new window.Blob([code], {\n                    type: 'application/json'\n                });\n                var blobURL = window.URL.createObjectURL(blob);\n                var worker = new window.Worker(blobURL);\n                _scheduler.setTimeout = function(funktion, delay) {\n                    var id = _scheduler.register(funktion);\n                    worker.postMessage({\n                        id: id,\n                        type: 'setTimeout',\n                        delay: delay\n                    });\n                    return id;\n                };\n                _scheduler.clearTimeout = function(id) {\n                    _scheduler.unregister(id);\n                    worker.postMessage({\n                        id: id,\n                        type: 'clearTimeout'\n                    });\n                };\n                worker.onmessage = function(e) {\n                    var id = e.data.id;\n                    var funktion = _scheduler.unregister(id);\n                    if (funktion) {\n                        funktion();\n                    }\n                };\n            }\n        }\n\n        function _removeListener(subscription) {\n            if (subscription) {\n                var subscriptions = _listeners[subscription.channel];\n                if (subscriptions && subscriptions[subscription.id]) {\n                    delete subscriptions[subscription.id];\n                    _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);\n                }\n            }\n        }\n\n        function _removeSubscription(subscription) {\n            if (subscription && !subscription.listener) {\n                _removeListener(subscription);\n            }\n        }\n\n        function _clearSubscriptions() {\n            for (var channel in _listeners) {\n                if (_listeners.hasOwnProperty(channel)) {\n                    var subscriptions = _listeners[channel];\n                    if (subscriptions) {\n                        for (var id in subscriptions) {\n                            if (subscriptions.hasOwnProperty(id)) {\n                                _removeSubscription(subscriptions[id]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        function _setStatus(newStatus) {\n            if (_status !== newStatus) {\n                _cometd._debug('Status', _status, '->', newStatus);\n                _status = newStatus;\n            }\n        }\n\n        function _isDisconnected() {\n            return _status === 'disconnecting' || _status === 'disconnected';\n        }\n\n        function _nextMessageId() {\n            var result = ++_messageId;\n            return '' + result;\n        }\n\n        function _applyExtension(scope, callback, name, message, outgoing) {\n            try {\n                return callback.call(scope, message);\n            } catch (x) {\n                var handler = _cometd.onExtensionException;\n                if (_isFunction(handler)) {\n                    _cometd._debug('Invoking extension exception handler', name, x);\n                    try {\n                        handler.call(_cometd, x, name, outgoing, message);\n                    } catch (xx) {\n                        _cometd._info('Exception during execution of extension exception handler', name, xx);\n                    }\n                } else {\n                    _cometd._info('Exception during execution of extension', name, x);\n                }\n                return message;\n            }\n        }\n\n        function _applyIncomingExtensions(message) {\n            for (var i = 0; i < _extensions.length; ++i) {\n                if (message === undefined || message === null) {\n                    break;\n                }\n\n                var extension = _extensions[i];\n                var callback = extension.extension.incoming;\n                if (_isFunction(callback)) {\n                    var result = _applyExtension(extension.extension, callback, extension.name, message, false);\n                    message = result === undefined ? message : result;\n                }\n            }\n            return message;\n        }\n\n        function _applyOutgoingExtensions(message) {\n            for (var i = _extensions.length - 1; i >= 0; --i) {\n                if (message === undefined || message === null) {\n                    break;\n                }\n\n                var extension = _extensions[i];\n                var callback = extension.extension.outgoing;\n                if (_isFunction(callback)) {\n                    var result = _applyExtension(extension.extension, callback, extension.name, message, true);\n                    message = result === undefined ? message : result;\n                }\n            }\n            return message;\n        }\n\n        function _notify(channel, message) {\n            var subscriptions = _listeners[channel];\n            if (subscriptions) {\n                for (var id in subscriptions) {\n                    if (subscriptions.hasOwnProperty(id)) {\n                        var subscription = subscriptions[id];\n                        // Subscriptions may come and go, so the array may have 'holes'\n                        if (subscription) {\n                            try {\n                                subscription.callback.call(subscription.scope, message);\n                            } catch (x) {\n                                var handler = _cometd.onListenerException;\n                                if (_isFunction(handler)) {\n                                    _cometd._debug('Invoking listener exception handler', subscription, x);\n                                    try {\n                                        handler.call(_cometd, x, subscription, subscription.listener, message);\n                                    } catch (xx) {\n                                        _cometd._info('Exception during execution of listener exception handler', subscription, xx);\n                                    }\n                                } else {\n                                    _cometd._info('Exception during execution of listener', subscription, message, x);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        function _notifyListeners(channel, message) {\n            // Notify direct listeners\n            _notify(channel, message);\n\n            // Notify the globbing listeners\n            var channelParts = channel.split('/');\n            var last = channelParts.length - 1;\n            for (var i = last; i > 0; --i) {\n                var channelPart = channelParts.slice(0, i).join('/') + '/*';\n                // We don't want to notify /foo/* if the channel is /foo/bar/baz,\n                // so we stop at the first non recursive globbing\n                if (i === last) {\n                    _notify(channelPart, message);\n                }\n                // Add the recursive globber and notify\n                channelPart += '*';\n                _notify(channelPart, message);\n            }\n        }\n\n        function _cancelDelayedSend() {\n            if (_scheduledSend !== null) {\n                _cometd.clearTimeout(_scheduledSend);\n            }\n            _scheduledSend = null;\n        }\n\n        function _delayedSend(operation, delay) {\n            _cancelDelayedSend();\n            var time = _advice.interval + delay;\n            _cometd._debug('Function scheduled in', time, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);\n            _scheduledSend = _cometd.setTimeout(operation, time);\n        }\n\n        // Needed to break cyclic dependencies between function definitions\n        var _handleMessages;\n        var _handleFailure;\n\n        /**\n         * Delivers the messages to the CometD server\n         * @param messages the array of messages to send\n         * @param metaConnect true if this send is on /meta/connect\n         * @param extraPath an extra path to append to the Bayeux server URL\n         */\n        function _send(messages, metaConnect, extraPath) {\n            // We must be sure that the messages have a clientId.\n            // This is not guaranteed since the handshake may take time to return\n            // (and hence the clientId is not known yet) and the application\n            // may create other messages.\n            for (var i = 0; i < messages.length; ++i) {\n                var message = messages[i];\n                var messageId = message.id;\n\n                if (_clientId) {\n                    message.clientId = _clientId;\n                }\n\n                message = _applyOutgoingExtensions(message);\n                if (message !== undefined && message !== null) {\n                    // Extensions may have modified the message id, but we need to own it.\n                    message.id = messageId;\n                    messages[i] = message;\n                } else {\n                    delete _callbacks[messageId];\n                    messages.splice(i--, 1);\n                }\n            }\n\n            if (messages.length === 0) {\n                return;\n            }\n\n            if (metaConnect) {\n                _metaConnect = messages[0];\n            }\n\n            var url = _cometd.getURL();\n            if (_config.appendMessageTypeToURL) {\n                // If url does not end with '/', then append it\n                if (!url.match(/\\/$/)) {\n                    url = url + '/';\n                }\n                if (extraPath) {\n                    url = url + extraPath;\n                }\n            }\n\n            var envelope = {\n                url: url,\n                sync: false,\n                messages: messages,\n                onSuccess: function(rcvdMessages) {\n                    try {\n                        _handleMessages.call(_cometd, rcvdMessages);\n                    } catch (x) {\n                        _cometd._info('Exception during handling of messages', x);\n                    }\n                },\n                onFailure: function(conduit, messages, failure) {\n                    try {\n                        var transport = _cometd.getTransport();\n                        failure.connectionType = transport ? transport.getType() : \"unknown\";\n                        _handleFailure.call(_cometd, conduit, messages, failure);\n                    } catch (x) {\n                        _cometd._info('Exception during handling of failure', x);\n                    }\n                }\n            };\n            _cometd._debug('Send', envelope);\n            _transport.send(envelope, metaConnect);\n        }\n\n        function _queueSend(message) {\n            if (_batch > 0 || _internalBatch === true) {\n                _messageQueue.push(message);\n            } else {\n                _send([message], false);\n            }\n        }\n\n        /**\n         * Sends a complete bayeux message.\n         * This method is exposed as a public so that extensions may use it\n         * to send bayeux message directly, for example in case of re-sending\n         * messages that have already been sent but that for some reason must\n         * be resent.\n         */\n        this.send = _queueSend;\n\n        function _resetBackoff() {\n            _backoff = 0;\n        }\n\n        function _increaseBackoff() {\n            if (_backoff < _config.maxBackoff) {\n                _backoff += _config.backoffIncrement;\n            }\n            return _backoff;\n        }\n\n        /**\n         * Starts a the batch of messages to be sent in a single request.\n         * @see #_endBatch(sendMessages)\n         */\n        function _startBatch() {\n            ++_batch;\n            _cometd._debug('Starting batch, depth', _batch);\n        }\n\n        function _flushBatch() {\n            var messages = _messageQueue;\n            _messageQueue = [];\n            if (messages.length > 0) {\n                _send(messages, false);\n            }\n        }\n\n        /**\n         * Ends the batch of messages to be sent in a single request,\n         * optionally sending messages present in the message queue depending\n         * on the given argument.\n         * @see #_startBatch()\n         */\n        function _endBatch() {\n            --_batch;\n            _cometd._debug('Ending batch, depth', _batch);\n            if (_batch < 0) {\n                throw 'Calls to startBatch() and endBatch() are not paired';\n            }\n\n            if (_batch === 0 && !_isDisconnected() && !_internalBatch) {\n                _flushBatch();\n            }\n        }\n\n        /**\n         * Sends the connect message\n         */\n        function _connect() {\n            if (!_isDisconnected()) {\n                var bayeuxMessage = {\n                    id: _nextMessageId(),\n                    channel: '/meta/connect',\n                    connectionType: _transport.getType()\n                };\n\n                // In case of reload or temporary loss of connection\n                // we want the next successful connect to return immediately\n                // instead of being held by the server, so that connect listeners\n                // can be notified that the connection has been re-established\n                if (!_connected) {\n                    bayeuxMessage.advice = {\n                        timeout: 0\n                    };\n                }\n\n                _setStatus('connecting');\n                _cometd._debug('Connect sent', bayeuxMessage);\n                _send([bayeuxMessage], true, 'connect');\n                _setStatus('connected');\n            }\n        }\n\n        function _delayedConnect(delay) {\n            _setStatus('connecting');\n            _delayedSend(function() {\n                _connect();\n            }, delay);\n        }\n\n        function _updateAdvice(newAdvice) {\n            if (newAdvice) {\n                _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);\n                _cometd._debug('New advice', _advice);\n            }\n        }\n\n        function _disconnect(abort) {\n            _cancelDelayedSend();\n            if (abort && _transport) {\n                _transport.abort();\n            }\n            _crossDomain = false;\n            _transport = null;\n            _setStatus('disconnected');\n            _clientId = null;\n            _batch = 0;\n            _resetBackoff();\n            _reestablish = false;\n            _connected = false;\n            _unconnectTime = 0;\n            _metaConnect = null;\n\n            // Fail any existing queued message\n            if (_messageQueue.length > 0) {\n                var messages = _messageQueue;\n                _messageQueue = [];\n                _handleFailure.call(_cometd, undefined, messages, {\n                    reason: 'Disconnected'\n                });\n            }\n        }\n\n        function _notifyTransportException(oldTransport, newTransport, failure) {\n            var handler = _cometd.onTransportException;\n            if (_isFunction(handler)) {\n                _cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);\n                try {\n                    handler.call(_cometd, failure, oldTransport, newTransport);\n                } catch (x) {\n                    _cometd._info('Exception during execution of transport exception handler', x);\n                }\n            }\n        }\n\n        /**\n         * Sends the initial handshake message\n         */\n        function _handshake(handshakeProps, handshakeCallback) {\n            if (_isFunction(handshakeProps)) {\n                handshakeCallback = handshakeProps;\n                handshakeProps = undefined;\n            }\n\n            _clientId = null;\n\n            _clearSubscriptions();\n\n            // Reset the transports if we're not retrying the handshake\n            if (_isDisconnected()) {\n                _transports.reset(true);\n            }\n\n            // Reset the advice.\n            _updateAdvice({});\n\n            _batch = 0;\n\n            // Mark the start of an internal batch.\n            // This is needed because handshake and connect are async.\n            // It may happen that the application calls init() then subscribe()\n            // and the subscribe message is sent before the connect message, if\n            // the subscribe message is not held until the connect message is sent.\n            // So here we start a batch to hold temporarily any message until\n            // the connection is fully established.\n            _internalBatch = true;\n\n            // Save the properties provided by the user, so that\n            // we can reuse them during automatic re-handshake\n            _handshakeProps = handshakeProps;\n            _handshakeCallback = handshakeCallback;\n\n            var version = '1.0';\n\n            // Figure out the transports to send to the server\n            var url = _cometd.getURL();\n            var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                version: version,\n                minimumVersion: version,\n                channel: '/meta/handshake',\n                supportedConnectionTypes: transportTypes,\n                advice: {\n                    timeout: _advice.timeout,\n                    interval: _advice.interval\n                }\n            };\n            // Do not allow the user to override important fields.\n            var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, handshakeCallback);\n\n            // Pick up the first available transport as initial transport\n            // since we don't know if the server supports it\n            if (!_transport) {\n                _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n                if (!_transport) {\n                    var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();\n                    _cometd._warn(failure);\n                    throw failure;\n                }\n            }\n\n            _cometd._debug('Initial transport is', _transport.getType());\n\n            // We started a batch to hold the application messages,\n            // so here we must bypass it and send immediately.\n            _setStatus('handshaking');\n            _cometd._debug('Handshake sent', message);\n            _send([message], false, 'handshake');\n        }\n\n        function _delayedHandshake(delay) {\n            _setStatus('handshaking');\n\n            // We will call _handshake() which will reset _clientId, but we want to avoid\n            // that between the end of this method and the call to _handshake() someone may\n            // call publish() (or other methods that call _queueSend()).\n            _internalBatch = true;\n\n            _delayedSend(function() {\n                _handshake(_handshakeProps, _handshakeCallback);\n            }, delay);\n        }\n\n        function _notifyCallback(callback, message) {\n            try {\n                callback.call(_cometd, message);\n            } catch (x) {\n                var handler = _cometd.onCallbackException;\n                if (_isFunction(handler)) {\n                    _cometd._debug('Invoking callback exception handler', x);\n                    try {\n                        handler.call(_cometd, x, message);\n                    } catch (xx) {\n                        _cometd._info('Exception during execution of callback exception handler', xx);\n                    }\n                } else {\n                    _cometd._info('Exception during execution of message callback', x);\n                }\n            }\n        }\n\n        this._getCallback = function(messageId) {\n            return _callbacks[messageId];\n        };\n\n        this._putCallback = function(messageId, callback) {\n            var result = this._getCallback(messageId);\n            if (_isFunction(callback)) {\n                _callbacks[messageId] = callback;\n            }\n            return result;\n        };\n\n        function _handleCallback(message) {\n            var callback = _cometd._getCallback([message.id]);\n            if (_isFunction(callback)) {\n                delete _callbacks[message.id];\n                _notifyCallback(callback, message);\n            }\n        }\n\n        function _handleRemoteCall(message) {\n            var context = _remoteCalls[message.id];\n            delete _remoteCalls[message.id];\n            if (context) {\n                _cometd._debug('Handling remote call response for', message, 'with context', context);\n\n                // Clear the timeout, if present.\n                var timeout = context.timeout;\n                if (timeout) {\n                    _cometd.clearTimeout(timeout);\n                }\n\n                var callback = context.callback;\n                if (_isFunction(callback)) {\n                    _notifyCallback(callback, message);\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        this.onTransportFailure = function(message, failureInfo, failureHandler) {\n            this._debug('Transport failure', failureInfo, 'for', message);\n\n            var transports = this.getTransportRegistry();\n            var url = this.getURL();\n            var crossDomain = this._isCrossDomain(_splitURL(url)[2]);\n            var version = '1.0';\n            var transportTypes = transports.findTransportTypes(version, crossDomain, url);\n\n            if (failureInfo.action === 'none') {\n                if (message.channel === '/meta/handshake') {\n                    if (!failureInfo.transport) {\n                        var failure = 'Could not negotiate transport, client=[' + transportTypes + '], server=[' + message.supportedConnectionTypes + ']';\n                        this._warn(failure);\n                        _notifyTransportException(_transport.getType(), null, {\n                            reason: failure,\n                            connectionType: _transport.getType(),\n                            transport: _transport\n                        });\n                    }\n                }\n            } else {\n                failureInfo.delay = this.getBackoffPeriod();\n                // Different logic depending on whether we are handshaking or connecting.\n                if (message.channel === '/meta/handshake') {\n                    if (!failureInfo.transport) {\n                        // The transport is invalid, try to negotiate again.\n                        var oldTransportType = _transport ? _transport.getType() : null;\n                        var newTransport = transports.negotiateTransport(transportTypes, version, crossDomain, url);\n                        if (!newTransport) {\n                            this._warn('Could not negotiate transport, client=[' + transportTypes + ']');\n                            _notifyTransportException(oldTransportType, null, message.failure);\n                            failureInfo.action = 'none';\n                        } else {\n                            var newTransportType = newTransport.getType();\n                            this._debug('Transport', oldTransportType, '->', newTransportType);\n                            _notifyTransportException(oldTransportType, newTransportType, message.failure);\n                            failureInfo.action = 'handshake';\n                            failureInfo.transport = newTransport;\n                        }\n                    }\n\n                    if (failureInfo.action !== 'none') {\n                        this.increaseBackoffPeriod();\n                    }\n                } else {\n                    var now = new Date().getTime();\n\n                    if (_unconnectTime === 0) {\n                        _unconnectTime = now;\n                    }\n\n                    if (failureInfo.action === 'retry') {\n                        failureInfo.delay = this.increaseBackoffPeriod();\n                        // Check whether we may switch to handshaking.\n                        var maxInterval = _advice.maxInterval;\n                        if (maxInterval > 0) {\n                            var expiration = _advice.timeout + _advice.interval + maxInterval;\n                            var unconnected = now - _unconnectTime;\n                            if (unconnected + _backoff > expiration) {\n                                failureInfo.action = 'handshake';\n                            }\n                        }\n                    }\n\n                    if (failureInfo.action === 'handshake') {\n                        failureInfo.delay = 0;\n                        transports.reset(false);\n                        this.resetBackoffPeriod();\n                    }\n                }\n            }\n\n            failureHandler.call(_cometd, failureInfo);\n        };\n\n        function _handleTransportFailure(failureInfo) {\n            _cometd._debug('Transport failure handling', failureInfo);\n\n            if (failureInfo.transport) {\n                _transport = failureInfo.transport;\n            }\n\n            if (failureInfo.url) {\n                _transport.setURL(failureInfo.url);\n            }\n\n            var action = failureInfo.action;\n            var delay = failureInfo.delay || 0;\n            switch (action) {\n                case 'handshake':\n                    _delayedHandshake(delay);\n                    break;\n                case 'retry':\n                    _delayedConnect(delay);\n                    break;\n                case 'none':\n                    _disconnect(true);\n                    break;\n                default:\n                    throw 'Unknown action ' + action;\n            }\n        }\n\n        function _failHandshake(message, failureInfo) {\n            _handleCallback(message);\n            _notifyListeners('/meta/handshake', message);\n            _notifyListeners('/meta/unsuccessful', message);\n\n            // The listeners may have disconnected.\n            if (_isDisconnected()) {\n                failureInfo.action = 'none';\n            }\n\n            _cometd.onTransportFailure.call(_cometd, message, failureInfo, _handleTransportFailure);\n        }\n\n        function _handshakeResponse(message) {\n            var url = _cometd.getURL();\n            if (message.successful) {\n                var crossDomain = _cometd._isCrossDomain(_splitURL(url)[2]);\n                var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, crossDomain, url);\n                if (newTransport === null) {\n                    message.successful = false;\n                    _failHandshake(message, {\n                        cause: 'negotiation',\n                        action: 'none',\n                        transport: null\n                    });\n                    return;\n                } else if (_transport !== newTransport) {\n                    _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());\n                    _transport = newTransport;\n                }\n\n                _clientId = message.clientId;\n\n                // End the internal batch and allow held messages from the application\n                // to go to the server (see _handshake() where we start the internal batch).\n                _internalBatch = false;\n                _flushBatch();\n\n                // Here the new transport is in place, as well as the clientId, so\n                // the listeners can perform a publish() if they want.\n                // Notify the listeners before the connect below.\n                message.reestablish = _reestablish;\n                _reestablish = true;\n\n                _handleCallback(message);\n                _notifyListeners('/meta/handshake', message);\n\n                _handshakeMessages = message['x-messages'] || 0;\n\n                var action = _isDisconnected() ? 'none' : _advice.reconnect || 'retry';\n                switch (action) {\n                    case 'retry':\n                        _resetBackoff();\n                        if (_handshakeMessages === 0) {\n                            _delayedConnect(0);\n                        } else {\n                            _cometd._debug('Processing', _handshakeMessages, 'handshake-delivered messages');\n                        }\n                        break;\n                    case 'none':\n                        _disconnect(true);\n                        break;\n                    default:\n                        throw 'Unrecognized advice action ' + action;\n                }\n            } else {\n                _failHandshake(message, {\n                    cause: 'unsuccessful',\n                    action: _advice.reconnect || 'handshake',\n                    transport: _transport\n                });\n            }\n        }\n\n        function _handshakeFailure(message) {\n            _failHandshake(message, {\n                cause: 'failure',\n                action: 'handshake',\n                transport: null\n            });\n        }\n\n        function _matchMetaConnect(connect) {\n            if (_status === 'disconnected') {\n                return true;\n            }\n            if (_metaConnect && _metaConnect.id === connect.id) {\n                _metaConnect = null;\n                return true;\n            }\n            return false;\n        }\n\n        function _failConnect(message, failureInfo) {\n            // Notify the listeners after the status change but before the next action.\n            _notifyListeners('/meta/connect', message);\n            _notifyListeners('/meta/unsuccessful', message);\n\n            // The listeners may have disconnected.\n            if (_isDisconnected()) {\n                failureInfo.action = 'none';\n            }\n\n            _cometd.onTransportFailure.call(_cometd, message, failureInfo, _handleTransportFailure);\n        }\n\n        function _connectResponse(message) {\n            if (_matchMetaConnect(message)) {\n                _connected = message.successful;\n                if (_connected) {\n                    _notifyListeners('/meta/connect', message);\n\n                    // Normally, the advice will say \"reconnect: 'retry', interval: 0\"\n                    // and the server will hold the request, so when a response returns\n                    // we immediately call the server again (long polling).\n                    // Listeners can call disconnect(), so check the state after they run.\n                    var action = _isDisconnected() ? 'none' : _advice.reconnect || 'retry';\n                    switch (action) {\n                        case 'retry':\n                            _resetBackoff();\n                            _delayedConnect(_backoff);\n                            break;\n                        case 'none':\n                            _disconnect(false);\n                            break;\n                        default:\n                            throw 'Unrecognized advice action ' + action;\n                    }\n                } else {\n                    _failConnect(message, {\n                        cause: 'unsuccessful',\n                        action: _advice.reconnect || 'retry',\n                        transport: _transport\n                    });\n                }\n            } else {\n                _cometd._debug('Mismatched /meta/connect reply', message);\n            }\n        }\n\n        function _connectFailure(message) {\n            if (_matchMetaConnect(message)) {\n                _connected = false;\n                _failConnect(message, {\n                    cause: 'failure',\n                    action: 'retry',\n                    transport: null\n                });\n            } else {\n                _cometd._debug('Mismatched /meta/connect failure', message);\n            }\n        }\n\n        function _failDisconnect(message) {\n            _disconnect(true);\n            _handleCallback(message);\n            _notifyListeners('/meta/disconnect', message);\n            _notifyListeners('/meta/unsuccessful', message);\n        }\n\n        function _disconnectResponse(message) {\n            if (message.successful) {\n                // Wait for the /meta/connect to arrive.\n                _disconnect(false);\n                _handleCallback(message);\n                _notifyListeners('/meta/disconnect', message);\n            } else {\n                _failDisconnect(message);\n            }\n        }\n\n        function _disconnectFailure(message) {\n            _failDisconnect(message);\n        }\n\n        function _failSubscribe(message) {\n            var subscriptions = _listeners[message.subscription];\n            if (subscriptions) {\n                for (var id in subscriptions) {\n                    if (subscriptions.hasOwnProperty(id)) {\n                        var subscription = subscriptions[id];\n                        if (subscription && !subscription.listener) {\n                            delete subscriptions[id];\n                            _cometd._debug('Removed failed subscription', subscription);\n                        }\n                    }\n                }\n            }\n            _handleCallback(message);\n            _notifyListeners('/meta/subscribe', message);\n            _notifyListeners('/meta/unsuccessful', message);\n        }\n\n        function _subscribeResponse(message) {\n            if (message.successful) {\n                _handleCallback(message);\n                _notifyListeners('/meta/subscribe', message);\n            } else {\n                _failSubscribe(message);\n            }\n        }\n\n        function _subscribeFailure(message) {\n            _failSubscribe(message);\n        }\n\n        function _failUnsubscribe(message) {\n            _handleCallback(message);\n            _notifyListeners('/meta/unsubscribe', message);\n            _notifyListeners('/meta/unsuccessful', message);\n        }\n\n        function _unsubscribeResponse(message) {\n            if (message.successful) {\n                _handleCallback(message);\n                _notifyListeners('/meta/unsubscribe', message);\n            } else {\n                _failUnsubscribe(message);\n            }\n        }\n\n        function _unsubscribeFailure(message) {\n            _failUnsubscribe(message);\n        }\n\n        function _failMessage(message) {\n            if (!_handleRemoteCall(message)) {\n                _handleCallback(message);\n                _notifyListeners('/meta/publish', message);\n                _notifyListeners('/meta/unsuccessful', message);\n            }\n        }\n\n        function _messageResponse(message) {\n            if (message.data !== undefined) {\n                if (!_handleRemoteCall(message)) {\n                    _notifyListeners(message.channel, message);\n                    if (_handshakeMessages > 0) {\n                        --_handshakeMessages;\n                        if (_handshakeMessages === 0) {\n                            _cometd._debug('Processed last handshake-delivered message');\n                            _delayedConnect(0);\n                        }\n                    }\n                }\n            } else {\n                if (message.successful === undefined) {\n                    _cometd._warn('Unknown Bayeux Message', message);\n                } else {\n                    if (message.successful) {\n                        _handleCallback(message);\n                        _notifyListeners('/meta/publish', message);\n                    } else {\n                        _failMessage(message);\n                    }\n                }\n            }\n        }\n\n        function _messageFailure(failure) {\n            _failMessage(failure);\n        }\n\n        function _receive(message) {\n            _unconnectTime = 0;\n\n            message = _applyIncomingExtensions(message);\n            if (message === undefined || message === null) {\n                return;\n            }\n\n            _updateAdvice(message.advice);\n\n            var channel = message.channel;\n            switch (channel) {\n                case '/meta/handshake':\n                    _handshakeResponse(message);\n                    break;\n                case '/meta/connect':\n                    _connectResponse(message);\n                    break;\n                case '/meta/disconnect':\n                    _disconnectResponse(message);\n                    break;\n                case '/meta/subscribe':\n                    _subscribeResponse(message);\n                    break;\n                case '/meta/unsubscribe':\n                    _unsubscribeResponse(message);\n                    break;\n                default:\n                    _messageResponse(message);\n                    break;\n            }\n        }\n\n        /**\n         * Receives a message.\n         * This method is exposed as a public so that extensions may inject\n         * messages simulating that they had been received.\n         */\n        this.receive = _receive;\n\n        _handleMessages = function(rcvdMessages) {\n            _cometd._debug('Received', rcvdMessages);\n\n            for (var i = 0; i < rcvdMessages.length; ++i) {\n                var message = rcvdMessages[i];\n                _receive(message);\n            }\n        };\n\n        _handleFailure = function(conduit, messages, failure) {\n            _cometd._debug('handleFailure', conduit, messages, failure);\n\n            failure.transport = conduit;\n            for (var i = 0; i < messages.length; ++i) {\n                var message = messages[i];\n                var failureMessage = {\n                    id: message.id,\n                    successful: false,\n                    channel: message.channel,\n                    failure: failure\n                };\n                failure.message = message;\n                switch (message.channel) {\n                    case '/meta/handshake':\n                        _handshakeFailure(failureMessage);\n                        break;\n                    case '/meta/connect':\n                        _connectFailure(failureMessage);\n                        break;\n                    case '/meta/disconnect':\n                        _disconnectFailure(failureMessage);\n                        break;\n                    case '/meta/subscribe':\n                        failureMessage.subscription = message.subscription;\n                        _subscribeFailure(failureMessage);\n                        break;\n                    case '/meta/unsubscribe':\n                        failureMessage.subscription = message.subscription;\n                        _unsubscribeFailure(failureMessage);\n                        break;\n                    default:\n                        _messageFailure(failureMessage);\n                        break;\n                }\n            }\n        };\n\n        function _hasSubscriptions(channel) {\n            var subscriptions = _listeners[channel];\n            if (subscriptions) {\n                for (var id in subscriptions) {\n                    if (subscriptions.hasOwnProperty(id)) {\n                        if (subscriptions[id]) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        function _resolveScopedCallback(scope, callback) {\n            var delegate = {\n                scope: scope,\n                method: callback\n            };\n            if (_isFunction(scope)) {\n                delegate.scope = undefined;\n                delegate.method = scope;\n            } else {\n                if (_isString(callback)) {\n                    if (!scope) {\n                        throw 'Invalid scope ' + scope;\n                    }\n                    delegate.method = scope[callback];\n                    if (!_isFunction(delegate.method)) {\n                        throw 'Invalid callback ' + callback + ' for scope ' + scope;\n                    }\n                } else if (!_isFunction(callback)) {\n                    throw 'Invalid callback ' + callback;\n                }\n            }\n            return delegate;\n        }\n\n        function _addListener(channel, scope, callback, isListener) {\n            // The data structure is a map<channel, subscription[]>, where each subscription\n            // holds the callback to be called and its scope.\n\n            var delegate = _resolveScopedCallback(scope, callback);\n            _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);\n\n            var id = ++_listenerId;\n            var subscription = {\n                id: id,\n                channel: channel,\n                scope: delegate.scope,\n                callback: delegate.method,\n                listener: isListener\n            };\n\n            var subscriptions = _listeners[channel];\n            if (!subscriptions) {\n                subscriptions = {};\n                _listeners[channel] = subscriptions;\n            }\n\n            subscriptions[id] = subscription;\n\n            _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);\n\n            return subscription;\n        }\n\n        //\n        // PUBLIC API\n        //\n\n        /**\n         * Registers the given transport under the given transport type.\n         * The optional index parameter specifies the \"priority\" at which the\n         * transport is registered (where 0 is the max priority).\n         * If a transport with the same type is already registered, this function\n         * does nothing and returns false.\n         * @param type the transport type\n         * @param transport the transport object\n         * @param index the index at which this transport is to be registered\n         * @return true if the transport has been registered, false otherwise\n         * @see #unregisterTransport(type)\n         */\n        this.registerTransport = function(type, transport, index) {\n            var result = _transports.add(type, transport, index);\n            if (result) {\n                this._debug('Registered transport', type);\n\n                if (_isFunction(transport.registered)) {\n                    transport.registered(type, this);\n                }\n            }\n            return result;\n        };\n\n        /**\n         * Unregisters the transport with the given transport type.\n         * @param type the transport type to unregister\n         * @return the transport that has been unregistered,\n         * or null if no transport was previously registered under the given transport type\n         */\n        this.unregisterTransport = function(type) {\n            var transport = _transports.remove(type);\n            if (transport !== null) {\n                this._debug('Unregistered transport', type);\n\n                if (_isFunction(transport.unregistered)) {\n                    transport.unregistered();\n                }\n            }\n            return transport;\n        };\n\n        this.unregisterTransports = function() {\n            _transports.clear();\n        };\n\n        /**\n         * @return an array of all registered transport types\n         */\n        this.getTransportTypes = function() {\n            return _transports.getTransportTypes();\n        };\n\n        this.findTransport = function(name) {\n            return _transports.find(name);\n        };\n\n        /**\n         * @returns the TransportRegistry object\n         */\n        this.getTransportRegistry = function() {\n            return _transports;\n        };\n\n        /**\n         * Configures the initial Bayeux communication with the Bayeux server.\n         * Configuration is passed via an object that must contain a mandatory field <code>url</code>\n         * of type string containing the URL of the Bayeux server.\n         * @param configuration the configuration object\n         */\n        this.configure = function(configuration) {\n            _configure.call(this, configuration);\n        };\n\n        /**\n         * Configures and establishes the Bayeux communication with the Bayeux server\n         * via a handshake and a subsequent connect.\n         * @param configuration the configuration object\n         * @param handshakeProps an object to be merged with the handshake message\n         * @see #configure(configuration)\n         * @see #handshake(handshakeProps)\n         */\n        this.init = function(configuration, handshakeProps) {\n            this.configure(configuration);\n            this.handshake(handshakeProps);\n        };\n\n        /**\n         * Establishes the Bayeux communication with the Bayeux server\n         * via a handshake and a subsequent connect.\n         * @param handshakeProps an object to be merged with the handshake message\n         * @param handshakeCallback a function to be invoked when the handshake is acknowledged\n         */\n        this.handshake = function(handshakeProps, handshakeCallback) {\n            if (_status !== 'disconnected') {\n                throw 'Illegal state: handshaken';\n            }\n            _handshake(handshakeProps, handshakeCallback);\n        };\n\n        /**\n         * Disconnects from the Bayeux server.\n         * @param disconnectProps an object to be merged with the disconnect message\n         * @param disconnectCallback a function to be invoked when the disconnect is acknowledged\n         */\n        this.disconnect = function(disconnectProps, disconnectCallback) {\n            if (_isDisconnected()) {\n                return;\n            }\n\n            if (_isFunction(disconnectProps)) {\n                disconnectCallback = disconnectProps;\n                disconnectProps = undefined;\n            }\n\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/disconnect'\n            };\n            // Do not allow the user to override important fields.\n            var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, disconnectCallback);\n\n            _setStatus('disconnecting');\n            _send([message], false, 'disconnect');\n        };\n\n        /**\n         * Marks the start of a batch of application messages to be sent to the server\n         * in a single request, obtaining a single response containing (possibly) many\n         * application reply messages.\n         * Messages are held in a queue and not sent until {@link #endBatch()} is called.\n         * If startBatch() is called multiple times, then an equal number of endBatch()\n         * calls must be made to close and send the batch of messages.\n         * @see #endBatch()\n         */\n        this.startBatch = function() {\n            _startBatch();\n        };\n\n        /**\n         * Marks the end of a batch of application messages to be sent to the server\n         * in a single request.\n         * @see #startBatch()\n         */\n        this.endBatch = function() {\n            _endBatch();\n        };\n\n        /**\n         * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}\n         * and {@link #endBatch()} calls.\n         * @param scope the scope of the callback, may be omitted\n         * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls\n         */\n        this.batch = function(scope, callback) {\n            var delegate = _resolveScopedCallback(scope, callback);\n            this.startBatch();\n            try {\n                delegate.method.call(delegate.scope);\n                this.endBatch();\n            } catch (x) {\n                this._info('Exception during execution of batch', x);\n                this.endBatch();\n                throw x;\n            }\n        };\n\n        /**\n         * Adds a listener for bayeux messages, performing the given callback in the given scope\n         * when a message for the given channel arrives.\n         * @param channel the channel the listener is interested to\n         * @param scope the scope of the callback, may be omitted\n         * @param callback the callback to call when a message is sent to the channel\n         * @returns the subscription handle to be passed to {@link #removeListener(object)}\n         * @see #removeListener(subscription)\n         */\n        this.addListener = function(channel, scope, callback) {\n            if (arguments.length < 2) {\n                throw 'Illegal arguments number: required 2, got ' + arguments.length;\n            }\n            if (!_isString(channel)) {\n                throw 'Illegal argument type: channel must be a string';\n            }\n\n            return _addListener(channel, scope, callback, true);\n        };\n\n        /**\n         * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.\n         * @param subscription the subscription to unsubscribe.\n         * @see #addListener(channel, scope, callback)\n         */\n        this.removeListener = function(subscription) {\n            // Beware of subscription.id == 0, which is falsy => cannot use !subscription.id\n            if (!subscription || !subscription.channel || !(\"id\" in subscription)) {\n                throw 'Invalid argument: expected subscription, not ' + subscription;\n            }\n\n            _removeListener(subscription);\n        };\n\n        /**\n         * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or\n         * {@link #subscribe(channel, scope, callback)}.\n         */\n        this.clearListeners = function() {\n            _listeners = {};\n        };\n\n        /**\n         * Subscribes to the given channel, performing the given callback in the given scope\n         * when a message for the channel arrives.\n         * @param channel the channel to subscribe to\n         * @param scope the scope of the callback, may be omitted\n         * @param callback the callback to call when a message is sent to the channel\n         * @param subscribeProps an object to be merged with the subscribe message\n         * @param subscribeCallback a function to be invoked when the subscription is acknowledged\n         * @return the subscription handle to be passed to {@link #unsubscribe(object)}\n         */\n        this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {\n            if (arguments.length < 2) {\n                throw 'Illegal arguments number: required 2, got ' + arguments.length;\n            }\n            if (!_isString(channel)) {\n                throw 'Illegal argument type: channel must be a string';\n            }\n            if (_isDisconnected()) {\n                throw 'Illegal state: disconnected';\n            }\n\n            // Normalize arguments\n            if (_isFunction(scope)) {\n                subscribeCallback = subscribeProps;\n                subscribeProps = callback;\n                callback = scope;\n                scope = undefined;\n            }\n            if (_isFunction(subscribeProps)) {\n                subscribeCallback = subscribeProps;\n                subscribeProps = undefined;\n            }\n\n            // Only send the message to the server if this client has not yet subscribed to the channel\n            var send = !_hasSubscriptions(channel);\n\n            var subscription = _addListener(channel, scope, callback, false);\n\n            if (send) {\n                // Send the subscription message after the subscription registration to avoid\n                // races where the server would send a message to the subscribers, but here\n                // on the client the subscription has not been added yet to the data structures\n                var bayeuxMessage = {\n                    id: _nextMessageId(),\n                    channel: '/meta/subscribe',\n                    subscription: channel\n                };\n                // Do not allow the user to override important fields.\n                var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);\n\n                // Save the callback.\n                _cometd._putCallback(message.id, subscribeCallback);\n\n                _queueSend(message);\n            }\n\n            return subscription;\n        };\n\n        /**\n         * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.\n         * @param subscription the subscription to unsubscribe.\n         * @param unsubscribeProps an object to be merged with the unsubscribe message\n         * @param unsubscribeCallback a function to be invoked when the unsubscription is acknowledged\n         */\n        this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {\n            if (arguments.length < 1) {\n                throw 'Illegal arguments number: required 1, got ' + arguments.length;\n            }\n            if (_isDisconnected()) {\n                throw 'Illegal state: disconnected';\n            }\n\n            if (_isFunction(unsubscribeProps)) {\n                unsubscribeCallback = unsubscribeProps;\n                unsubscribeProps = undefined;\n            }\n\n            // Remove the local listener before sending the message\n            // This ensures that if the server fails, this client does not get notifications\n            this.removeListener(subscription);\n\n            var channel = subscription.channel;\n            // Only send the message to the server if this client unsubscribes the last subscription\n            if (!_hasSubscriptions(channel)) {\n                var bayeuxMessage = {\n                    id: _nextMessageId(),\n                    channel: '/meta/unsubscribe',\n                    subscription: channel\n                };\n                // Do not allow the user to override important fields.\n                var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);\n\n                // Save the callback.\n                _cometd._putCallback(message.id, unsubscribeCallback);\n\n                _queueSend(message);\n            }\n        };\n\n        this.resubscribe = function(subscription, subscribeProps) {\n            _removeSubscription(subscription);\n            if (subscription) {\n                return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);\n            }\n            return undefined;\n        };\n\n        /**\n         * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},\n         * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.\n         */\n        this.clearSubscriptions = function() {\n            _clearSubscriptions();\n        };\n\n        /**\n         * Publishes a message on the given channel, containing the given content.\n         * @param channel the channel to publish the message to\n         * @param content the content of the message\n         * @param publishProps an object to be merged with the publish message\n         * @param publishCallback a function to be invoked when the publish is acknowledged by the server\n         */\n        this.publish = function(channel, content, publishProps, publishCallback) {\n            if (arguments.length < 1) {\n                throw 'Illegal arguments number: required 1, got ' + arguments.length;\n            }\n            if (!_isString(channel)) {\n                throw 'Illegal argument type: channel must be a string';\n            }\n            if (/^\\/meta\\//.test(channel)) {\n                throw 'Illegal argument: cannot publish to meta channels';\n            }\n            if (_isDisconnected()) {\n                throw 'Illegal state: disconnected';\n            }\n\n            if (_isFunction(content)) {\n                publishCallback = content;\n                content = {};\n                publishProps = undefined;\n            } else if (_isFunction(publishProps)) {\n                publishCallback = publishProps;\n                publishProps = undefined;\n            }\n\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: channel,\n                data: content\n            };\n            // Do not allow the user to override important fields.\n            var message = this._mixin(false, {}, publishProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, publishCallback);\n\n            _queueSend(message);\n        };\n\n        /**\n         * Publishes a message with binary data on the given channel.\n         * The binary data chunk may be an ArrayBuffer, a DataView, a TypedArray\n         * (such as Uint8Array) or a plain integer array.\n         * The meta data object may contain additional application data such as\n         * a file name, a mime type, etc.\n         * @param channel the channel to publish the message to\n         * @param data the binary data to publish\n         * @param last whether the binary data chunk is the last\n         * @param meta an object containing meta data associated to the binary chunk\n         * @param callback a function to be invoked when the publish is acknowledged by the server\n         */\n        this.publishBinary = function(channel, data, last, meta, callback) {\n            if (_isFunction(data)) {\n                callback = data;\n                data = new ArrayBuffer(0);\n                last = true;\n                meta = undefined;\n            } else if (_isFunction(last)) {\n                callback = last;\n                last = true;\n                meta = undefined;\n            } else if (_isFunction(meta)) {\n                callback = meta;\n                meta = undefined;\n            }\n            var content = {\n                meta: meta,\n                data: data,\n                last: last\n            };\n            var ext = {\n                ext: {\n                    binary: {}\n                }\n            };\n            this.publish(channel, content, ext, callback);\n        };\n\n        this.remoteCall = function(target, content, timeout, callProps, callback) {\n            if (arguments.length < 1) {\n                throw 'Illegal arguments number: required 1, got ' + arguments.length;\n            }\n            if (!_isString(target)) {\n                throw 'Illegal argument type: target must be a string';\n            }\n            if (_isDisconnected()) {\n                throw 'Illegal state: disconnected';\n            }\n\n            if (_isFunction(content)) {\n                callback = content;\n                content = {};\n                timeout = _config.maxNetworkDelay;\n                callProps = undefined;\n            } else if (_isFunction(timeout)) {\n                callback = timeout;\n                timeout = _config.maxNetworkDelay;\n                callProps = undefined;\n            } else if (_isFunction(callProps)) {\n                callback = callProps;\n                callProps = undefined;\n            }\n\n            if (typeof timeout !== 'number') {\n                throw 'Illegal argument type: timeout must be a number';\n            }\n\n            if (!target.match(/^\\//)) {\n                target = '/' + target;\n            }\n            var channel = '/service' + target;\n\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: channel,\n                data: content\n            };\n            var message = this._mixin(false, {}, callProps, bayeuxMessage);\n\n            var context = {\n                callback: callback\n            };\n            if (timeout > 0) {\n                context.timeout = _cometd.setTimeout(function() {\n                    _cometd._debug('Timing out remote call', message, 'after', timeout, 'ms');\n                    _failMessage({\n                        id: message.id,\n                        error: '406::timeout',\n                        successful: false,\n                        failure: {\n                            message: message,\n                            reason: 'Remote Call Timeout'\n                        }\n                    });\n                }, timeout);\n                _cometd._debug('Scheduled remote call timeout', message, 'in', timeout, 'ms');\n            }\n            _remoteCalls[message.id] = context;\n\n            _queueSend(message);\n        };\n\n        this.remoteCallBinary = function(target, data, last, meta, timeout, callback) {\n            if (_isFunction(data)) {\n                callback = data;\n                data = new ArrayBuffer(0);\n                last = true;\n                meta = undefined;\n                timeout = _config.maxNetworkDelay;\n            } else if (_isFunction(last)) {\n                callback = last;\n                last = true;\n                meta = undefined;\n                timeout = _config.maxNetworkDelay;\n            } else if (_isFunction(meta)) {\n                callback = meta;\n                meta = undefined;\n                timeout = _config.maxNetworkDelay;\n            } else if (_isFunction(timeout)) {\n                callback = timeout;\n                timeout = _config.maxNetworkDelay;\n            }\n\n            var content = {\n                meta: meta,\n                data: data,\n                last: last\n            };\n            var ext = {\n                ext: {\n                    binary: {}\n                }\n            };\n\n            this.remoteCall(target, content, timeout, ext, callback);\n        };\n\n        /**\n         * Returns a string representing the status of the bayeux communication with the Bayeux server.\n         */\n        this.getStatus = function() {\n            return _status;\n        };\n\n        /**\n         * Returns whether this instance has been disconnected.\n         */\n        this.isDisconnected = _isDisconnected;\n\n        /**\n         * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n         * Default value is 1 second, which means if there is a persistent failure the retries will happen\n         * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of\n         * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).\n         * @param period the backoff period to set\n         * @see #getBackoffIncrement()\n         */\n        this.setBackoffIncrement = function(period) {\n            _config.backoffIncrement = period;\n        };\n\n        /**\n         * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n         * @see #setBackoffIncrement(period)\n         */\n        this.getBackoffIncrement = function() {\n            return _config.backoffIncrement;\n        };\n\n        /**\n         * Returns the backoff period to wait before retrying an unsuccessful or failed message.\n         */\n        this.getBackoffPeriod = function() {\n            return _backoff;\n        };\n\n        /**\n         * Increases the backoff period up to the maximum value configured.\n         * @returns the backoff period after increment\n         * @see getBackoffIncrement\n         */\n        this.increaseBackoffPeriod = function() {\n            return _increaseBackoff();\n        };\n\n        /**\n         * Resets the backoff period to zero.\n         */\n        this.resetBackoffPeriod = function() {\n            _resetBackoff();\n        };\n\n        /**\n         * Sets the log level for console logging.\n         * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n         * less verbose to more verbose.\n         * @param level the log level string\n         */\n        this.setLogLevel = function(level) {\n            _config.logLevel = level;\n        };\n\n        /**\n         * Registers an extension whose callbacks are called for every incoming message\n         * (that comes from the server to this client implementation) and for every\n         * outgoing message (that originates from this client implementation for the\n         * server).\n         * The format of the extension object is the following:\n         * <pre>\n         * {\n         *     incoming: function(message) { ... },\n         *     outgoing: function(message) { ... }\n         * }\n         * </pre>\n         * Both properties are optional, but if they are present they will be called\n         * respectively for each incoming message and for each outgoing message.\n         * @param name the name of the extension\n         * @param extension the extension to register\n         * @return true if the extension was registered, false otherwise\n         * @see #unregisterExtension(name)\n         */\n        this.registerExtension = function(name, extension) {\n            if (arguments.length < 2) {\n                throw 'Illegal arguments number: required 2, got ' + arguments.length;\n            }\n            if (!_isString(name)) {\n                throw 'Illegal argument type: extension name must be a string';\n            }\n\n            var existing = false;\n            for (var i = 0; i < _extensions.length; ++i) {\n                var existingExtension = _extensions[i];\n                if (existingExtension.name === name) {\n                    existing = true;\n                    break;\n                }\n            }\n            if (!existing) {\n                _extensions.push({\n                    name: name,\n                    extension: extension\n                });\n                this._debug('Registered extension', name);\n\n                // Callback for extensions\n                if (_isFunction(extension.registered)) {\n                    extension.registered(name, this);\n                }\n\n                return true;\n            } else {\n                this._info('Could not register extension with name', name, 'since another extension with the same name already exists');\n                return false;\n            }\n        };\n\n        /**\n         * Unregister an extension previously registered with\n         * {@link #registerExtension(name, extension)}.\n         * @param name the name of the extension to unregister.\n         * @return true if the extension was unregistered, false otherwise\n         */\n        this.unregisterExtension = function(name) {\n            if (!_isString(name)) {\n                throw 'Illegal argument type: extension name must be a string';\n            }\n\n            var unregistered = false;\n            for (var i = 0; i < _extensions.length; ++i) {\n                var extension = _extensions[i];\n                if (extension.name === name) {\n                    _extensions.splice(i, 1);\n                    unregistered = true;\n                    this._debug('Unregistered extension', name);\n\n                    // Callback for extensions\n                    var ext = extension.extension;\n                    if (_isFunction(ext.unregistered)) {\n                        ext.unregistered();\n                    }\n\n                    break;\n                }\n            }\n            return unregistered;\n        };\n\n        /**\n         * Find the extension registered with the given name.\n         * @param name the name of the extension to find\n         * @return the extension found or null if no extension with the given name has been registered\n         */\n        this.getExtension = function(name) {\n            for (var i = 0; i < _extensions.length; ++i) {\n                var extension = _extensions[i];\n                if (extension.name === name) {\n                    return extension.extension;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Returns the name assigned to this CometD object, or the string 'default'\n         * if no name has been explicitly passed as parameter to the constructor.\n         */\n        this.getName = function() {\n            return _name;\n        };\n\n        /**\n         * Returns the clientId assigned by the Bayeux server during handshake.\n         */\n        this.getClientId = function() {\n            return _clientId;\n        };\n\n        /**\n         * Returns the URL of the Bayeux server.\n         */\n        this.getURL = function() {\n            if (_transport) {\n                var url = _transport.getURL();\n                if (url) {\n                    return url;\n                }\n                url = _config.urls[_transport.getType()];\n                if (url) {\n                    return url;\n                }\n            }\n            return _config.url;\n        };\n\n        this.getTransport = function() {\n            return _transport;\n        };\n\n        this.getConfiguration = function() {\n            return this._mixin(true, {}, _config);\n        };\n\n        this.getAdvice = function() {\n            return this._mixin(true, {}, _advice);\n        };\n\n        this.setTimeout = function(funktion, delay) {\n            return _scheduler.setTimeout(function() {\n                try {\n                    _cometd._debug('Invoking timed function', funktion);\n                    funktion();\n                } catch (x) {\n                    _cometd._debug('Exception invoking timed function', funktion, x);\n                }\n            }, delay);\n        };\n\n        this.clearTimeout = function(id) {\n            _scheduler.clearTimeout(id);\n        };\n\n        // Initialize transports.\n        if (window.WebSocket) {\n            this.registerTransport('websocket', new WebSocketTransport());\n        }\n        this.registerTransport('long-polling', new LongPollingTransport());\n        this.registerTransport('callback-polling', new CallbackPollingTransport());\n    };\n\n    var _z85EncodeTable = [\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n        'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n        'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',\n        'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n        'Y', 'Z', '.', '-', ':', '+', '=', '^', '!', '/',\n        '*', '?', '&', '<', '>', '(', ')', '[', ']', '{',\n        '}', '@', '%', '$', '#'\n    ];\n    var _z85DecodeTable = [\n        0x00, 0x44, 0x00, 0x54, 0x53, 0x52, 0x48, 0x00,\n        0x4B, 0x4C, 0x46, 0x41, 0x00, 0x3F, 0x3E, 0x45,\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n        0x08, 0x09, 0x40, 0x00, 0x49, 0x42, 0x4A, 0x47,\n        0x51, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A,\n        0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,\n        0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A,\n        0x3B, 0x3C, 0x3D, 0x4D, 0x00, 0x4E, 0x43, 0x00,\n        0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,\n        0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,\n        0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,\n        0x21, 0x22, 0x23, 0x4F, 0x00, 0x50, 0x00, 0x00\n    ];\n    var Z85 = {\n        encode: function(bytes) {\n            var buffer = null;\n            if (bytes instanceof ArrayBuffer) {\n                buffer = bytes;\n            } else if (bytes.buffer instanceof ArrayBuffer) {\n                buffer = bytes.buffer;\n            } else if (Array.isArray(bytes)) {\n                buffer = new Uint8Array(bytes).buffer;\n            }\n            if (buffer == null) {\n                throw 'Cannot Z85 encode ' + bytes;\n            }\n\n            var length = buffer.byteLength;\n            var remainder = length % 4;\n            var padding = 4 - (remainder === 0 ? 4 : remainder);\n            var view = new DataView(buffer);\n            var result = '';\n            var value = 0;\n            for (var i = 0; i < length + padding; ++i) {\n                var isPadding = i >= length;\n                value = value * 256 + (isPadding ? 0 : view.getUint8(i));\n                if ((i + 1) % 4 === 0) {\n                    var divisor = 85 * 85 * 85 * 85;\n                    for (var j = 5; j > 0; --j) {\n                        if (!isPadding || j > padding) {\n                            var code = Math.floor(value / divisor) % 85;\n                            result += _z85EncodeTable[code];\n                        }\n                        divisor /= 85;\n                    }\n                    value = 0;\n                }\n            }\n\n            return result;\n        },\n        decode: function(string) {\n            var remainder = string.length % 5;\n            var padding = 5 - (remainder === 0 ? 5 : remainder);\n            for (var p = 0; p < padding; ++p) {\n                string += _z85EncodeTable[_z85EncodeTable.length - 1];\n            }\n            var length = string.length;\n\n            var buffer = new ArrayBuffer((length * 4 / 5) - padding);\n            var view = new DataView(buffer);\n            var value = 0;\n            var charIdx = 0;\n            var byteIdx = 0;\n            for (var i = 0; i < length; ++i) {\n                var code = string.charCodeAt(charIdx++) - 32;\n                value = value * 85 + _z85DecodeTable[code];\n                if (charIdx % 5 === 0) {\n                    var divisor = 256 * 256 * 256;\n                    while (divisor >= 1) {\n                        if (byteIdx < view.byteLength) {\n                            view.setUint8(byteIdx++, Math.floor(value / divisor) % 256);\n                        }\n                        divisor /= 256;\n                    }\n                    value = 0;\n                }\n            }\n\n            return buffer;\n        }\n    };\n\n    return {\n        CometD: CometD,\n        Transport: Transport,\n        RequestTransport: RequestTransport,\n        LongPollingTransport: LongPollingTransport,\n        CallbackPollingTransport: CallbackPollingTransport,\n        WebSocketTransport: WebSocketTransport,\n        Utils: Utils,\n        Z85: Z85\n    };\n}));\n","const lib = require('cometd');\nmodule.exports = {\n  CometD: lib.CometD,\n  default: lib\n};\n","import { CometD } from 'isomorphic-cometd';\nimport { IFetchClient } from '../core';\nimport { MetaChannel } from './MetaChannel';\n\nexport interface ICometdConfig {\n  url: string;\n  logLevel?: string;\n  requestHeaders?: any;\n  appendMessageTypeToURL?: boolean;\n  stickyReconnect?: boolean;\n}\n\nexport class Realtime {\n  private cometd: CometD = new CometD();\n\n  /**\n   * Allows to set up a realtime (websocket or long-polling) connection to the platform.\n   * @param client The fetch client instance to use\n   * @param url The URL to connect to\n   * @param handshakeCallback A function which is called on succeeded or failed handshake\n   */\n  constructor(\n    private client: IFetchClient,\n    private url: string = '/notification/realtime',\n    handshakeCallback?\n  ) {\n    this.cometd.websocketEnabled = true;\n    this.cometd.addListener(MetaChannel.HANDSHAKE, handshakeCallback || this.metaHandshake);\n  }\n\n  /**\n   * Subscribes to a realtime channel to listen for data.\n   * @param channel The channel to connect to\n   * @param callback A function to call when data is received\n   */\n  subscribe(channel: string, callback: (data: any) => void): object {\n    this.checkConnection();\n    return this.cometd.subscribe(channel, callback);\n  }\n\n  /**\n   * Cancels the listening to a channel.\n   * @param subscription The subscription object returned by subscribe()\n   */\n  unsubscribe(subscription: object): object {\n    return this.cometd.unsubscribe(subscription);\n  }\n\n  /**\n   * Disconnects the current connection.\n   */\n  disconnect(): void {\n    this.cometd.disconnect();\n  }\n\n  private checkConnection() {\n    const { cometd, client, url } = this;\n    if (cometd.isDisconnected()) {\n      const { headers } = client.getFetchOptions();\n      const config = {\n        url: client.getUrl(url),\n        requestHeaders: headers\n      };\n      cometd.configure(config);\n      this.handshake(client.getCometdHandshake());\n    }\n  }\n\n  private handshake(config: object) {\n    this.cometd.handshake(config);\n  }\n\n  private metaHandshake = msg => {\n    if (!msg.successful) {\n      throw new Error('Handshake failed');\n    }\n  }\n}\n","import { Service } from './Service';\nimport { IResultList } from './IResultList';\n\n/**\n * Paging allows you to query the next and previous data chunks\n * in a convenient way. You can also go to a specific page or just read\n * page information about the current data chunk.\n * Note that page numbers are generated by backend\n * and may be used as offset rather than a continuous range of positive numbers\n * (e.g. in case of users with restricted permissions).\n */\nexport class Paging<TData> {\n  /**\n   * Holds the number of the current page, so in fact\n   * the data chunk you are looking at.\n   */\n  currentPage: number;\n  /**\n   * Holds the number of the next page.\n   */\n  nextPage: number;\n  /**\n   * Holds the number of the previous page.\n   */\n  prevPage: number;\n  /**\n   * Holds the number of the maximum data that you will\n   * get with the response.\n   */\n  pageSize: number;\n  /**\n   * Holds the number of total pages regarding to the\n   * given page size.\n   */\n  totalPages: number;\n\n  private service: Service<TData>;\n  private filter: object;\n\n  constructor(service: Service<TData>, statistics: any, filter: object) {\n    this.filter = filter;\n    this.service = service;\n    this.currentPage = statistics.currentPage;\n    this.nextPage = statistics.nextPage;\n    this.prevPage = statistics.prevPage;\n    this.pageSize = statistics.pageSize;\n    this.totalPages = statistics.totalPages;\n  }\n\n  /**\n   * Gets the next page of available data from the server.\n   * @param filter\n   */\n  async next(filter: object = {}): Promise<IResultList<TData>> {\n    return this.list(this.getFilter(filter, this.nextPage));\n  }\n\n  /**\n   * Gets the previous page of available data from server.\n   * @param filter\n   */\n  async prev(filter: object = {}): Promise<IResultList<TData>> {\n    return this.list(this.getFilter(filter, this.prevPage));\n  }\n\n  /**\n   * Method used by next(), prev() and goto() to call the service.list method.\n   * It is public so it can be overriden in special cases (like children objects\n   * in inventory).\n   * @param filter\n   */\n  async list(filter: object = {}): Promise<IResultList<TData>> {\n    return this.service.list(filter);\n  }\n\n  /**\n   * Goes to the page that you define as page parameter.\n   * @param page\n   * @param filter\n   */\n  async goto(page: number, filter: object = {}): Promise<IResultList<TData>> {\n    return this.list(this.getFilter(filter, page));\n  }\n\n  private getFilter(filter: object, page: number) {\n    return Object.assign(filter, this.filter, { currentPage: page });\n  }\n}\n","import { IFetchClient } from './IFetchClient';\nimport { IFetchOptions } from './IFetchOptions';\nimport { IFetchResponse } from './IFetchResponse';\nimport { IIdentified } from './IIdentified';\nimport { IResult } from './IResult';\nimport { IResultList } from './IResultList';\nimport { Paging } from './Paging';\n\nimport { Realtime } from '../realtime/index';\n\nexport abstract class Service<TData extends IIdentified> {\n  protected propertyName: string;\n  protected abstract baseUrl: string;\n  protected abstract listUrl: string;\n  protected channel: string;\n  private cache = new Map();\n\n  constructor(protected client: IFetchClient, protected realtime?: Realtime) {\n    const methodsToHide = ['list', 'create', 'update', 'detail', 'delete'];\n    const prototype = Object.getPrototypeOf(this);\n    methodsToHide.forEach(method => {\n      if (!prototype.hasOwnProperty(method)) {\n        Object.defineProperty(this, method, {\n          get() {\n            return undefined;\n          }\n        });\n      }\n    });\n  }\n\n  async list(filter: object = {}): Promise<IResultList<TData>> {\n    const headers = { accept: 'application/json' };\n    const url = this.listUrl;\n    const res = await this.fetch(url, this.changeFetchOptions({ headers, params: filter }, url));\n    const json = await res.json();\n    const data = this.propertyName ? json[this.propertyName] : json;\n    const paging = this.getPaging(json, filter);\n    return { res, data, paging };\n  }\n\n  protected async detail(\n    entityOrId: string | number | IIdentified,\n    filter: object = {}\n  ): Promise<IResult<TData>> {\n    const headers = { accept: 'application/json' };\n    const url = this.getDetailUrl(entityOrId);\n    const res = await this.fetch(\n      url,\n      this.changeFetchOptions({ headers, params: { ...filter } }, url)\n    );\n    const data = await res.json();\n    return { res, data };\n  }\n\n  protected async create(entity: Partial<TData>): Promise<IResult<TData>> {\n    const url = this.listUrl;\n    const method = 'POST';\n    const body = JSON.stringify(this.onBeforeCreate(entity));\n    const headers = { 'content-type': 'application/json', accept: 'application/json' };\n    const res = await this.fetch(url, this.changeFetchOptions({ method, body, headers }, url));\n    const data = await res.json();\n    return { res, data };\n  }\n\n  protected async update(entity: Partial<TData>): Promise<IResult<TData>> {\n    const url = this.getDetailUrl(entity);\n    const method = 'PUT';\n    const body = JSON.stringify(this.onBeforeUpdate(entity));\n    const headers = { 'content-type': 'application/json', accept: 'application/json' };\n    const res = await this.fetch(url, this.changeFetchOptions({ method, body, headers }, url));\n    const data = await res.json();\n    return { res, data };\n  }\n\n  protected async delete(\n    entityOrId: string | number | IIdentified,\n    params?: any\n  ): Promise<IResult<null>> {\n    const method = 'DELETE';\n    const url = this.getDetailUrl(entityOrId);\n    const res = await this.fetch(url, this.changeFetchOptions({ method, params }, url));\n    return { res, data: null };\n  }\n\n  protected onBeforeCreate(obj: Partial<TData>): Partial<TData> {\n    delete obj.id;\n    return obj;\n  }\n\n  protected onBeforeUpdate(objWithId: Partial<TData>): Partial<TData> {\n    return objWithId;\n  }\n\n  protected changeFetchOptions(options: any, url: string = '') {\n    return options;\n  }\n\n  protected getUrl(url: string = ''): string {\n    const baseUrl = this.baseUrl.replace(/\\/+$/, '');\n    const partialUrl = url.replace(/^\\/+/, '');\n    return `${baseUrl}/${partialUrl}`;\n  }\n\n  protected getDetailUrl(entityOrId: string | number | IIdentified): string {\n    let id: string | number;\n    if (typeof entityOrId === 'object' && entityOrId.id) {\n      id = entityOrId.id;\n    } else {\n      id = entityOrId as string | number;\n    }\n    return `${this.listUrl}/${id}`;\n  }\n\n  protected async fetch(url: string, init?: IFetchOptions): Promise<IFetchResponse> {\n    const fullUrl = this.getUrl(url);\n    const res: IFetchResponse = await this.client.fetch(fullUrl, init);\n    if (res.status >= 400) {\n      let data = null;\n      try {\n        data = await res.json();\n      } catch (ex) {\n        try {\n          data = await res.text();\n        } catch (ex) {\n          // do nothing\n        }\n      }\n      throw { res, data };\n    }\n    return res;\n  }\n\n  protected mimeType(type: string): string {\n    return `application/vnd.com.nsn.cumulocity.${type}+json`;\n  }\n\n  protected getIdString(reference: number | string | IIdentified): string {\n    let id;\n    if (typeof reference === 'object') {\n      id = reference.id;\n    } else {\n      id = reference;\n    }\n    return String(id);\n  }\n\n  protected getPaging(json: any, filter: object): Paging<TData> {\n    if (json.statistics) {\n      const statistics = {\n        ...json.statistics,\n        nextPage: this.getCurrentPageFromLink(json.next),\n        prevPage: this.getCurrentPageFromLink(json.prev)\n      };\n      return new Paging<TData>(this, statistics, filter);\n    }\n    return null;\n  }\n\n  protected getCurrentPageFromLink(link: string = '') {\n    const matches = link.match(/currentPage=(-{0,1}\\d+)/);\n    return matches && parseInt(matches[1], 10);\n  }\n}\n","var __root__ = (function (root) {\nfunction F() { this.fetch = false; }\nF.prototype = root;\nreturn new F();\n})(typeof self !== 'undefined' ? self : this);\n(function(self) {\n\n(function(self) {\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    };\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue+','+value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) { items.push(name); });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) { items.push(value); });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) { items.push([name, value]); });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=');\n        var name = split.shift().replace(/\\+/g, ' ');\n        var value = split.join('=').replace(/\\+/g, ' ');\n        form.append(decodeURIComponent(name), decodeURIComponent(value));\n      }\n    });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = 'status' in options ? options.status : 200;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n      var xhr = new XMLHttpRequest();\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  };\n  self.fetch.polyfill = true;\n})(typeof self !== 'undefined' ? self : this);\n}).call(__root__, void(0));\nvar fetch = __root__.fetch;\nvar Response = fetch.Response = __root__.Response;\nvar Request = fetch.Request = __root__.Request;\nvar Headers = fetch.Headers = __root__.Headers;\nif (typeof module === 'object' && module.exports) {\nmodule.exports = fetch;\n}\n","import fetch from 'cross-fetch';\n\nimport { IFetchClient } from './IFetchClient';\nimport { IFetchOptions } from './IFetchOptions';\nimport { IFetchResponse } from './IFetchResponse';\nimport { IAuthentication } from './IAuthentication';\n\nlet auths = new WeakMap(); // tslint:disable-line\n\nexport class FetchClient implements IFetchClient {\n  tenant: string = '';\n  defaultHeaders = {};\n  constructor(\n    authOrBaseUrl?: IAuthentication | string,\n    public baseUrl?: string,\n  ) {\n    if (typeof authOrBaseUrl === 'string') {\n      baseUrl = authOrBaseUrl;\n    } else {\n      this.setAuth(authOrBaseUrl);\n    }\n    this.baseUrl = this.resolveServerUrl(baseUrl);\n  }\n\n  setAuth(auth: IAuthentication) {\n    auths.set(this, auth);\n  }\n\n  async fetch(url: string, init?: IFetchOptions): Promise<IFetchResponse> {\n    let fetchFn = fetch;\n    try { fetchFn = window.fetch || fetchFn; } catch (e) { /* do nothing */ }\n    const fullUrl: string = this.getUrl(url, init);\n    const options: IFetchOptions = this.getFetchOptions(init);\n    return fetchFn(fullUrl, options);\n  }\n\n  getUrl(url: string = '', options?: IFetchOptions): string {\n    const params = options && options.params;\n    let paramPart = '';\n    if (params && Object.keys(params).length) {\n      paramPart = Object.keys(params)\n        .map((k) => {\n          let vals = params[k];\n          const encodedKey = encodeURIComponent(k);\n          if (!Array.isArray(vals)) {\n            vals = [vals];\n          }\n          return vals.map((v) => `${encodedKey}=${encodeURIComponent(v)}`).join('&');\n        })\n        .join('&');\n      paramPart = `?${paramPart}`;\n    }\n    const baseUrl = this.baseUrl.replace(/\\/+$/, '').replace(/^\\/+/, '');\n    const partialUrl = url.replace(/\\/+$/, '').replace(/^\\/+/, '');\n    return `${baseUrl}/${partialUrl}${paramPart}`;\n  }\n\n  getFetchOptions(options: IFetchOptions = {}): IFetchOptions {\n    const auth = auths.get(this);\n    options.headers = Object.assign({}, this.defaultHeaders, options.headers, { UseXBasic: true });\n    delete options.params;\n    options = auth ? auth.getFetchOptions(options) : options;\n    return options;\n  }\n\n  getCometdHandshake(config: any = {}) {\n    const auth = auths.get(this);\n    return auth ? auth.getCometdHandshake(config) : config;\n  }\n\n  private resolveServerUrl(baseUrl: string = ''): any {\n    if (baseUrl && baseUrl.startsWith('http')) {\n      return baseUrl.replace(/\\/+$/, '');\n    }\n    try {\n      const location = window.location;\n      return `${location.protocol}//${location.host}/${baseUrl.replace(/\\/+$/, '')}`;\n    } catch (ex) {\n      throw Error('Your environment does not support relative URLs. Please provide a base URL.');\n    }\n  }\n}\n","export var error = function (message) {\n  function E() {\n    this.message = message;\n  }\n\n  E.prototype = new Error();\n  E.prototype.name = 'InvalidCharacterError';\n  E.prototype.code = 5;\n  return E;\n};\nexport var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';","import { chars, error } from './common'; // btoa polyfill for IE<10 courtesy https://gist.github.com/nignag/999166\n\nvar E = error('The string to be encoded contains characters out of range');\nexport var _btoa = typeof btoa !== 'undefined'\n/* istanbul ignore next */\n? function (input) {\n  return btoa(input);\n} : function (input) {\n  var str = String(input);\n  var output = '';\n\n  for ( // initialize result and counter\n  var block, charCode, idx = 0, map = chars; // if the next str index does not exist:\n  //   change the mapping table to \"=\"\n  //   check if d has no fractional digits\n  str.charAt(idx | 0) || (map = '=', idx % 1); // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {\n    charCode = str.charCodeAt(idx += 3 / 4);\n\n    if (charCode > 0xFF) {\n      throw new E();\n    }\n\n    block = block << 8 | charCode;\n  }\n\n  return output;\n};\n\nvar utf8 = function (input) {\n  return encodeURIComponent(input).replace(/%([0-9A-F]{2})/g, function (match, p1) {\n    return String.fromCharCode('0x' + p1);\n  });\n};\n\nexport default (function (input) {\n  return _btoa(utf8(input));\n});","import { IAuthentication, ICredentials } from './IAuthentication';\nimport { btoa } from 'b2a';\n\n// this is var and not const to please typedoc https://github.com/TypeStrong/typedoc/issues/691\nvar secrets = new WeakMap(); // tslint:disable-line\n\n/**\n * Allows to use Basic-Auth for Authorization to the\n * Cumulocity API.\n */\nexport class BasicAuth implements IAuthentication {\n\n  user: string;\n  /**\n   * Authenticates the given user against the given tenant.\n   * @param name\n   * @param password\n   * @param tenant\n   */\n  constructor(credentials?: ICredentials) {\n    this.updateCredentials(credentials);\n  }\n\n  updateCredentials({ tenant, user, password, token, tfa }: ICredentials = {}) {\n    const secret = secrets.get(this) || {};\n    if (user && tenant) { user = `${tenant}/${user}`; }\n    user = user || this.user;\n    password = password || secret.password;\n    if (!token && user && password) { token = btoa(`${user}:${password}`); }\n    if (user) { this.user = user; }\n    token = token || secret.token;\n    tfa = tfa || secret.tfa;\n    secrets.set(this, { tfa, token, password });\n    return token;\n  }\n\n  getFetchOptions(options) {\n    const secret = secrets.get(this);\n    const { token, tfa } = secret;\n    const xsrfToken = this.getCookieValue('XSRF-TOKEN');\n    const headers: any = {\n      Authorization: `Basic ${token || ''}`,\n      ...(xsrfToken ? { 'X-XSRF-TOKEN': xsrfToken } : undefined)\n    };\n\n    if (tfa) {\n      headers.tfatoken = tfa;\n    }\n    options.headers = Object.assign(headers, options.headers);\n    return options;\n  }\n\n  getCometdHandshake(config: { ext?: {} } = {}) {\n    const secret = secrets.get(this);\n    const { token, tfa } = secret;\n    const KEY = 'com.cumulocity.authn';\n    const ext = config.ext = config.ext || {};\n    const auth = ext[KEY] = Object.assign(ext[KEY] || {}, { token, tfa });\n    return config;\n  }\n\n  logout() {\n    delete this.user;\n    secrets.set(this, {});\n  }\n\n  private getCookieValue(name) {\n    try {\n      const value = document.cookie.match('(^|;)\\\\s*' + name + '\\\\s*=\\\\s*([^;]+)');\n      return value ? value.pop() : undefined;\n    } catch (ex) {\n      return undefined;\n    }\n  }\n}\n","import { chars, error } from './common';\nvar E = error('The string to be decoded is not correctly encoded');\nexport var _atob = typeof atob !== 'undefined'\n/* istanbul ignore next */\n? function (input) {\n  return atob(input);\n} : function (input) {\n  var str = String(input).replace(/[=]+$/, '');\n\n  if (str.length % 4 == 1) {\n    throw new E();\n  }\n\n  var output = '';\n\n  for ( // initialize result and counters\n  var bc = 0, bs, buffer, idx = 0; // get next character\n  buffer = str.charAt(idx++); // character found in table? initialize bit storage and add its ascii value;\n  ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,\n  // convert the first 8 bits to one ascii character\n  bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n    // try to find character in table (0-63, not found => -1)\n    buffer = chars.indexOf(buffer);\n  }\n\n  return output;\n};\n\nvar utf16 = function (input) {\n  return decodeURIComponent(input.split('').map(function (c) {\n    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(''));\n};\n\nexport default (function (input) {\n  return utf16(_atob(input));\n});","/** Identity function used for marking strings for translation */\nexport const gettext = t => t;\n","import { gettext } from '../gettext';\n\n/**\n * Severity can be one of the following states.\n * It is used in [[AlarmService]] for example.\n */\nexport enum Severity {\n  CRITICAL = gettext('CRITICAL'),\n  MAJOR = gettext('MAJOR'),\n  MINOR = gettext('MINOR'),\n  WARNING = gettext('WARNING')\n}\n","export class QueriesUtil {\n  protected operatorFns = {\n    __not: operand => {\n      return `not(${this.buildQueryFilter(operand, null)})`;\n    },\n    __and: operand => {\n      return this.buildQueryFilter(operand, null, 'and');\n    },\n    __or: operand => {\n      return this.buildQueryFilter(operand, null, 'or');\n    },\n    __eq: (operand, contextKey) => {\n      if (typeof operand === 'object' && operand !== null) {\n        return this.buildQueryFilter(operand, contextKey);\n      }\n      return `${contextKey} eq ${this.quoteString(operand)}`;\n    },\n    __gt: (operand, contextKey) => {\n      return `${contextKey} gt ${this.quoteString(operand)}`;\n    },\n    __ge: (operand, contextKey) => {\n      return `${contextKey} ge ${this.quoteString(operand)}`;\n    },\n    __lt: (operand, contextKey) => {\n      return `${contextKey} lt ${this.quoteString(operand)}`;\n    },\n    __le: (operand, contextKey) => {\n      return `${contextKey} le ${this.quoteString(operand)}`;\n    },\n    __in: (operand, contextKey) => {\n      const stmts = operand\n        .filter(op => !!op)\n        .map(op => {\n          return `${contextKey} eq ${this.quoteString(op)}`;\n        });\n      return this.glue(stmts, 'or');\n    },\n    __bygroupid: operand => {\n      return `bygroupid(${operand})`;\n    },\n    __has: operand => {\n      return `has(${operand})`;\n    },\n    __useFilterQueryString: (queryString: string) => {\n      // match everything inside the most exterior parentheses, including them\n      const query = queryString.match(/\\(.*\\)/)[0];\n      // get rid of the most exterior parentheses\n      return query.substring(1, query.length - 1);\n    }\n  };\n\n  /**\n   * Builds query string from provided query object.\n   *\n   * @param query Object containing filters and sort order for querying managed objects. Supported filters are:\n   * - **__and** - Specifies conditions, e.g. {__and: [{__has: 'c8y_IsDevice'}, {'count': {__gt: 0}}]}.\n   * - **__or** - Specifies alternative conditions, e.g. {__or: [{__bygroupid: 10300}, {__bygroupid: 10400}]}.\n   * - **__eq** - Specified fragment must be equal to given value, e.g. {'status': 'AVAILABLE'} (no nested object required).\n   * - **__lt** - Specified fragment must be less then given value, e.g. {'count': {__lt: 10}}.\n   * - **__gt** - Specified fragment must be greater then given value, e.g. {'count': {__gt: 0}}.\n   * - **__in** - Specified fragment must be equal to one of values in the list, e.g. {'status': {__in: ['AVAILABLE', 'UNAVAILABLE']}}.\n   * - **__not** - Negates condition, e.g. {__not: {'status': 'AVAILABLE'}}.\n   * - **__bygroupid** - True if filtered managed object is assigned to given group, e.g. {__bygroupid: 10300}.\n   * - **__has** - Specified fragment must have a value defined, e.g. {__has: 'c8y_IsDevice'}.\n   * - **__useFilterQueryString** - Gets rid of the '$filter=() $orderby=' parts of a query and keeps only what's between the most\n   *                                exterior parentheses of the $filter.\n   *                                EXAMPLE: takes a query of the form\n   *                                \"$filter=(name eq 'RaspPi*') $orderby=name asc\"\n   *                                and turns it into\n   *                                \"name eq 'RaspPi*'\"\n   *                                This is necessary for searching for smart groups, which are identified by their own query\n   *                                that needs to be passed through.\n   *\n   *\n   * The order is specified by an array of field paths and sort direction (1 for ascending, -1 for descending), e.g.:\n   * - {__orderby: [{'creationTime': -1}, {'name': 1}], __filter: {...}}\n   *\n   * @returns {string} Returns a query string ready to be sent in request params to backend.\n   *\n   * **Example**\n   * <pre>\n   *   const query = {\n   *     __filter: {\n   *       'name': 'My Device*',\n   *       'c8y_Availability.status': {\n   *         __in: ['AVAILABLE', 'UNAVAILABLE']\n   *       },\n   *       'creationTime': {\n   *         __lt: '2015-11-30T13:28:123Z'\n   *       },\n   *       'c8y_ActiveAlarmsStatus.critical': {\n   *         __gt: 0\n   *       },\n   *       __or: [\n   *         {__not: {__has: 'c8y_ActiveAlarmsStatus.major'}},\n   *         {\n   *           __or: [\n   *             {__bygroupid: 10300},\n   *             {__bygroupid: 10400}\n   *           ]\n   *         }\n   *       ]\n   *     },\n   *     __orderby: [\n   *       {'name': 1},\n   *       {'creationTime': -1},\n   *       {'c8y_ActiveAlarmsStatus.critical': -1}\n   *     ]\n   *   };\n   *\n   *   const params = {\n   *     query: queriesUtil.buildQuery(query)\n   *   };\n   * </pre>\n   */\n  buildQuery(query): string {\n    const q = [];\n    const filter = this.buildQueryFilter(query.__filter || query);\n    const orderBy = this.buildQueryOrderby(query.__orderby);\n    if (filter) {\n      q.push(`$filter=(${filter})`);\n    }\n    if (orderBy) {\n      q.push(`$orderby=${orderBy}`);\n    }\n    return q.join(' ');\n  }\n\n  buildQueryFilter(queryFilter, _queryKey?, _glueType?): string {\n    const queryKey = _queryKey || null;\n    const glueType = _glueType || 'and';\n\n    const q = [];\n\n    if (Array.isArray(queryFilter)) {\n      queryFilter.forEach(qFilter => {\n        const _q = this.buildQueryFilter(qFilter, null, glueType);\n        if (_q) {\n          q.push(_q);\n        }\n      });\n    } else {\n      let _q;\n      Object.keys(queryFilter).forEach(k => {\n        if (this.operatorFns[k] !== undefined) {\n          _q = this.operatorFns[k](queryFilter[k], queryKey);\n          if (_q) {\n            q.push(_q);\n          }\n        } else {\n          _q = this.operatorFns.__eq(queryFilter[k], k);\n          if (_q) {\n            q.push(_q);\n          }\n        }\n      });\n    }\n\n    return this.glue(q, glueType);\n  }\n\n  buildQueryOrderby(queryOrderbys): string {\n    const o = [];\n    if (queryOrderbys) {\n      queryOrderbys.forEach(q => {\n        Object.keys(q).forEach(k => {\n          if (q[k] !== 0) {\n            o.push(`${k} ${q[k] > 0 ? 'asc' : 'desc'}`);\n          }\n        });\n      });\n    }\n    return o.join(',');\n  }\n\n  addAndFilter(query, filter) {\n    return this.addFilter(query, filter, 'and');\n  }\n\n  addOrFilter(query, filter) {\n    return this.addFilter(query, filter, 'or');\n  }\n\n  addFilter(query, filter, operator: 'and' | 'or') {\n    const oldFilter = query.__orderby ? query.__filter || {} : query.__filter || query;\n    const newFilter = { [`__${operator}`]: this.skipEmptyObjects([oldFilter, filter]) };\n    if (!query.__filter && !query.__orderby) {\n      return newFilter;\n    }\n    query.__filter = newFilter;\n    return query;\n  }\n\n  prependOrderbys(query, orderbys) {\n    return this.addOrderbys(query, orderbys, 'prepend');\n  }\n\n  appendOrderbys(query, orderbys) {\n    return this.addOrderbys(query, orderbys, 'append');\n  }\n\n  addOrderbys(query, orderbys, how: 'prepend' | 'append') {\n    const oldFilter = query.__orderby ? query.__filter || {} : query.__filter || query;\n    const oldOrderbys = query.__orderby || [];\n    const newOrderbys =\n      how === 'prepend' ? [...orderbys, ...oldOrderbys] : [...oldOrderbys, ...orderbys];\n    const newQuery: any = {\n      __orderby: this.skipEmptyObjects(newOrderbys)\n    };\n    if (!this.isEmptyObject(oldFilter)) {\n      newQuery.__filter = oldFilter;\n    }\n    return newQuery;\n  }\n\n  protected glue(stmts: any[], type: string) {\n    return stmts.length > 1 ? `(${stmts.join(`) ${type} (`)})` : stmts[0];\n  }\n\n  protected quoteString(s: any) {\n    return typeof s === 'string' ? `'${s}'` : s;\n  }\n\n  protected skipEmptyObjects(objs: any[]) {\n    return objs.filter(obj => !this.isEmptyObject(obj));\n  }\n\n  protected isEmptyObject(obj: {}) {\n    return Object.keys(obj).length === 0;\n  }\n}\n","import { IIdentified, Service, IResult, IResultList } from '../core';\nimport { IEvent } from './IEvent';\n\n/**\n * This class allows managing for events.\n */\nexport class EventService extends Service<IEvent> {\n  protected baseUrl = 'event';\n  protected listUrl = 'events';\n  protected propertyName = 'events';\n  protected channel = '/events/*';\n\n  /**\n   * Gets the details of a specific event.\n   *\n   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const eventId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await eventService.detail(eventId);\n   *   })();\n   * ```\n   */\n  async detail(entityOrId: string | number | IIdentified): Promise<IResult<IEvent>> {\n    return super.detail(entityOrId);\n  }\n\n  /**\n   * Creates a new event.\n   *\n   * @param {IEvent} entity Event object with mandantory fragments.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const mandantoryObject: IEvent = {\n   *    source: device,\n   *    text: 'I am an Event!',\n   *    time: '2018-05-02T10:08:00Z',\n   *    type: 'device-type-here',\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await eventService.create(mandantoryObject);\n   *  })();\n   * ```\n   */\n  async create(entity: IEvent): Promise<IResult<IEvent>> {\n    return super.create(entity);\n  }\n\n  /**\n   * Updates event data.\n   *\n   * @param {Partial<IEvent>} entity Event is partially updatable.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const partialUpdateObject: Partial<IEvent> = {\n   *    source: device,\n   *    text: 'Changed Event!'\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await eventService.update(partialUpdateObject);\n   *  })();\n   * ```\n   */\n  async update(entity: Partial<IEvent>): Promise<IResult<IEvent>> {\n    return super.update(entity);\n  }\n\n  /**\n   * Gets the list of events filtered by parameters.\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {object} filter Object containing filters for querying events.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await eventService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}): Promise<IResultList<IEvent>> {\n    return super.list(filter);\n  }\n\n  /**\n   * Removes an event with given id.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {string | number | IIdentified} entityOrId entity or id of the event.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const eventId: number = 1;\n   *\n   *   (async () => {\n   *     const {data, res} = await eventService.delete(eventId);\n   *     // data will be null\n   *   })();\n   * ```\n   */\n  async delete(entityOrId: string | number | IIdentified): Promise<IResult<null>> {\n    return super.delete(entityOrId);\n  }\n}\n","/* eslint-env browser */\nmodule.exports = typeof self == 'object' ? self.FormData : window.FormData;\n","import FormData from 'form-data';\nimport { Stream } from 'stream';\nimport { Service, IResult, IFetchResponse } from '../core';\nimport { IdReference } from './InventoryService';\nimport { IManagedObject, IManagedObjectBinary } from './IManagedObject';\n\nexport class InventoryBinaryService extends Service<IManagedObjectBinary> {\n  protected baseUrl = 'inventory';\n  protected listUrl = 'binaries';\n  protected propertyName = 'managedObjects';\n\n  /**\n   * Uploads a file and creates a managed object with its metadata.\n   * @param file A file to be uploaded.\n   * @param managedObject An object containing metadata about the file.\n   * Note that you can specify `fileType` and `fileName` in case `file` does not define them\n   * but these two properties will be removed from `managedObject` before saving.\n   */\n  async create(\n    file: Stream | Buffer | File | Blob,\n    managedObject: Partial<IManagedObject> = {}\n  ): Promise<IResult<IManagedObjectBinary>> {\n    const method = 'POST';\n    const url = this.listUrl;\n    const body = new FormData();\n    let fileName;\n    let fileType;\n    if (managedObject.fileName) {\n      fileName = managedObject.fileName;\n      delete managedObject.fileName;\n    }\n    if (managedObject.fileType) {\n      fileType = managedObject.fileType;\n      delete managedObject.fileType;\n    }\n    if (!fileName) {\n      fileName = 'bin';\n    }\n    if (typeof (File) !== 'undefined' && file instanceof File) {\n      fileName = file.name;\n      fileType = file.type;\n    }\n    if (!managedObject.name) {\n      managedObject.name = fileName;\n    }\n    if (!managedObject.type) {\n      managedObject.type = fileType || 'c8y_upload';\n    }\n    body.append('file', file, fileName);\n    body.append('object', JSON.stringify(managedObject));\n    let bodyHeaders;\n    if (typeof body.getHeaders === 'function') {\n      bodyHeaders = body.getHeaders();\n    }\n    const headers = Object.assign({\n      accept: 'application/json'\n    }, bodyHeaders);\n    const res = await this.fetch(url, { method, body, headers });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  async list(filter: object = {}) {\n    return super.list(filter);\n  }\n\n  async delete(managedObjectOrId: IdReference) {\n    return super.delete(managedObjectOrId);\n  }\n\n  async download(managedObjectOrId: IdReference): Promise<IFetchResponse> {\n    const url = this.getDetailUrl(managedObjectOrId);\n    return await this.fetch(url);\n  }\n\n  /**\n   * Gets binary managed object's id from its download or self URL.\n   *\n   * @param {string} url URL string.\n   *\n   * @returns {number} Binary managed object's id.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   const id = InventoryBinaryService.getIdFromUrl('http://mytenant.cumulocity.com/inventory/binaries/12345');\n   * ```\n   */\n  getIdFromUrl(url: string): string {\n    const regexp = new RegExp('\\\\/inventory\\\\/binaries\\\\/(\\\\d+)|\\\\/inventory\\\\/managedObjects\\\\/(\\\\d+)');\n    const matches = url.match(regexp);\n    return matches && (matches[1] || matches[2]);\n  }\n}\n","import {\n  IIdentified,\n  Service,\n  IResult,\n  IResultList,\n  IFetchClient,\n  QueriesUtil\n} from '../core';\nimport { IManagedObject } from './IManagedObject';\nimport { InventoryBinaryService } from './InventoryBinaryService';\n\nimport { Realtime } from '../realtime';\n\n/**\n * Possible types of a child.\n */\nexport enum ChildType {\n  ASSETS = 'childAssets',\n  DEVICES = 'childDevices',\n  ADDITIONS = 'childAdditions'\n}\n\n/**\n * IdReference is only a combined type of string | number | IIdentified\n */\nexport type IdReference = string | number | IIdentified;\n\n/**\n * This class allows for managing managed objects and different child types, see [[ChildType]].\n */\nexport class InventoryService extends Service<IManagedObject> {\n  binary: InventoryBinaryService;\n  queriesUtil: QueriesUtil;\n  protected baseUrl = 'inventory';\n  protected listUrl = 'managedObjects';\n  protected propertyName = 'managedObjects';\n  protected channel = '/managedobjects/*';\n  protected inventoriesQueryParamName = 'query';\n  protected devicesQueryParamName = 'q';\n\n  constructor(client: IFetchClient, realtime?: Realtime) {\n    super(client, realtime);\n    this.queriesUtil = new QueriesUtil();\n    this.binary = new InventoryBinaryService(client);\n  }\n\n  /**\n   * Gets the details of managed object\n   *\n   * @param {IdReference} managedObjectOrId ManagedObject or Id of the ManagedObject.\n   * @param {object} filter Filter object.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const managedObjId: number = 1;\n   *    const filter = { withChildren: false };\n   *\n   *    (async () => {\n   *      const {data, res} = await inventoryService.detail(managedObjId, filter);\n   *   })();\n   * ```\n   */\n  async detail(managedObjectOrId: IdReference, filter: object = {}) {\n    return super.detail(managedObjectOrId, filter);\n  }\n\n  /**\n   * Creates a new managed object.\n   *\n   * @param {Partial<IManagedObject>} managedObject\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const partialManagedObj: Partial<IManagedObject> = {\n   *    customFragment: 'yourData'\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await inventoryService.create(partialManagedObj);\n   *  })();\n   * ```\n   */\n  async create(managedObject: Partial<IManagedObject>) {\n    return super.create(managedObject);\n  }\n\n  /**\n   * Updates managed object data.\n   *\n   * @param {Partial<IManagedObject>} managedObject Managed object is partially updatable.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const partialUpdateObject: Partial<IManagedObject> = {\n   *    customFragment: 'Changed data',\n   *    name: 'Name'\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await inventoryService.update(partialUpdateObject);\n   *  })();\n   * ```\n   */\n  async update(managedObject: Partial<IManagedObject>) {\n    return super.update(managedObject);\n  }\n\n  /**\n   * Gets the list of managed objects filtered by parameters.\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {object} filter Object containing filters for querying managed objects.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await inventoryService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}) {\n    return super.list(filter);\n  }\n\n  /**\n   * Gets the list of all managed objects filtered and sorted by given query.\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {object} filter Object containing filters for querying managed objects.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *  const query = {\n   *      name: 'MY-NAM*'\n   *  }\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await inventoryService.listQuery(query, filter);\n   *   })();\n   * ```\n   */\n  async listQuery(query, filter: object = {}) {\n    filter[this.inventoriesQueryParamName] = this.queriesUtil.buildQuery(query);\n    return super.list(filter);\n  }\n\n  /**\n   * Gets the list of all devices filtered and sorted by given query.\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {object} filter Object containing filters for querying devices.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *  const query = {\n   *      name: 'MY-NAM*'\n   *  }\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await inventoryService.listQueryDevices(query, filter);\n   *   })();\n   * ```\n   */\n  async listQueryDevices(query, filter: object = {}) {\n    filter[this.devicesQueryParamName] = this.queriesUtil.buildQuery(query);\n    return super.list(filter);\n  }\n\n  /**\n   * Removes managed object with given id.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {IdReference} managedObjectOrId ManagedObject or Id of the ManagedObject.\n   * @param {object} params Additional query params.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   const managedObjectId: number = 1;\n   *   const params: any = {\n   *     cascade: true\n   *   }\n   *\n   *    (async () => {\n   *      const {data, res} = await inventoryService.delete(managedObjectId, params);\n   *   })();\n   * ```\n   */\n  async delete(managedObjectOrId: IdReference, params: any = {}) {\n    return super.delete(managedObjectOrId, params);\n  }\n\n  /**\n   * Gets a list of child additions from a given managed object (parent)\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {IdReference} parentReference\n   * @param {object} filter\n   *\n   * **Example**\n   * ```typescript\n   *    const parentReferenceId: IdReference = 1;\n   *\n   *    const filter: object = {\n   *      pageSize: 100,\n   *      withTotalPages: true\n   *    };\n   *\n   *    (async () => {\n   *      const {data, res, paging} = await inventoryService.childAdditionsList(parentReferenceId, filter);\n   *    })();\n   * ```\n   */\n  async childAdditionsList(parentReference: IdReference, filter: object = {}) {\n    return this.listChildren(ChildType.ADDITIONS, parentReference, filter);\n  }\n\n  /**\n   * Creates a new managed object as child addition to another managed object (parent)\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {Partial<IManagedObject>} managedObject\n   * @param {IdReference} parentReference\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const mOAsChildAddition: Partial<IManagedObject> = {\n   *      name: 'Child addition MO',\n   *      type: 'new type',\n   *      ...\n   *    };\n   *\n   *    // This is the identifier of the managed object which should be the parent of\n   *    // mOAsChildAddition, see above.\n   *    const parentReferenceId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await inventoryService.childAdditionsCreate(mOAsChildAddition, parentReferenceId);\n   *    })();\n   * ```\n   */\n  async childAdditionsCreate(managedObject: Partial<IManagedObject>, parentReference: IdReference) {\n    return this.createChild(ChildType.ADDITIONS, managedObject, parentReference);\n  }\n\n  /**\n   * Adds an existing managed object as child addition to another managed object (parent)\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {IdReference} childReference\n   * @param {IdReference} parentReference\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const childRef: number = 2;\n   *    const parentReferenceId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await inventoryService.childAdditionsCreate(childRef, parentReferenceId);\n   *    })();\n   * ```\n   */\n  async childAdditionsAdd(childReference: IdReference, parentReference: IdReference) {\n    return this.addChild(ChildType.ADDITIONS, childReference, parentReference);\n  }\n\n  /**\n   * Removes an existing managed object as child addition from another managed object (parent)\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {IdReference} childReference\n   * @param {IdReference} parentReference\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const childRef: number = 2;\n   *    const parentReferenceId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await inventoryService.childAdditionsRemove(childRef, parentReferenceId);\n   *    })();\n   * ```\n   */\n  async childAdditionsRemove(childReference: IdReference, parentReference: IdReference) {\n    return this.removeChild(ChildType.ADDITIONS, childReference, parentReference);\n  }\n\n  /**\n   * Gets a list of child assets from a given managed object (parent)\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {IdReference} parentReference\n   * @param {object} filter\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const parentReferenceId: IdReference = 1;\n   *\n   *    const filter: object = {\n   *      pageSize: 100,\n   *      withTotalPages: true\n   *    };\n   *\n   *    (async () => {\n   *      const {data, res, paging} = await inventoryService.childAssetsList(parentReferenceId, filter);\n   *    })();\n   * ```\n   */\n  async childAssetsList(parentReference: IdReference, filter: object = {}) {\n    return this.listChildren(ChildType.ASSETS, parentReference, filter);\n  }\n\n  /**\n   * Creates a new managed object as child asset to another managed object (parent)\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {Partial<IManagedObject>} managedObject\n   * @param {IdReference} parentReference\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const mOAsChildAsset: Partial<IManagedObject> = {\n   *      name: 'Child asset MO',\n   *      type: 'new type',\n   *      ...\n   *    };\n   *\n   *    // This is the identifier of the managed object which should be the parent of\n   *    // mOAsChildAsset, see above.\n   *    const parentReferenceId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await inventoryService.childAdditionsCreate(mOAsChildAddition, parentReferenceId);\n   *    })();\n   * ```\n   */\n  async childAssetsCreate(managedObject: Partial<IManagedObject>, parentReference: IdReference) {\n    return this.createChild(ChildType.ASSETS, managedObject, parentReference);\n  }\n\n  /**\n   * Adds an existing managed object as child asset to another managed object (parent)\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {IdReference} childReference\n   * @param {IdReference} parentReference\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const childRef: number = 2;\n   *    const parentReferenceId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await inventoryService.childAssetsAdd(childRef, parentReferenceId);\n   *    })();\n   * ```\n   */\n  async childAssetsAdd(childReference: IdReference, parentReference: IdReference) {\n    return this.addChild(ChildType.ASSETS, childReference, parentReference);\n  }\n  /**\n   * Adds bulk of existing managed objects as child assets to another managed object (parent).\n   *\n   * @returns Response wrapped in array of [[IResult]]\n   *\n   * @param {IdReference[]} childReference List of existing managed objects IDs that should be added to another managed object (parent).\n   * @param {IdReference} parentReference\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const childAssetsRefIds: string[] = ['2', '3'];\n   *    const parentReferenceId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await inventoryService.childAssetsBulkAdd(childAssetsRefIds, parentReferenceId);\n   *    })();\n   * ```\n   */\n  async childAssetsBulkAdd(childReference: IdReference[], parentReference: IdReference) {\n    return this.addChildBulk(ChildType.ASSETS, childReference, parentReference);\n  }\n\n  /**\n   * Removes an existing managed object as child asset from another managed object (parent)\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {IdReference} childReference\n   * @param {IdReference} parentReference\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const childRef: number = 2;\n   *    const parentReferenceId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await inventoryService.childAssetsRemove(childRef, parentReferenceId);\n   *    })();\n   * ```\n   */\n  async childAssetsRemove(childReference: IdReference, parentReference: IdReference) {\n    return this.removeChild(ChildType.ASSETS, childReference, parentReference);\n  }\n\n  /**\n   * Gets a list of child devices from a given managed object (parent)\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {IdReference} parentReference\n   * @param {object} filter\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const parentReferenceId: IdReference = 1;\n   *\n   *    const filter: object = {\n   *      pageSize: 100,\n   *      withTotalPages: true\n   *    };\n   *\n   *    (async () => {\n   *      const {data, res, paging} = await inventoryService.childDevicesList(parentReferenceId, filter);\n   *    })();\n   * ```\n   */\n  async childDevicesList(parentReference: IdReference, filter: object = {}) {\n    return this.listChildren(ChildType.DEVICES, parentReference, filter);\n  }\n\n  /**\n   * Creates a new managed object as child device to another managed object (parent)\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {Partial<IManagedObject>} managedObject\n   * @param {IdReference} parentReference\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const mOAsChildDevice: Partial<IManagedObject> = {\n   *      name: 'Child device MO',\n   *      type: 'new type',\n   *      ...\n   *    };\n   *\n   *    // This is the identifier of the managed object which should be the parent of\n   *    // mOAsChildDevice, see above.\n   *    const parentReferenceId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await inventoryService.childDevicesCreate(mOAsChildDevice, parentReferenceId);\n   *    })();\n   * ```\n   */\n  async childDevicesCreate(managedObject: Partial<IManagedObject>, parentReference: IdReference) {\n    return this.createChild(ChildType.DEVICES, managedObject, parentReference);\n  }\n\n  /**\n   * Adds an existing managed object as child device to another managed object (parent)\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {IdReference} childReference\n   * @param {IdReference} parentReference\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const childRef: number = 2;\n   *    const parentReferenceId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await inventoryService.childDevicesAdd(childRef, parentReferenceId);\n   *    })();\n   * ```\n   */\n  async childDevicesAdd(childReference: IdReference, parentReference: IdReference) {\n    return this.addChild(ChildType.DEVICES, childReference, parentReference);\n  }\n\n  /**\n   * Removes an existing managed object as child device from another managed object (parent)\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {IdReference} childReference\n   * @param {IdReference} parentReference\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const childRef: number = 2;\n   *    const parentReferenceId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await inventoryService.childDevicesRemove(childRef, parentReferenceId);\n   *    })();\n   * ```\n   */\n  async childDevicesRemove(childReference: IdReference, parentReference: IdReference) {\n    return this.removeChild(ChildType.DEVICES, childReference, parentReference);\n  }\n\n  protected onBeforeUpdate(objWithId: Partial<IManagedObject>): Partial<IManagedObject> {\n    delete objWithId.lastUpdated;\n    return objWithId;\n  }\n\n  protected onBeforeCreate(managedObject: Partial<IManagedObject>): Partial<IManagedObject> {\n    delete managedObject.id;\n    delete managedObject.lastUpdated;\n    return managedObject;\n  }\n\n  private getChildrenUrl(type: ChildType, parentReference: IdReference): string {\n    return `${this.getDetailUrl(parentReference)}/${type}`;\n  }\n\n  private getChildUrl(\n    type: ChildType,\n    childReference: IdReference,\n    parentReference: IdReference\n  ): string {\n    const typeofChildReference = typeof childReference;\n    const childId = this.getIdString(childReference);\n    return `${this.getChildrenUrl(type, parentReference)}/${childId}`;\n  }\n\n  private async listChildren(\n    type: ChildType,\n    parentReference: IdReference,\n    filter: object = {}\n  ): Promise<IResultList<IManagedObject>> {\n    const headers = { 'content-type': 'application/json' };\n    const url = this.getChildrenUrl(type, parentReference);\n    const res = await this.fetch(url, { headers, params: filter });\n    const json = await res.json();\n    const data = json.references.map(ref => ref.managedObject);\n    const paging = this.getPaging(json, filter);\n    paging.list = pagingFilter => this.listChildren(type, parentReference, pagingFilter);\n    return { res, data, paging };\n  }\n\n  private async createChild(\n    type: ChildType,\n    managedObject: Partial<IManagedObject>,\n    parentReference: IdReference\n  ): Promise<IResult<IIdentified>> {\n    const url = this.getChildrenUrl(type, parentReference);\n    const method = 'POST';\n    const body = JSON.stringify(this.onBeforeCreate(managedObject));\n    const headers = { 'content-type': this.mimeType('managedObject'), accept: 'application/json' };\n    const res = await this.fetch(url, { method, body, headers });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  private async addChild(\n    type: ChildType,\n    childReference: IdReference,\n    parentReference: IdReference\n  ): Promise<IResult<IIdentified>> {\n    const url = this.getChildrenUrl(type, parentReference);\n    const method = 'POST';\n    const childId = this.getIdString(childReference);\n    const body = JSON.stringify({ managedObject: { id: String(childId) } });\n    const headers = {\n      accept: 'application/json',\n      'content-type': this.mimeType('managedObjectReference')\n    };\n    const res = await this.fetch(url, { method, body, headers });\n    let data = await res.json();\n    data = data.managedObject;\n    return { res, data };\n  }\n\n  private async addChildBulk(\n    type: ChildType,\n    childReferenceArray: IdReference[],\n    parentReference: IdReference\n  ): Promise<IResultList<IIdentified>> {\n    const url = this.getChildrenUrl(type, parentReference);\n    const method = 'POST';\n    const references = childReferenceArray.map(childId => ({\n      managedObject: {\n        id: this.getIdString(childId)\n      }\n    }));\n    const body = JSON.stringify({\n      references\n    });\n    const headers = {\n      accept: 'application/json',\n      'content-type': this.mimeType('managedObjectReferenceCollection')\n    };\n    const res = await this.fetch(url, { method, body, headers });\n    const data = (await res.json()).references;\n    return { res, data: data.map(obj => obj.managedObject) };\n  }\n\n  private async removeChild(\n    type: ChildType,\n    childReference: IdReference,\n    parentReference: IdReference\n  ): Promise<IResult<null>> {\n    const childId = this.getIdString(childReference);\n    const url = `${this.getChildrenUrl(type, parentReference)}/${childId}`;\n    const method = 'DELETE';\n    const headers = { accept: 'application/json' };\n    const res = await this.fetch(url, { method, headers });\n    const data = null;\n    return { res, data };\n  }\n}\n","export enum aggregationType {\n  MINUTELY = 'MINUTELY',\n  HOURLY = 'HOURLY',\n  DAILY = 'DAILY'\n}\n\n/**\n * This interface specifies all fragments which can be used\n * to filter for specific series.\n */\nexport interface ISeriesFilter {\n  /**\n   * The ManagedObject which is the source of these series\n   */\n  source: number | string;\n  /**\n   * From which date the series should be gathered\n   */\n  dateFrom: string | Date;\n  /**\n   * To which date the series should be gathered\n   */\n  dateTo: string | Date;\n  /**\n   * For which aggregation it should filter, see [[aggregationType]]\n   */\n  aggregationType?: aggregationType;\n  /**\n   * The series type and name\n   *\n   * **Example**\n   * ```typescript\n   *\n   * const series: string[] = ['c8y_AccelerationMeasurement.acceleration', '...'];\n   * ```\n   */\n  series?: string | string[];\n}\n","import { IIdentified, Service, IResult } from '../core';\nimport { IMeasurement, IMeasurementCreate } from './IMeasurement';\nimport { ISeriesFilter} from './ISeriesFilter';\nimport { ISeries } from './ISeries';\n\n/**\n * This class allows for managing measurements.\n */\nexport class MeasurementService extends Service<IMeasurement> {\n  protected baseUrl = 'measurement';\n  protected listUrl = 'measurements';\n  protected propertyName = 'measurements';\n  protected channel = '/measurements/*';\n\n  /**\n   * Gets the details of selected measurement.\n   *\n   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const measurementId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await measurementService.detail(measurementId);\n   *   })();\n   * ```\n   */\n  async detail(entityOrId: string | number | IIdentified) {\n    return super.detail(entityOrId);\n  }\n\n  /**\n   * Creates a new measurement.\n   *\n   * @param {Partial<IMeasurementCreate>} entity At least sourceId is mandantory.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const mandantoryObject: Partial<IMeasurementCreate> = {\n   *    sourceId: device.id,\n   *    fragment: { series: { unit: '%', value: 51 } },\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await measurementService.create(mandantoryObject);\n   *  })();\n   * ```\n   */\n  async create(entity: Partial<IMeasurementCreate>) {\n    return super.create(this.onBeforeCreate(entity));\n  }\n\n  /**\n   * Gets the list of measurements filtered by parameters.\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {object} filter Object containing filters for querying measurements.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await measurementService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}) {\n    return super.list(filter);\n  }\n\n  /**\n   * Removes a measurement with given id.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {string | number | IIdentified} entityOrId\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   const id: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await measurementService.delete(id);\n   *   })();\n   * ```\n   */\n  async delete(entityOrId: string | number | IIdentified) {\n    return super.delete(entityOrId);\n  }\n\n  /**\n   * Gets the list of series in a measurement filtered by parameters.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {object} filter Object containing filters for querying measurements.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *    dateFrom: '2018-02-06T10:43:55.077Z',\n   *    dateTo: '2018-02-06T10:50:55.077Z',\n   *    source: device.id\n   *  };\n   *\n   *   (async () => {\n   *     const {data, res} = await measurementService.listSeries(filter);\n   *   })();\n   * ```\n   */\n  async listSeries(params: ISeriesFilter): Promise<IResult<ISeries>> {\n    const url = `${this.baseUrl}/${this.listUrl}/series`;\n    const res = await this.client.fetch(url, { params });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  protected onBeforeCreate(entity: Partial<IMeasurementCreate>) {\n    if (!entity.time) {\n      entity.time = new Date();\n    }\n    if (!entity.type) {\n      entity.type = 'c8y_Measurement';\n    }\n    if (entity.sourceId) {\n      const { sourceId } = entity;\n      delete entity.sourceId;\n      if (!entity.source) {\n        entity.source = {\n          id: String(sourceId),\n        };\n      }\n    }\n    return entity;\n  }\n}\n","import { gettext } from '../gettext';\n\n/**\n * A specific alarm can have one of the following states\n */\nexport enum AlarmStatus {\n  ACKNOWLEDGED = gettext('ACKNOWLEDGED'),\n  CLEARED = gettext('CLEARED'),\n  ACTIVE = gettext('ACTIVE')\n}\n","import { IIdentified, Service, IResult, IResultList } from '../core';\nimport { IAlarm } from './IAlarm';\n\n/**\n * This class allows for managing alarms.\n */\nexport class AlarmService extends Service<IAlarm> {\n  protected baseUrl = 'alarm';\n  protected listUrl = 'alarms';\n  protected propertyName = 'alarms';\n  protected channel = '/alarms/*';\n\n  /**\n   * Gets the details of selected alarms.\n   *\n   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const alarmId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await alarmService.detail(alarmId);\n   *    })();\n   * ```\n   */\n  async detail(entityOrId: string | number | IIdentified): Promise<IResult<IAlarm>> {\n    return super.detail(entityOrId);\n  }\n\n  /**\n   * Creates a new alarm.\n   *\n   * @param {IAlarm} entity Alarm object with mandantory fragments.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const mandantoryObject: IAlarm = {\n   *    severity: Severity.CRITICAL,\n   *    source: device,\n   *    text: 'I am an Alarm!',\n   *    time: '2018-05-02T10:08:00Z',\n   *    type: 'device-type-here',\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await alarmService.create(mandantoryObject);\n   *  })();\n   * ```\n   */\n  async create(entity: IAlarm): Promise<IResult<IAlarm>> {\n    return super.create(entity);\n  }\n\n  /**\n   * Updates alarm data.\n   *\n   * @param {Partial<IAlarm>} entity Alarm is partially updatable.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const partialUpdateObject: Partial<IAlarm> = {\n   *    severity: Severity.MINOR,\n   *    source: device,\n   *    text: 'Changed Alarm!'\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await alarmService.update(partialUpdateObject);\n   *  })();\n   * ```\n   */\n  async update(entity: Partial<IAlarm>): Promise<IResult<IAlarm>> {\n    return super.update(entity);\n  }\n\n  /**\n   * Gets the list of alarms filtered by parameters.\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {object} filter Object containing filters for querying alarms.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     severity: Severity.MAJOR,\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await alarmService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}): Promise<IResultList<IAlarm>> {\n    return super.list(filter);\n  }\n}\n","import { IIdentified, Service, IResult, IResultList } from '../core';\nimport { IOperation } from './IOperation';\n\n/**\n * This class allows for managing operations on a device.\n */\nexport class OperationService extends Service<IOperation> {\n  protected baseUrl = 'devicecontrol';\n  protected listUrl = 'operations';\n  protected propertyName = 'operations';\n\n  /**\n   * Gets the details of selected operation.\n   *\n   * @param {string|number|IIdentified} entityOrId Entity or Id of the entitytabs.service.ts.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const operationId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await operationService.detail(operationId);\n   *   })();\n   * ```\n   */\n  async detail(entityOrId: string | number | IIdentified): Promise<IResult<IOperation>> {\n    return super.detail(entityOrId);\n  }\n\n  /**\n   * Creates a new operation.\n   *\n   * @param {IOperation} entity Operation object with mandantory fragments.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const mandantoryObject: IOperation = {\n   *    com_cumulocity_model_WebCamDevice: {\n   *      name: 'take picture',\n   *      parameters: {\n   *         duration: '5s',\n   *         quality: 'HD'\n   *      }\n   *    },\n   *    deviceId: device.id,\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await operationService.create(mandantoryObject);\n   *  })();\n   * ```\n   */\n  async create(entity: IOperation): Promise<IResult<IOperation>> {\n    return super.create(entity);\n  }\n\n  /**\n   * Updates operation data.\n   *\n   * @param {Partial<IOperation>} entity Operation is partially updatable.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const partialUpdateObject: Partial<IOperation> = {\n   *    com_cumulocity_model_WebCamDevice: {\n   *      name: 'take picture',\n   *      parameters: {\n   *         duration: '2s',\n   *         quality: 'HD',\n   *         ratio: '16:9'\n   *      }\n   *    },\n   *    deviceId: device.id,\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await operationService.update(partialUpdateObject);\n   *  })();\n   * ```\n   */\n  async update(entity: Partial<IOperation>): Promise<IResult<IOperation>> {\n    return super.update(entity);\n  }\n\n  /**\n   * Gets the list of operations filtered by parameters.\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {object} filter Object containing filters for querying operations.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await operationService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}): Promise<IResultList<IOperation>> {\n    return super.list(filter);\n  }\n}\n","import { gettext } from '../gettext';\r\n\r\n/**\r\n * A bulk operation can have one of the following states.\r\n */\r\nexport enum OperationBulkStatus {\r\n  ACTIVE = gettext('ACTIVE'),\r\n  IN_PROGRESS = gettext('IN_PROGRESS'),\r\n  COMPLETED = gettext('COMPLETED'),\r\n  DELETED = gettext('DELETED')\r\n}\r\n","import { gettext } from '../gettext';\r\n\r\n/**\r\n * A bulk operation can have one of the following general statuses.\r\n */\r\nexport enum OperationBulkGeneralStatus {\r\n  SCHEDULED = gettext('SCHEDULED'),\r\n  EXECUTING = gettext('EXECUTING'),\r\n  EXECUTING_WITH_ERROR = gettext('EXECUTING_WITH_ERROR'),\r\n  CANCELED = gettext('CANCELED'),\r\n  FAILED = gettext('FAILED'),\r\n  SUCCESSFUL = gettext('SUCCESSFUL'),\r\n  DELETED = gettext('DELETED'),\r\n  INCORRECT = gettext('INCORRECT')\r\n}\r\n","import { gettext } from '../gettext';\n\n/**\n * An Operation can have one of the following states.\n */\nexport enum OperationStatus {\n  PENDING = gettext('PENDING'),\n  EXECUTING = gettext('EXECUTING'),\n  SUCCESSFUL = gettext('SUCCESSFUL'),\n  FAILED = gettext('FAILED')\n}\n","import {IIdentified, Service, IResult} from '../core';\nimport { IOperationBulk } from './IOperationBulk';\n\n/**\n * This class allows for managing bulk operations.\n */\nexport class OperationBulkService extends Service<IOperationBulk> {\n  protected baseUrl = 'devicecontrol';\n  protected listUrl = 'bulkoperations';\n  protected propertyName = 'bulkOperations';\n\n  /**\n   * Gets the details of selected bulk operation.\n   *\n   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const bulkOperationId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await operationBulkService.detail(bulkOperationId);\n   *   })();\n   * ```\n   */\n  async detail(operationOrId: string | number | IIdentified) {\n    return super.detail(operationOrId);\n  }\n\n  /**\n   * Creates a new operation.\n   *\n   * @param {Partial<IOperationBulk>} operation Operation object with mandantory fragments.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const mandantoryObject: Partial<IOperationBulk> = {\n   *    creationRamp: 15,\n   *    groupId: '149044',\n   *    operationPrototype: {\n   *      c8y_Restart: {},\n   *      description: 'Restart device',\n   *      deviceId: device.id,\n   *      status: 'PENDING'\n   *    },\n   *     startDate: '2018-02-15T16:01:00.000Z'\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await operationBulkService.create(mandantoryObject);\n   *  })();\n   * ```\n   */\n  async create(operation: Partial<IOperationBulk>) {\n    return super.create(operation);\n  }\n\n  /**\n   * Updates a new operation.\n   *\n   * @param {Partial<IOperationBulk>} operation Operation object.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const updateObject: Partial<IOperationBulk> = {\n   *    creationRamp: 15,\n   *    groupId: '149044',\n   *    operationPrototype: {\n   *      c8y_Restart: {},\n   *      description: 'Restart device',\n   *      deviceId: device.id,\n   *      status: 'PENDING'\n   *    },\n   *     startDate: '2018-02-15T16:01:00.000Z'\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await operationBulkService.update(updateObject);\n   *  })();\n   * ```\n   */\n  async update(entity: Partial<IOperationBulk>) {\n    return super.update(entity);\n  }\n\n  /**\n   * Gets the list of bulk operations filtered by parameters.\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {object} filter Object containing filters for querying alarms.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await operationBulkService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}) {\n    return super.list(filter);\n  }\n\n  /**\n   * Removes an bulk operation with given id.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {string | number | IIdentified):} operationOrId Operation object or id.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   const id: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await operationBulkService.delete(id);\n   *   })();\n   * ```\n   */\n  async delete(operationOrId: string | number | IIdentified): Promise<IResult<null>> {\n    return super.delete(operationOrId);\n  }\n}\n","import { gettext } from '../gettext';\r\n\r\nexport enum TenantStatus {\r\n  ACTIVE = gettext('ACTIVE'),\r\n  SUSPENDED = gettext('SUSPENDED')\r\n}\r\n","/**\n * Represents a strategy used for two-factor authentication.\n */\nexport enum TfaStrategy {\n  /** Two-factor authentication with Time-Based One Time Passwords. */\n  TOTP = 'TOTP',\n  /** Two-factor authentication with codes sent via SMSes. */\n  SMS = 'SMS'\n}\n","import { Service, IResult, IResultList } from '../core';\nimport { ITenant } from './ITenant';\nimport { ICurrentTenant } from './ICurrentTenant';\nimport { ITfaSettings } from './ITfaSettings';\nimport { IApplication } from '../application';\n\n/**\n * @description\n * This service allows for managing tenants.\n */\nexport class TenantService extends Service<ITenant> {\n  protected baseUrl = 'tenant';\n  protected listUrl = 'tenants';\n  protected currentTenantUrl = 'currentTenant';\n  protected propertyName = 'tenants';\n  protected fetchOptions = {\n    method: 'PUT',\n    body: '{}',\n    headers: { 'content-type': 'application/json', accept: 'application/json' }\n  };\n\n  /**\n   * Get a representation of a tenant.\n   *\n   * @param {string|number|IIdentified} entityOrId Tenant's id or tenant object.\n   *\n   * @returns Returns promise object that is resolved with the IIdentified wrapped by IResult.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const tenantId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await tenantService.detail(tenantId);\n   *   })();\n   * ```\n   *\n   * Required role: ROLE_TENANT_MANAGEMENT_READ<br><br>\n   * User password is never returned in GET response. Authentication mechanism is provided by another interface.\n   */\n  async detail(entityOrId: string | number | ITenant): Promise<IResult<ITenant>> {\n    return super.detail(entityOrId);\n  }\n\n  /**\n   * Creates a new tenant.\n   *\n   * @param {IIdentified} entity Tenant object.\n   *\n   * @returns {IResult<IIdentified>} Returns promise object that is resolved with the details of newly created tenant.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const tenantObject = {\n   *    id: \"sample_tenant\",\n   *    company: \"sample_company\",\n   *    domain: \"sample_domain.com\",\n   *    contactName: \"Mr. Doe\",\n   *    ...\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await tenantService.create(tenantObject);\n   *  })();\n   * ```\n   *\n   * Required role: ROLE_TENANT_MANAGEMENT_ADMIN or ROLE_TENANT_MANAGEMENT_CREATE<br><br>\n   * Note that creating a tenant with adminName, adminPass and adminEmail, creates an admin user with these settings.\n   * For the tenant id SQL keywords (e.g., select, cross, where) are not allowed.\n   */\n  async create(entity: ITenant): Promise<IResult<ITenant>> {\n    return super.create(entity);\n  }\n\n  /**\n   * Updates tenant data.\n   *\n   * @param {IIdentified} entity Tenant is partially updatable.\n   *\n   * @returns {IResult<IIdentified>} Returns promise object that is resolved with the saved tenant object.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const partialUpdateObject: IIdentified = {\n   *     adminName : \"newAdmin\"\n   *     ...\n   *   }\n   *\n   *  (async () => {\n   *    const {data, res} = await tenantService.update(partialUpdateObject);\n   *  })();\n   * ```\n   *\n   * Required role: ROLE_TENANT_MANAGEMENT_ADMIN or ROLE_TENANT_MANAGEMENT_UPDATE<br><br>\n   * Note that updating adminPass and adminEmail updates these settings in the admin user of the tenant.\n   * Updating adminName has no effect.\n   */\n  async update(entity: ITenant): Promise<IResult<ITenant>> {\n    return super.update(entity);\n  }\n\n  /**\n   * Gets the list of tenants filtered by parameters.\n   *\n   * @param {object} filter Object containing filters for querying tenants.\n   *\n   * @returns Returns promise object that is resolved with the IIdentified wrapped by IResultList.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     severity: Severity.MAJOR,\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await tenantService.list(filter);\n   *   })();\n   * ```\n   *\n   * Required role: ROLE_TENANT_MANAGEMENT_READ\n   */\n  async list(filter: object = {}): Promise<IResultList<ITenant>> {\n    return super.list(filter);\n  }\n\n  /**\n   * Delete a representation of a tenant.\n   *\n   * @param {string|number|IIdentified} entityOrId Tenant's id or tenant object.\n   *\n   * @returns Returns promise object that is resolved with the IResult.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const tenantId: string = \"uniqueTenantId\";\n   *\n   *    (async () => {\n   *      const {data, res} = await tenantService.delete(tenantId);\n   *   })();\n   * ```\n   *\n   * Required role: ROLE_TENANT_MANAGEMENT_ADMIN\n   */\n  async delete(entityOrId: string | number | ITenant): Promise<IResult<null>> {\n    return super.delete(entityOrId);\n  }\n\n  async current(): Promise<IResult<ICurrentTenant>> {\n    const headers = { 'content-type': 'application/json' };\n    const res = await this.fetch(this.currentTenantUrl, { headers });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  /**\n   * enable support user for current tenant.\n   *\n   * @returns Returns promise object that is resolved with the IResult.\n   *\n   * **Example**\n   * ```typescript\n   *    (async () => {\n   *      const {res} = await tenantService.enableSupportUser();\n   *   })();\n   * ```\n   */\n  async enableSupportUser(): Promise<IResult<null>> {\n    const url = 'support-user/enable';\n    const res = await this.fetch(url, this.fetchOptions);\n    return { res, data: null };\n  }\n\n  /**\n   * disable support user for current tenant.\n   *\n   * @returns Returns promise object that is resolved with the IResult.\n   *\n   * **Example**\n   * ```typescript\n   *    (async () => {\n   *      const {res} = await tenantService.disableSupportUser();\n   *   })();\n   * ```\n   */\n  async disableSupportUser(): Promise<IResult<null>> {\n    const url = 'support-user/disable';\n    const res = await this.fetch(url, this.fetchOptions);\n    return { res, data: null };\n  }\n\n  async currentTenantType() {\n    const tenantData = await this.current();\n    if (\n      tenantData.data.customProperties &&\n      tenantData.data.customProperties.tenantType === 'TRIAL'\n    ) {\n      return 'TRIAL';\n    }\n    return 'REGULAR';\n  }\n\n  /**\n   * Returns two factor-authentication settings for given tenant.\n   *\n   * @param tenant The tenant object.\n   *\n   * @returns Promise which resolves with the object with TFA settings.\n   *\n   * **Example**\n   * ```typescript\n   *   (async () => {\n   *     const currentTenant = (await tenantService.current()).data;\n   *     const currentTenantTfaSettings = await tenantService.getTfaSettings(currentTenant);\n   *\n   *     const subtenant = (await tenantService.detail('t12345')).data;\n   *     const subtenantTfaSettings = await tenantService.getTfaSettings(subtenant);\n   *   })();\n   * ```\n   */\n  async getTfaSettings(tenant: ICurrentTenant | ITenant): Promise<ITfaSettings> {\n    const entityOrId: string = this.getIdString(tenant);\n    const url = `tenants/${entityOrId}/tfa`;\n    const res = await this.fetch(url);\n    const tfaSettings = await res.json();\n\n    return tfaSettings;\n  }\n\n  /**\n   * Subscribes a given application to a given tenant.\n   *\n   * @param tenant The tenant object.\n   * @param application The application object.\n   *\n   * @returns Returns promise object that is resolved with the IResult.\n   *\n   * **Example**\n   * ```typescript\n   *     const newApp = {\n   *        name: 'New application',\n   *        type: 'HOSTED',\n   *        key: 'new-app'\n   *     };\n   *\n   *     const application = (await applicationService.create(newApp)).data;\n   *     const currentTenant = (await tenantService.current()).data;\n   *\n   *     const {data, res} = await tenantService.subscribeApplication(currentTenant, application);\n   *   })();\n   * ```\n   */\n  async subscribeApplication(\n    tenant: ICurrentTenant | ITenant,\n    application: IApplication\n  ): Promise<IResult<null>> {\n    const entityOrId: string = this.getIdString(tenant);\n    const applicationId = application.id;\n    const url = `tenants/${entityOrId}/applications`;\n    const method = 'POST';\n    const body = JSON.stringify({\n      application: {\n        id: applicationId,\n        self: application.self\n      }\n    });\n    const headers = { 'content-type': this.mimeType('applicationReference') };\n    const res = await this.fetch(url, this.changeFetchOptions({ method, body, headers }, url));\n    return { res, data: null };\n  }\n\n  /**\n   * Unsubscribes a given application from a given tenant.\n   *\n   * @param tenant The tenant object.\n   * @param application The application object.\n   *\n   * @returns Returns promise object that is resolved with the IResult.\n   *\n   * **Example**\n   * ```typescript\n   *     const newApp = {\n   *        name: 'New application',\n   *        type: 'HOSTED',\n   *        key: 'new-app'\n   *     };\n   *\n   *     const application = (await applicationService.create(newApp)).data;\n   *     const currentTenant = (await tenantService.current()).data;\n   *     await tenantService.addApplication(currentTenant, application);\n   *\n   *     await tenantService.unsubscribeApplication(currentTenant, application);\n   *   })();\n   * ```\n   */\n  async unsubscribeApplication(\n    tenant: ICurrentTenant | ITenant,\n    application: IApplication\n  ): Promise<IResult<null>> {\n    const entityOrId: string = this.getIdString(tenant);\n    const url = `tenants/${entityOrId}/applications/${application.id}`;\n    const method = 'DELETE';\n    const res = await this.fetch(url, this.changeFetchOptions({ method }, url));\n    return { res, data: null };\n  }\n\n  protected getIdString(tenant: ITenant | ICurrentTenant): string {\n    return (tenant as ITenant).id || (tenant as ICurrentTenant).name;\n  }\n\n  protected onBeforeCreate(obj: ITenant): any {\n    return obj;\n  }\n}\n","import {IFetchClient, IIdentified, Service} from '../core';\nimport { IUserInventoryRole } from './IUserInventoryRole';\n\n/**\n * @description\n * This service allows for managing current user's inventory roles.\n */\nexport class UserInventoryRoleService extends Service<IUserInventoryRole> {\n  protected baseUrl;\n  protected listUrl = `inventory`;\n  protected currenUserUrl = `currentUser`;\n  protected propertyName = 'inventoryAssignments';\n\n  constructor(userUrl: string, client: IFetchClient) {\n    super(client);\n    this.baseUrl = `user/${userUrl}/roles`;\n  }\n\n  /**\n   * Get a representation of a concrete current user's inventory role.\n   *\n   * @param {string|number|IUserInventoryRole} entityOrId inventory role id or inventory role object.\n   *\n   * @returns Returns promise object that is resolved with the IUserInventoryRole wrapped by IResult.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const inventoryRoleId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await userInventoryRoleService.detail(inventoryRoleId);\n   *   })();\n   * ```\n   *\n   * Required role: ROLE_TENANT_MANAGEMENT_READ<br><br>\n   * User password is never returned in GET response. Authentication mechanism is provided by another interface.\n   */\n  async detail(entityOrId: string | number | IUserInventoryRole) {\n    return super.detail(entityOrId);\n  }\n\n  /**\n   * Assign inventory role to current user.\n   *\n   * @param {IUserInventoryRole} entity Inventory Role object.\n   *\n   * @returns Returns promise object that is resolved with the details of newly assigned inventory role.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const inventoryRoleObject: IUserInventoryRole = {\n   *    ...\n   *  };\n   *\n   *    (async () => {\n   *      const {data, res} = await userInventoryRoleService.create(inventoryRoleObject);\n   *   })();\n   * ```\n   */\n  async create(entity: IUserInventoryRole) {\n    return super.create(entity);\n  }\n\n  /**\n   * Updates an inventory role.\n   *\n   * @param {Partial<IUserInventoryRole>} entity Inventory Role object.\n   */\n  async update(entity: Partial<IUserInventoryRole>) {\n    return super.update(entity);\n  }\n\n  /**\n   * Gets the list the inventory roles applied to a current user.\n   *\n   * @param {object} filter Object containing filters for querying inventory roles.\n   *\n   * @returns Returns promise object that is resolved with the IUserInventoryRole wrapped by IResultList.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     severity: Severity.MAJOR,\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await userInventoryRoleService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}) {\n    return super.list(filter);\n  }\n\n  /**\n   * Unassign inventory role from current user\n   *\n   * @param {string|number|IIdentified} entityOrId Inventory Role id or Inventory Role object.\n   *\n   * @returns Returns promise object that is resolved with the IResult.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const inventoryRoleId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await userInventoryRoleService.delete(inventoryRoleId);\n   *   })();\n   * ```\n   */\n  async delete(entityOrId: string | number | IIdentified) {\n    return super.delete(entityOrId);\n  }\n}\n","export enum PasswordStrength {\n  GREEN = 'GREEN',\n  RED = 'RED',\n  YELLOW = 'YELLOW'\n}\n","import { IIdentified, Service, IResult, IFetchOptions } from '../core';\nimport { IUser } from './IUser';\nimport { ICurrentUser } from './ICurrentUser';\nimport { UserInventoryRoleService } from './UserInventoryRoleService';\nimport { IResetPassword } from './IResetPassword';\nimport { ITotp } from './ITotp';\nimport { ITotpStatus } from './ITotpStatus';\n\n/**\n * @description\n * This service allows for managing users.\n */\nexport class UserService extends Service<IUser> {\n  protected get listUrl() {\n    return `${this.client.tenant}/users`;\n  }\n  protected baseUrl = 'user';\n  protected currentUserUrl = 'currentUser';\n  protected passwordResetUrl = 'passwordReset';\n  protected currentUserPhoneUrl = 'currentUserPhone';\n  protected verifyTFACodeUrl = 'pin';\n  protected totpCurrentUserURL = `${this.currentUserUrl}/totpSecret`;\n  protected verifyTOTPCodeUrl = `${this.totpCurrentUserURL}/verify`;\n  protected activateTOTPCodeUrl = `${this.totpCurrentUserURL}/activity`;\n  protected revokeTOTPSecretUrl = 'totpSecret/revoke';\n  protected get newsletterEmailsUrl() {\n    return `${this.client.tenant}/users/newsletterEmails`;\n  }\n  protected propertyName = 'users';\n\n  /**\n   * Gets the details of given user.\n   *\n   * @param {string | number | IUser} entityOrId User's id or user object.\n   *\n   * @returns Returns promise object that is resolved with the IUser wrapped by IResult.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const userId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await userService.detail(userId);\n   *   })();\n   * ```\n   * User password is never returned in GET response. Authentication mechanism is provided by another interface.\n   */\n  async detail(entityOrId: string | number | IUser) {\n    return super.detail(entityOrId);\n  }\n\n  /**\n   * Creates a new user.\n   *\n   * @param {IUser} entity User object.\n   *\n   * @returns {IResult<IUser>} Returns promise object that is resolved with the details of newly created user.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const userObject: IUser = {\n   *    userName: \"newUser\",\n   *    password: \"userPassword12!@\"\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await userService.create(userObject);\n   *  })();\n   * ```\n   */\n  async create(entity: IUser) {\n    return super.create(entity);\n  }\n\n  /**\n   * Updates user data.\n   *\n   * @param {Partial<IUser>} entity User is partially updatable.\n   *\n   * @returns {IResult<IUserGroup>} Returns promise object that is resolved with the saved user object.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const partialUpdateObject: Partial<IUser> = {\n   *     \"id\" : \"myuser\",\n   *     \"userName\" : \"newUserName\",\n   *     \"email\": \"newUserEmail@example.com\"\n   *     ...\n   *   }\n   *\n   *  (async () => {\n   *    const {data, res} = await userService.update(partialUpdateObject);\n   *  })();\n   * ```\n   * When user is updated with changed permissions or groups, suitable audit record is created with type\n   * 'User' and activity 'User updated'.\n   */\n  async update(entity: Partial<IUser>) {\n    return super.update(entity);\n  }\n\n  /**\n   * Gets the list of users filtered by parameters.\n   *\n   * @param {object} filter Object containing filters for querying users.\n   *\n   * @returns Returns promise object that is resolved with the IUser wrapped by IResultList.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await userService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}) {\n    return super.list(filter);\n  }\n\n  /**\n   * Removes user.\n   *\n   * @param {number|IIdentified} entityOrId User's id or user object.\n   *\n   * @returns Returns promise object that is resolved with the IResult of null.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const userId: string = \"uniqueUserId\";\n   *\n   *    (async () => {\n   *      const {data, res} = await userService.delete(userGroupId);\n   *   })();\n   * ```\n   */\n  async delete(entityOrId: string | number | IIdentified) {\n    return super.delete(entityOrId);\n  }\n\n  /**\n   * Create instance of User Inventory Role Service related with given User.\n   *\n   * @param {string|number|IUser} entityOrId User's id or user object.\n   *\n   * @returns Returns UserInventoryRoleService object that is related with given User.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const userId: string = \"uniqueUserId\";\n   *\n   *    const userInventoryRoleService = userService.inventoryAssignment(userGroupId);\n   *    (async () => {\n   *      const {data, res} = await userInventoryRoleService.create(...);\n   *   })();\n   * ```\n   */\n  inventoryAssignment(entityOrId: string | number | IUser) {\n    return new UserInventoryRoleService(this.getDetailUrl(entityOrId), this.client);\n  }\n\n  /**\n   * Gets user that is currently logged in.\n   *\n   * @returns Returns promise object that is resolved with the IUser wrapped by IResult.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    (async () => {\n   *      const {data, res} = await userService.current();\n   *   })();\n   * ```\n   */\n  async current(): Promise<IResult<IUser>> {\n    const headers = {\n      'content-type': 'application/json',\n      Accept: 'application/vnd.com.nsn.cumulocity.user+json;'\n    };\n    const res = await this.fetch(this.currentUserUrl, { headers });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  /**\n   * Gets user that is currently logged in with the list of all roles assigned.\n   *\n   * @returns Returns promise object that is resolved with the ICurrenUser wrapped by IResult.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    (async () => {\n   *      const {data, res} = await userService.currentWithEffectiveRoles();\n   *   })();\n   * ```\n   */\n  async currentWithEffectiveRoles(): Promise<IResult<ICurrentUser>> {\n    const headers = {\n      'content-type': 'application/json',\n      Accept: 'application/vnd.com.nsn.cumulocity.currentUser+json;'\n    };\n    const res = await this.fetch(this.currentUserUrl, { headers });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  /**\n   * Updates the current user\n   *\n   * @param {IUser} user The user object with the properties to be updated\n   *\n   * @return Returns promise object resolved with the IUser wrapped by IResult\n   */\n  async updateCurrent(user: IUser): Promise<IResult<IUser>> {\n    const mimeType = 'application/vnd.com.nsn.cumulocity.user+json';\n    const headers = { 'content-type': mimeType, Accept: mimeType };\n    const body = JSON.stringify(this.onBeforeUpdate(user));\n    const res = await this.fetch(this.currentUserUrl, { headers, body, method: 'PUT' });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  /**\n   * Sends an email message with a link allowing user to reset their password.\n   *\n   * @param {string} email The email address to send the message to.\n   * @param {string} tenantId The id of user's tenant (if cannot be inferred from URL).\n   *\n   * @returns Returns a request result object.\n   *\n   * **Example**\n   * ```typescript\n   *   const email = 'user@example.com';\n   *   const tenantId = 't123456';\n   *\n   *   (async () => {\n   *     const { res, data } = await userService.sendPasswordResetMail(email, tenantId);\n   *   })();\n   * ```\n   */\n  async sendPasswordResetMail(email: string, tenantId?: string): Promise<IResult<null>> {\n    const headers = { 'content-type': 'application/json', accept: 'application/json' };\n    const method = 'POST';\n    const url = this.passwordResetUrl;\n    const params = tenantId ? { tenantId } : {};\n    const body = JSON.stringify({ email });\n    const res = await this.fetch(url, { headers, method, params, body });\n    return { res, data: null };\n  }\n\n  /**\n   * Resets user's password to a new one.\n   *\n   * @param {IResetPassword} newPassword Object with token, user's email, new password and its strength indicator.\n   * @param {string} tenantId The id of user's tenant (if cannot be inferred from URL).\n   *\n   * @returns Returns a request result object.\n   *\n   * **Example**\n   * ```typescript\n   *   const newPassword: IResetPassword = {\n   *     token: '123123ASDAWERER@#!WEDS$@#!WADA#A#EA#EA#EA',\n   *     email: 'user@example.com',\n   *     newPassword: 'myNewPassword',\n   *     passwordStrength: PasswordStrength.GREEN\n   *   };\n   *   const tenantId = 't123456';\n   *\n   *   (async () => {\n   *     const { res, data } = await userService.resetPassword(newPassword, tenantId);\n   *   })();\n   * ```\n   */\n  async resetPassword(newPassword: IResetPassword, tenantId?: string): Promise<IResult<null>> {\n    const headers = { 'content-type': 'application/json', accept: 'application/json' };\n    const method = 'PUT';\n    const url = this.passwordResetUrl;\n    const params = tenantId ? { tenantId } : {};\n    const body = JSON.stringify(newPassword);\n    const res = await this.fetch(url, { headers, method, params, body });\n    return { res, data: null };\n  }\n\n  /**\n   * Verifies TFA code which is sent via SMS. If invoked with string '0', new TFA code will be sent.\n   *\n   * @param {string} pin The code to verify.\n   *\n   * @returns Returns a status object.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    (async () => {\n   *      const {data, res} = await userService.verifyTFACode('123123');\n   *   })();\n   * ```\n   */\n  async verifyTFACode(pin: string): Promise<IResult<null>> {\n    const method = 'POST';\n    const body = JSON.stringify({ pin });\n    const headers = { 'content-type': 'application/json', accept: 'application/json' };\n    const res = await this.fetch(this.verifyTFACodeUrl, { headers, body, method });\n    return { res, data: null };\n  }\n\n  /**\n   * Verifies TFA code which is generated by a TOTP app.\n   *\n   * @param {string} code The code to verify.\n   *\n   * @returns Returns a status object.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    (async () => {\n   *      const {data, res} = await userService.verifyTotpCode('123123');\n   *   })();\n   * ```\n   */\n  async verifyTotpCode(code): Promise<IResult<null>> {\n    const method = 'POST';\n    const headers = { 'content-type': 'application/json' };\n    const body = JSON.stringify({ code });\n    const res = await this.fetch(this.verifyTOTPCodeUrl, { headers, body, method });\n    return { res, data: null };\n  }\n\n  /**\n   * Verifies TFA code which is generated by a TOTP app.\n   *\n   * @returns Returns a status object.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    (async () => {\n   *      const {data, res} = await userService.activateTotp();\n   *   })();\n   * ```\n   */\n  async activateTotp(): Promise<IResult<null>> {\n    const method = 'POST';\n    const headers = { 'content-type': 'application/json' };\n    const body = JSON.stringify({ isActive: true });\n    const res = await this.fetch(this.activateTOTPCodeUrl, { headers, body, method });\n    return { res, data: null };\n  }\n\n  /**\n   * Checks if TOTP is activated and enforced.\n   *\n   * @returns Returns an object of ITotpStatus if it is active.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    (async () => {\n   *      const {data, res} = await userService.getActivityTotp();\n   *      console.log(data.isActive);\n   *   })();\n   * ```\n   */\n  async getActivityTotp(): Promise<IResult<ITotpStatus>> {\n    const method = 'GET';\n    const headers = { 'content-type': 'application/json' };\n    const res = await this.fetch(this.activateTOTPCodeUrl, { headers, method });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  /**\n   * Generates a secret which can be used to setup two-factor authentication with TOTP.\n   *\n   * @returns Returns the secret and an URL to a QR Code.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    (async () => {\n   *      const {data, res} = await userService.generateTotpSecret();\n   *      console.log(secret);\n   *   })();\n   * ```\n   */\n  async generateTotpSecret(): Promise<IResult<ITotp>> {\n    const method = 'POST';\n    const headers = { 'content-type': 'application/json', accept: 'application/json' };\n    const res = await this.fetch(this.totpCurrentUserURL, { headers, method });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  /**\n   * Revokes a specific user's TOTP secret.\n   *\n   * @param {IUser} user User whose TOTP secret to revoke.\n   *\n   * @returns Status object\n   */\n  async totpRevokeSecret(user: IUser): Promise<IResult<null>> {\n    const url = `${this.getDetailUrl(user)}/${this.revokeTOTPSecretUrl}`;\n    const method = 'DELETE';\n    const headers = { accept: 'application/json' };\n    const res = await this.fetch(url, { headers, method });\n    return { res, data: null };\n  }\n\n  /**\n   * Saves phone number for the current user.\n   * @param phoneNumber Phone number to save.\n   * @returns Server response and data with updated current user object.\n   */\n  async savePhoneNumber(phoneNumber: string): Promise<IResult<ICurrentUser>> {\n    const url = this.currentUserPhoneUrl;\n    const options: IFetchOptions = {\n      method: 'PUT',\n      headers: { 'content-type': 'application/json', accept: 'application/json' },\n      body: JSON.stringify({\n        phone: phoneNumber\n      })\n    };\n    const res = await this.fetch(url, options);\n    const data = await res.json();\n    return { res, data };\n  }\n\n  /**\n   * Gets the list of emails of users subscribed for newsletter\n   * on the current tenant and its subtenants.\n   * @returns Server response and data with email addresses as plain text.\n   */\n  async getNewsletterEmails(): Promise<IResult<string>> {\n    const url = this.newsletterEmailsUrl;\n    const options: IFetchOptions = {\n      method: 'GET',\n      headers: { accept: 'text/plain' }\n    };\n    const res = await this.fetch(url, options);\n    const data = await res.text();\n    return { res, data };\n  }\n\n  hasRole(user: IUser, roleId: string): boolean {\n    return this.hasRoleInUser(user, roleId) || this.hasRoleInGroups(user, roleId);\n  }\n\n  hasAllRoles(user: IUser, roleIds: string[]): boolean {\n    return roleIds.every(roleId => this.hasRole(user, roleId));\n  }\n\n  hasAnyRole(user: IUser, roleIds: string[]): boolean {\n    return roleIds.some(roleId => this.hasRole(user, roleId));\n  }\n\n  protected onBeforeUpdate(user: IUser): any {\n    const obj = Object.assign({}, user);\n    delete obj.id;\n    delete obj.userName;\n    return obj;\n  }\n\n  protected getDetailUrl(entityOrId: string | number | IUser): string {\n    let id: string | number;\n    if (typeof entityOrId === 'object' && entityOrId.id) {\n      id = entityOrId.id;\n    } else if (typeof entityOrId === 'object' && entityOrId.userName) {\n      id = entityOrId.userName;\n    } else {\n      id = entityOrId as string | number;\n    }\n    return `${this.listUrl}/${encodeURIComponent(String(id))}`;\n  }\n\n  protected hasRoleInUser(user, roleId) {\n    const effectiveRoles = user.effectiveRoles || [];\n    return (\n      this.hasRoleInReferences((user && user.roles && user.roles.references) || [], roleId) ||\n      effectiveRoles.some(({ id }) => roleId === id)\n    );\n  }\n\n  protected hasRoleInGroups(user, roleId) {\n    const groupReferences = (user && user.groups && user.groups.references) || [];\n    return groupReferences.some(groupRef =>\n      this.hasRoleInReferences(groupRef.group.roles.references, roleId)\n    );\n  }\n\n  protected hasRoleInReferences(references, roleId) {\n    return references.some(ref => ref.role.id === roleId);\n  }\n}\n","export enum ApplicationType {\n  EXTERNAL = 'EXTERNAL',\n  HOSTED = 'HOSTED',\n  MICROSERVICE = 'MICROSERVICE',\n  FEATURE = 'FEATURE',\n  REPOSITORY = 'REPOSITORY'\n}\n","import { IFetchClient, Service, IResult, IFetchResponse } from '../core';\nimport { IApplication } from './IApplication';\nimport { IApplicationBinary } from './IApplicationBinary';\nimport { Stream } from 'stream';\nimport FormData from 'form-data';\n\nexport class ApplicationBinaryService extends Service<IApplicationBinary> {\n  protected baseUrl;\n  protected listUrl = 'binaries';\n  protected propertyName = 'attachments';\n\n  constructor(client: IFetchClient, applicationOrId: string | number | IApplication) {\n    super(client);\n    this.baseUrl = `application/applications/${this.getIdString(applicationOrId)}`;\n  }\n\n  async upload(\n    binary: ArrayBuffer | Stream | Buffer | File | Blob,\n    fileName?: string\n  ): Promise<IResult<IApplicationBinary>> {\n    const url = this.listUrl;\n    const method = 'POST';\n    const body = this.createBinaryRequestBody(binary, fileName);\n    let bodyHeaders;\n    if (typeof body.getHeaders === 'function') {\n      bodyHeaders = body.getHeaders();\n    }\n    const headers = Object.assign(\n      {\n        accept: 'application/json'\n      },\n      bodyHeaders\n    );\n    const res = await this.fetch(url, { method, body, headers });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  uploadWithProgressXhr(\n    binary: ArrayBuffer | Stream | Buffer | File | Blob,\n    onProgress,\n    fileName?: string\n  ): XMLHttpRequest {\n    const url = `/${this.baseUrl}/${this.listUrl}`;\n    const method = 'POST';\n    const body = this.createBinaryRequestBody(binary, fileName);\n    let bodyHeaders;\n    if (typeof body.getHeaders === 'function') {\n      bodyHeaders = body.getHeaders();\n    }\n    const headers = this.client.getFetchOptions().headers;\n    Object.assign(headers, {\n      Accept: 'application/json'\n    });\n    Object.assign(headers, bodyHeaders);\n    const xhr = new XMLHttpRequest();\n    xhr.open(method, url, true);\n    for (const key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n\n    xhr.upload.addEventListener('progress', onProgress);\n    xhr.send(body);\n    return xhr;\n  }\n\n  getXMLHttpResponse(xhr): Promise<IApplication> {\n    return new Promise((res, rej) => {\n      xhr.addEventListener('loadend', () => {\n        xhr.readyState === 4 && (xhr.status === 200 || xhr.status === 201)\n          ? res(JSON.parse(xhr.responseText))\n          : rej(\n              xhr.responseText ? { data: JSON.parse(xhr.responseText) } : 'Could not upload file.'\n            );\n      });\n    });\n  }\n\n  async list(filter?) {\n    return super.list(filter);\n  }\n\n  async delete(binaryOrId: string | number | IApplicationBinary) {\n    return super.delete(binaryOrId);\n  }\n\n  async listPlugins() {\n    const headers = { accept: 'application/json' };\n    const url = `${this.listUrl}/plugins`;\n    const res = await this.fetch(url, { headers });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  async addPlugin(pluginName: string, pluginFile: Stream | Buffer | ArrayBuffer) {\n    const url = `${this.listUrl}/plugins/${encodeURIComponent(pluginName)}`;\n    const method = 'POST';\n    const body = new FormData();\n    const bufferOrStream = pluginFile instanceof ArrayBuffer ? Buffer.from(pluginFile) : pluginFile;\n    body.append('file', bufferOrStream);\n    let bodyHeaders;\n    if (typeof body.getHeaders === 'function') {\n      bodyHeaders = body.getHeaders();\n    }\n    const headers = Object.assign(\n      {\n        accept: 'application/json'\n      },\n      bodyHeaders\n    );\n\n    const res = await this.fetch(url, { method, body, headers });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  async removePlugin(pluginName: string) {\n    const method = 'DELETE';\n    const headers = { accept: 'application/json' };\n    const url = `${this.listUrl}/plugins/${pluginName}`;\n    const res = await this.fetch(url, { method, headers });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  async updateFiles(files: Array<{ path: string; contents: Stream | Buffer | ArrayBuffer }>) {\n    const url = `${this.listUrl}/files`;\n    const method = 'POST';\n    const body = new FormData();\n    files.forEach(file => {\n      const bufferOrStream =\n        file.contents instanceof ArrayBuffer ? Buffer.from(file.contents) : file.contents;\n      body.append(file.path, bufferOrStream);\n    });\n    let bodyHeaders;\n    if (typeof body.getHeaders === 'function') {\n      bodyHeaders = body.getHeaders();\n    }\n    const headers = Object.assign(\n      {\n        accept: 'application/json'\n      },\n      bodyHeaders\n    );\n    const res = await this.fetch(url, { method, body, headers });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  async downloadArchive(binaryId: number | string): Promise<IFetchResponse> {\n    const url = `${this.listUrl}/${binaryId}`;\n    return await this.fetch(url);\n  }\n\n  private createBinaryRequestBody(\n    binary: ArrayBuffer | Stream | Buffer | File | Blob,\n    fileName?: string\n  ) {\n    const body = new FormData();\n    const bufferOrStream = binary instanceof ArrayBuffer ? Buffer.from(binary) : binary;\n    let uploadFileName = fileName;\n    if (typeof File !== 'undefined' && binary instanceof File) {\n      uploadFileName = binary.name;\n    }\n    body.append('file', bufferOrStream, uploadFileName);\n    body.append('fileName', uploadFileName);\n    return body;\n  }\n}\n","export enum BillingMode {\n  SUBSCRIPTION = 'SUBSCRIPTION',\n  RESOURCES = 'RESOURCES'\n}\n","export enum Isolation {\n  PER_TENANT = 'PER_TENANT',\n  MULTI_TENANT = 'MULTI_TENANT'\n}\n","import { gettext } from '../gettext';\r\n\r\nexport enum ApplicationAvailability {\r\n  MARKET = gettext('MARKET'),\r\n  PRIVATE = gettext('PRIVATE')\r\n}\r\n","import { IIdentified, IResult, IResultList, Service } from '../core';\nimport { ITenant, TenantService } from '../tenant';\nimport { IUser, UserService } from '../user';\nimport { ApplicationBinaryService } from './ApplicationBinaryService';\nimport { ApplicationType } from './ApplicationType';\nimport { IApplication } from './IApplication';\n\nexport class ApplicationService extends Service<IApplication> {\n  protected baseUrl = 'application';\n  protected listUrl = 'applications';\n  protected propertyName = 'applications';\n  protected channel = '/applications/*';\n\n  /**\n   * Creates a new application.\n   *\n   * @param {IIdentified} entity Application object.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const newApp = {\n   *    name: 'New application',\n   *    type: 'EXTERNAL',\n   *    key: 'new-app'\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await applicationService.create(newApp);\n   *  })();\n   * ```\n   */\n  async create(entity: IApplication): Promise<IResult<IApplication>> {\n    return super.create(entity);\n  }\n\n  async clone(entity: IApplication): Promise<IResult<IApplication>> {\n    const url = `${this.getDetailUrl(entity)}/clone`;\n    const method = 'POST';\n    const body = '';\n    const headers = { 'content-type': 'application/json', accept: 'application/json' };\n    const res = await this.fetch(url, { method, body, headers });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  /**\n   * Gets the list of existing applications filtered by parameters.\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {object} filter Object containing filters for querying applications.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await applicationService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}): Promise<IResultList<IApplication>> {\n    return super.list(filter);\n  }\n\n  /**\n   * Gets the details of selected application.\n   *\n   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const applicationId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await applicationService.detail(applicationId);\n   *   })();\n   * ```\n   */\n  async detail(entityOrId: string | number | IApplication): Promise<IResult<IApplication>> {\n    return super.detail(entityOrId);\n  }\n\n  /**\n   * Updates existing application.\n   * Make sure that you specifiy the application id within the update object.\n   *\n   * @param {IIdentified} entity Application object.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const updateApp = {\n   *    id: 38\n   *    name: 'Updated application'\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await applicationService.update(updateApp);\n   *  })();\n   * ```\n   */\n  async update(entity: IApplication): Promise<IResult<IApplication>> {\n    return super.update(entity);\n  }\n\n  /**\n   * Removes an application with given id.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {string | number | IIdentified} entityOrId entity or id of the application.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const removeApp: object = {\n   *     id: 38\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res} = await applicationService.delete(removeApp);\n   *     // data will be null\n   *   })();\n   * ```\n   */\n  async delete(entityOrId: string | number | IApplication): Promise<IResult<null>> {\n    return super.delete(entityOrId);\n  }\n\n  async listByName(name: string): Promise<IResultList<IApplication>> {\n    const headers = { 'content-type': 'application/json' };\n    const url = `applicationsByName/${encodeURIComponent(name)}`;\n    const res = await this.fetch(url, { headers });\n    const json = await res.json();\n    const data = json[this.propertyName];\n    return { res, data };\n  }\n\n  async listByTenant(\n    tenantOrName?: string | ITenant,\n    params: object = {}\n  ): Promise<IResultList<IApplication>> {\n    const headers = { 'content-type': 'application/json' };\n    const tenantService = new TenantService(this.client);\n    const tenantName = this.getIdString(tenantOrName || (await tenantService.current()).data.name);\n    const url = `applicationsByTenant/${encodeURIComponent(tenantName)}`;\n    const res = await this.fetch(url, { headers, params });\n    const json = await res.json();\n    const data = json[this.propertyName];\n    return { res, data };\n  }\n\n  async listByOwner(\n    tenantOrName?: string | ITenant,\n    params: object = {}\n  ): Promise<IResultList<IApplication>> {\n    const headers = { 'content-type': 'application/json' };\n    const tenantService = new TenantService(this.client);\n    const tenantName = this.getIdString(tenantOrName || (await tenantService.current()).data.name);\n    const url = `applicationsByOwner/${encodeURIComponent(tenantName)}`;\n    const res = await this.fetch(url, { headers, params });\n    const json = await res.json();\n    const data = json[this.propertyName];\n    return { res, data };\n  }\n\n  async listByUser(\n    userOrId?: string | number | IUser,\n    params: object = {}\n  ): Promise<IResultList<IApplication>> {\n    const headers = { 'content-type': 'application/json' };\n    const userService = new UserService(this.client);\n    const userId = this.getIdString(userOrId || (await userService.current()).data);\n    const url = `applicationsByUser/${encodeURIComponent(userId)}`;\n    const res = await this.fetch(url, { headers, params });\n    const json = await res.json();\n    const data = json[this.propertyName];\n    return { res, data };\n  }\n\n  async reactivateArchive(appId: number | string): Promise<IResult<null>> {\n    const url = `${this.listUrl}/${appId}/refresh`;\n    const method = 'POST';\n    const body = '';\n    const headers = { 'content-type': 'application/json', accept: 'application/json' };\n    const res = await this.fetch(url, { method, body, headers });\n    return { res, data: null };\n  }\n\n  binary(application: string | number | IApplication): ApplicationBinaryService {\n    return new ApplicationBinaryService(this.client, application);\n  }\n\n  getHref(application: IApplication): string {\n    if (application.type === ApplicationType.EXTERNAL) {\n      return application.externalUrl;\n    }\n    return `/apps/${application.public ? 'public/' : ''}${application.contextPath}`;\n  }\n\n  /**\n   * Checks if current user can access specified application.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {string | IApplication} application Application name or contextPath as a\n   * string or Application object.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const checkApp: object = {\n   *    name: 'myApplication'\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await applicationService.isAvailable(checkApp);\n   *  })();\n   * ```\n   */\n  async isAvailable(application: string | Partial<IApplication>): Promise<IResult<boolean>> {\n    const { res, data } = await this.listByUser(undefined, {\n      dropOverwrittenApps: true,\n      noPaging: true\n    });\n\n    const available: boolean = (data || []).some((availableApp: IApplication) =>\n      typeof application === 'string'\n        ? availableApp.name === application || availableApp.contextPath === application\n        : this.isMatch(availableApp, application)\n    );\n\n    return { data: available, res };\n  }\n\n  private isMatch(object, source): boolean {\n    return Object.keys(source).every((key) => {\n      if (Array.isArray(object[key]) && Array.isArray(source[key])) {\n        return source[key].every((el) => object[key].includes(el));\n      } else if (\n        typeof object[key] === 'object' &&\n        object[key] !== null &&\n        typeof source[key] === 'object' &&\n        source[key] !== null\n      ) {\n        return this.isMatch(object[key], source[key]);\n      } else {\n        return object[key] === source[key];\n      }\n    });\n  }\n}\n","import { Service, IResult, IResultList, IFetchClient   } from '../core';\r\nimport { ISystemOption } from './ISystemOption';\r\n\r\nexport class SystemOptionsService extends Service<ISystemOption> {\r\n  protected baseUrl = 'tenant/system';\r\n  protected listUrl = 'options';\r\n  protected propertyName = 'options';\r\n\r\n  /**\r\n   * Gets the details of given system option.\r\n   *\r\n   * @param {string|number|IIdentified} option System option object with mandantory fragments.\r\n   *\r\n   * @returns Response wrapped in [[IResult]]\r\n   *\r\n   * **Example**\r\n   * ```typescript\r\n   *\r\n   *    const option: ISystemOption = {\r\n   *      category: 'alarm.type.mapping',\r\n   *      key: 'temp_to_high'\r\n   *    };\r\n   *\r\n   *    (async () => {\r\n   *      const {data, res} = await systemOptionsService.detail(option);\r\n   *   })();\r\n   * ```\r\n   */\r\n  async detail(option: ISystemOption): Promise<IResult<ISystemOption>> {\r\n    return super.detail(option);\r\n  }\r\n\r\n  /**\r\n   * Gets the list of system options filtered by parameters.\r\n   *\r\n   * @returns Response wrapped in [[IResultList]]\r\n   *\r\n   * @param {object} filter Object containing filters for querying system options.\r\n   *\r\n   * **Example**\r\n   * ```typescript\r\n   *\r\n   *  const filter: object = {\r\n   *     pageSize: 100,\r\n   *     withTotalPages: true\r\n   *   };\r\n   *\r\n   *   (async () => {\r\n   *     const {data, res, paging} = await systemOptionsService.list(filter);\r\n   *   })();\r\n   * ```\r\n   */\r\n  async list(filter: object = {}): Promise<IResultList<ISystemOption>> {\r\n    const headers = { 'content-type': 'application/json' };\r\n    const url = this.listUrl;\r\n    const res = await this.fetch(url, { headers, params: filter });\r\n    const json = await res.json();\r\n    const data = json[this.propertyName];\r\n\r\n    return { res, data };\r\n  }\r\n\r\n  protected getDetailUrl(option: ISystemOption): string {\r\n    return `${this.listUrl}/${option.category}/${option.key}`;\r\n  }\r\n\r\n  protected onBeforeCreate(obj: ISystemOption): any {\r\n    return obj;\r\n  }\r\n}\r\n","import { Service, IResultList, IResult, IIdentified } from '../core';\nimport { ITenantOption } from './ITenantOption';\nimport { ITenantOptionDetailParams } from './ITenantOptionDetailParams';\n\n/**\n * @description\n * This service allows for managing tenant's options.\n */\nexport class TenantOptionsService extends Service<ITenantOption> {\n  protected baseUrl = 'tenant';\n  protected listUrl = 'options';\n  protected propertyName = 'options';\n\n  private securityOptionsCategories = ['password'];\n  private securityOptionsListUrl = 'security-options';\n  private systemOptions = 'system';\n\n  /**\n   * Get a representation of a tenant's option.\n   *\n   * @param entity Tenant option object.\n   * @param params Additional query parameters.\n   *\n   * @returns Returns promise object that is resolved with\n   * the ITenantOption wrapped by IResult.\n   *\n   * **Example**\n   * ```typescript\n   * const option: ITenantOption = {\n   *   category: 'access.control',\n   *   key: 'allow.origin'\n   * };\n   * const params: ITenantOptionDetailParams = {\n   *   evaluate: 'inherited'\n   * };\n   * (async () => {\n   *   const { data, res } = await tenantService.detail(option);\n   *   console.log('value inherited from parent tenant:', data.value);\n   * })();\n   * ```\n   *\n   * Required role: ROLE_OPTION_MANAGEMENT_READ\n   */\n  async detail(\n    entity: ITenantOption,\n    params: ITenantOptionDetailParams = {}\n  ): Promise<IResult<ITenantOption>> {\n    return super.detail(entity, params);\n  }\n\n  /**\n   * Creates a new tenant's option.\n   *\n   * @param {ITenantOption} entity Tenant's Option object.\n   *\n   * @returns {IResult<IIdentified>} Returns promise object that is resolved with\n   * the details of newly created tenant option.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const tenantObject = {\n   *    id: \"sample_tenant\",\n   *    company: \"sample_company\",\n   *    domain: \"sample_domain.com\",\n   *    contactName: \"Mr. Doe\",\n   *    ...\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await tenantService.create(tenantObject);\n   *  })();\n   * ```\n   *\n   * Required role: ROLE_OPTION_MANAGEMENT_ADMIN<br><br>\n   * Options are category-key-value tuples, storing tenant configuration.Some categories of options\n   * allow creation of new one, other are limited to predefined set of keys.<br><br>\n   * Any option of any tenant can be defined as \"non-editable\" by \"management\" tenant. Afterwards, any PUT or DELETE\n   * requests made on that option by the owner tenant, will result in 403 error (Unauthorized).\n   */\n  async create(entity: ITenantOption): Promise<IResult<ITenantOption>> {\n    return super.create(entity);\n  }\n\n  /**\n   * Updates tenant's option data.\n   *\n   * @param {ITenantOption} entity Tenant option is partially updatable.\n   *\n   * @returns {IResult<ITenantOption>} Returns promise object that is resolved with the saved tenant option object.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const partialUpdateObject: IIdentified = {\n   *     value : \"http://developer.cumulocity.com\"\n   *     ...\n   *   }\n   *\n   *  (async () => {\n   *    const {data, res} = await tenantOptionsService.update(partialUpdateObject);\n   *  })();\n   * ```\n   *\n   * Required role: ROLE_OPTION_MANAGEMENT_ADMIN\n   */\n  async update(entity: ITenantOption): Promise<IResult<ITenantOption>> {\n    return super.update(entity);\n  }\n\n  /**\n   * Gets the list of tenant's options filtered by parameters.\n   *\n   * @param {object} filter Object containing filters for querying tenant options.\n   *\n   * @returns {IResultList<ITenantOption>} Returns promise object that is resolved\n   * with the ITenantOption wrapped by IResultList.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     severity: Severity.MAJOR,\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await tenantOptionsService.list(filter);\n   *   })();\n   * ```\n   *\n   * Required role: ROLE_OPTION_MANAGEMENT_READ\n   */\n  async list(filter: object = {}): Promise<IResultList<ITenantOption>> {\n    return super.list(filter);\n  }\n\n  /**\n   * Delete a representation of a tenant's option.\n   *\n   * @param {string|number|IIdentified} entityOrId Tenant's option id or tenant's option object.\n   *\n   * @returns Returns promise object that is resolved with the IResult.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const tenantOptionId: string = \"uniqueTenantId\";\n   *\n   *    (async () => {\n   *      const {data, res} = await tenantOptionsService.delete(tenantOptionId);\n   *   })();\n   * ```\n   *\n   * Required role: ROLE_TENANT_MANAGEMENT_ADMIN\n   */\n  async delete(entityOrId: string | number | IIdentified): Promise<IResult<null>> {\n    return super.delete(entityOrId);\n  }\n\n  protected getDetailUrl(entity: ITenantOption): string {\n    const encodedCategory = encodeURIComponent(entity.category);\n    const encodedKey = encodeURIComponent(entity.key);\n    if (this.securityOptionsCategories.indexOf(entity.category) > -1) {\n      return `${this.securityOptionsListUrl}/${encodedCategory}/${encodedKey}`;\n    } else {\n      return `${this.listUrl}/${encodedCategory}/${encodedKey}`;\n    }\n  }\n\n  protected onBeforeCreate(obj: ITenantOption): any {\n    return obj;\n  }\n}\n","import { Service, IResult } from '../core';\nimport { ITenantSecurityOption } from './ITenantSecurityOption';\n\n/**\n * @description\n * This service allows to get tenant security option.\n */\nexport class TenantSecurityOptionsService extends Service<ITenantSecurityOption> {\n  protected baseUrl = 'tenant';\n  protected listUrl = 'security-options';\n  protected category = 'password';\n  protected propertyName = 'options';\n\n  /**\n   * Get a specific tenant's security option.\n   *\n   * @param {ITenantSecurityOption} Tenant's security option object with key value.\n   *\n   * @returns Returns promise object that is resolved with the ITenantSecurityOption wrapped by IResult.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *     const option: ITenantSecurityOption = {\n   *        key: 'limit.validity'\n   *      };\n   *\n   *    (async () => {\n   *      const {data, res} = await tenantSecurityOptionsService.detail(option);\n   *   })();\n   * ```\n   */\n  async detail(tenantSecurityOption: ITenantSecurityOption): Promise<IResult<ITenantSecurityOption>> {\n    return super.detail(tenantSecurityOption);\n  }\n\n  protected getDetailUrl(tenantSecurityOption: ITenantSecurityOption): string {\n    return `${this.listUrl}/${this.category}/${tenantSecurityOption.key}`;\n  }\n\n  protected onBeforeCreate(obj: ITenantSecurityOption): any {\n    return obj;\n  }\n}\n","/**\n * A list of supported [[ITenantLoginOption]] which\n * describe the way a user can login to the Platform.\n */\nimport { TfaStrategy } from '../tenant';\n\nexport interface ITenantLoginOptions {\n  /**\n   * Link to the resource\n   */\n  self?: string;\n  /**\n   * The list of tenant login options\n   */\n  loginOptions: ITenantLoginOption[];\n}\n\n/**\n * Describes the login option which can be requested by any\n * application on startup without login. It describes which kind\n * of login mechanism (e.g. Basic, SSO or OAI-Secure) is\n * supported by the current Platform.\n */\nexport interface ITenantLoginOption {\n  /**\n   * Identifies the login option\n   */\n  id?: string;\n  /**\n   * Login option type\n   */\n  type?: TenantLoginOptionType;\n  /**\n   * Grant type\n   */\n  grantType?: GrantType;\n  /**\n   * The origin of the users REMOTE or INTERNAL\n   */\n  userManagementSource: UserManagementSource;\n  /**\n   * Link to the resource\n   */\n  self?: string;\n  /**\n   * The strategy for Two Factor Authentication\n   */\n  tfaStrategy?: TfaStrategy;\n  /**\n   * Indicates whether the login option should be visible on the login page of UI applications.\n   * If set to `true` for more than one login option, then the preferred one will be selected according to priority:\n   * 1. OAI-Secure: authentication information is stored in a HttpOnly cookie\n   * 2. Basic Auth: authentication information is stored in a session storage\n   * 3. SSO redirect: allows a user to login with a single 3rd-party authorization server using the OAuth2 protocol.\n   * If no login option has `visibleOnLoginPage` set to `true`, the preferred login option will be Basic Auth.\n   */\n  visibleOnLoginPage?: boolean;\n  /**\n   * The label which is shown on the login button\n   */\n  buttonName?: string;\n  /**\n   * The request which is used to initialize an oauth flow\n   */\n  initRequest?: string;\n  /**\n   * Determines if password strength is enforced on system level\n   */\n  enforceStrength?: boolean;\n  /**\n   * Minimum length of a password to be considered as a green strong one\n   */\n  greenMinLength?: number;\n  /**\n   * Determines if password strength is enforced on tenant level\n   */\n  strengthValidity?: boolean;\n  /**\n   * Organizations name which provides login option\n   */\n  providerName?: string;\n  /**\n   * Basic authentication restrictions.\n   */\n  authenticationRestrictions?: IAuthenticationRestrictions;\n  /**\n   * Configuration for OAI-Secure sessions.\n   */\n  sessionConfiguration?: ISessionConfiguration;\n  /**\n   * Tenant correct domain for OAI-Secure login option.\n   * UI will redirect to this domain if OAI-Secure is\n   * set as preferred login mode and domain in browser is wrong.\n   */\n  loginRedirectDomain?: string;\n}\n\nexport interface IAuthenticationRestrictions {\n  /**\n   * The list of user agents which are allowed to use the platform's REST API.\n   * The values are compared with `User-Agent` HTTP header.\n   */\n  trustedUserAgents: string[];\n\n  /**\n   * The list of user agents which are forbidden to use the platform's REST API.\n   * The values are compared with `User-Agent` HTTP header.\n   */\n  forbiddenUserAgents: string[];\n\n  /**\n   * The list of clients which are forbidden to use the platform's REST API.\n   * For now, the only value supported in the array is `'WEB_BROWSERS'` (which blocks all web browsers).\n   */\n  forbiddenClients: string[];\n}\n\nexport interface ISessionConfiguration {\n  /**\n   * The maximum amount of time a session can be active.\n   */\n  absoluteTimeoutMillis: number;\n  /**\n   * The maximum amount of sessions per user.\n   */\n  maximumNumberOfParallelSessions: number;\n  /**\n   * The timeout after which the session id is automatically renewed. If there is no activity after renewal timeout and before absolute session timeout, the session will not be renewed.\n   */\n  renewalTimeoutMillis: number;\n  /**\n   * If `true`, then every request needs to use the same `User-Agent` header as the first request which initiated the session.\n   */\n  userAgentValidationRequired: boolean;\n}\n\nexport enum TenantLoginOptionType {\n  /**\n   * OAI-Secure: authentication information is stored in a HttpOnly cookie\n   */\n  OAUTH2_INTERNAL = 'OAUTH2_INTERNAL',\n  /**\n   * SSO redirect: allows a user to login with a single 3rd-party authorization server using the OAuth2 protocol.\n   */\n  OAUTH2 = 'OAUTH2',\n  /**\n   * Basic Auth: authentication information is stored in a session storage\n   */\n  BASIC = 'BASIC'\n}\n\nexport enum GrantType {\n  AUTHORIZATION_CODE = 'AUTHORIZATION_CODE',\n  PASSWORD = 'PASSWORD'\n}\n\nexport enum UserManagementSource {\n  REMOTE = 'REMOTE',\n  INTERNAL = 'INTERNAL'\n}\n","import { IIdentified, IResult, IResultList, Service } from '../core';\nimport { GrantType, ITenantLoginOption, TenantLoginOptionType, UserManagementSource } from './ITenantLoginOptions';\n\n/**\n * @description\n * This service allows to get tenant login options.\n */\nexport class TenantLoginOptionsService extends Service<ITenantLoginOption> {\n  protected baseUrl = 'tenant';\n  protected listUrl = 'loginOptions';\n  protected propertyName = 'loginOptions';\n\n  /**\n   * Gets the details of login option.\n   *\n   * @param entityIdentityOrId Login option's id or login option object.\n   *\n   * @returns Returns promise object that is resolved with the ITenantLoginOption wrapped by IResult.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const tenantLoginOptionId: string = 'uniqueTenantLoginOptionId';\n   *\n   *    (async () => {\n   *      const {data, res} = await tenantLoginOptionsService.detail(tenantLoginOptionId);\n   *   })();\n   * ```\n   */\n  async detail(entityIdentityOrId: string | IIdentified): Promise<IResult<ITenantLoginOption>> {\n    return super.detail(entityIdentityOrId);\n  }\n\n  /**\n   * Gets the list of tenant's login options filtered by parameters.\n   *\n   * @param filter Object containing filters for querying tenant's login options.\n   *\n   * @returns Returns promise object that is resolved with the ITenantLoginOption wrapped by IResultList.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     tenantId: '1111111'\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await tenantLoginOptionsService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}): Promise<IResultList<ITenantLoginOption>> {\n    return super.list(filter);\n  }\n\n  /**\n   * Gets the list of all tenant's login options for current tenant.\n   *\n   * @returns Returns promise object that is resolved with the ITenantLoginOption wrapped by IResultList.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await tenantLoginOptionsService.listForCurrentTenant();\n   *   })();\n   * ```\n   */\n  async listForCurrentTenant(): Promise<IResultList<ITenantLoginOption>> {\n    return super.list({ tenantId: this.client.tenant });\n  }\n\n  /**\n   * Gets the list of all tenant's login options for management tenant.\n   *\n   * @returns Returns promise object that is resolved with the ITenantLoginOption wrapped by IResultList.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await tenantLoginOptionsService.listForManagement();\n   *   })();\n   * ```\n   */\n  async listForManagement(): Promise<IResultList<ITenantLoginOption>> {\n    return super.list({ management: true });\n  }\n\n  /**\n   * Creates a new tenant login option.\n   *\n   * @param entity ITenantLoginOption object.\n   *\n   * @returns Returns promise object that is resolved with the details of newly created tenant login option.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const tenantLoginOption: ITenantLoginOption = {\n   *    grantType: \"PASSWORD\",\n   *    providerName: \"Cumulocity\",\n   *    type: \"BASIC\",\n   *    userManagementSource: \"INTERNAL\",\n   *    visibleOnLoginPage: true\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await tenantLoginOptionsService.create(tenantLoginOption);\n   *  })();\n   * ```\n   */\n  async create(entity: ITenantLoginOption): Promise<IResult<ITenantLoginOption>> {\n    return super.create(entity);\n  }\n\n  /**\n   * Updates tenant's login option data.\n   *\n   * @param entity ITenantLoginOption object.\n   *\n   * @returns Returns promise object that is resolved with the saved tenant's login option object.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const tenantLoginOption: ITenantLoginOption = {\n   *    grantType: \"PASSWORD\",\n   *    id: \"2eff9a0b-e376-4ce8-a0f1-0a07cef8a8a1\",\n   *    providerName: \"Cumulocity\",\n   *    type: \"BASIC\",\n   *    userManagementSource: \"INTERNAL\",\n   *    visibleOnLoginPage: true\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await tenantLoginOptionsService.update(tenantLoginOption);\n   *  })();\n   * ```\n   */\n  async update(entity: ITenantLoginOption): Promise<IResult<ITenantLoginOption>> {\n    return super.update(entity);\n  }\n\n  /**\n   * Removes tenant's login option.\n   *\n   * @param entityOrId Tenant's login option's id or tenant's login option object.\n   *\n   * @returns Returns promise object that is resolved with the IResult of null.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const tenantLoginOptionId: string = 'uniqueTenantLoginOptionId';\n   *\n   *    (async () => {\n   *      const {data, res} = await tenantLoginOptionsService.delete(tenantLoginOptionId);\n   *   })();\n   * ```\n   */\n  async delete(entityOrId: string | IIdentified): Promise<IResult<null>> {\n    return super.delete(entityOrId);\n  }\n}\n","/**\n * A specific audit record can have one of the following types\n */\nexport enum AuditRecordType {\n  ALARM = 'Alarm',\n  BULK_OPERATION = 'BulkOperation',\n  CEP_MODULE = 'CepModule',\n  EVENT = 'Event',\n  INVENTORY = 'Inventory',\n  INVENTORY_ROLE = 'InventoryRole',\n  OPERATION = 'Operation',\n  OPTION = 'Option',\n  GROUP = 'Group',\n  SMART_RULE = 'SmartRule',\n  SYSTEM = 'SYSTEM',\n  TENANT = 'Tenant',\n  USER = 'User',\n}\n","import { gettext } from '../gettext';\r\n\r\n/**\r\n * An audit record can have one of the following change type\r\n */\r\nexport enum ChangeType {\r\n  ADDED = gettext('ADDED'),\r\n  REPLACED = gettext('REPLACED'),\r\n  REMOVED = gettext('REMOVED')\r\n}\r\n","import {Service, IResult, IResultList} from '../core';\nimport { IAuditRecord } from './IAuditRecord';\n\nexport class AuditService extends Service<IAuditRecord> {\n  protected baseUrl = 'audit';\n  protected listUrl = 'auditRecords';\n  protected propertyName = 'auditRecords';\n\n  /**\n   * Gets the details of selected audit record.\n   *\n   * @param {string|number|IAuditRecord} entityOrId Entity or Id of the entity.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const auditId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await auditService.detail(auditId);\n   *   })();\n   * ```\n   */\n  async detail(entityOrId: string | number | IAuditRecord): Promise<IResult<IAuditRecord>> {\n    return super.detail(entityOrId);\n  }\n\n  /**\n   * Creates a new audit record for a given source.\n   *\n   * @param {IAuditRecord} entity Audit record object with mandantory fragments.\n   * IAuditRecord implements the [[IEvent]] interface.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const mandantoryObject: IAuditRecord = {\n   *    type: AuditRecordType.ALARM,\n   *    time: '2018-05-02T10:08:00Z',\n   *    severity: Severity.MAJOR,\n   *    source: {id: 1}\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await auditService.create(mandantoryObject);\n   *  })();\n   * ```\n   */\n  async create(entity: IAuditRecord): Promise<IResult<IAuditRecord>> {\n    return super.create(entity);\n  }\n\n  /**\n   * Gets the list of audit records filtered by parameters.\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {object} filter Object containing filters for querying audit records.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     severity: Severity.MAJOR,\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await auditService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}): Promise<IResultList<IAuditRecord>> {\n    return super.list(filter);\n  }\n}\n","import { gettext } from '../gettext';\n\n/**\n * Device registration can have one of the following states.\n */\nexport enum DeviceRegistrationStatus {\n  WAITING_FOR_CONNECTION = gettext('WAITING_FOR_CONNECTION'),\n  PENDING_ACCEPTANCE = gettext('PENDING_ACCEPTANCE'),\n  ACCEPTED = gettext('ACCEPTED')\n}\n","import {IIdentified, Service, IResult, IResultList} from '../core';\n\nexport class InventoryRoleService extends Service<IIdentified> {\n  protected baseUrl = 'user';\n  protected listUrl = 'inventoryroles';\n  protected propertyName = 'roles';\n\n  /**\n   * Gets the details of inventory role.\n   *\n   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const inventoryRoleId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await inventoryRoleService.detail(inventoryRoleId);\n   *   })();\n   * ```\n   */\n  async detail(entityOrId: string | number | IIdentified): Promise<IResult<IIdentified>> {\n    return super.detail(entityOrId);\n  }\n\n  /**\n   * Creates a new inventory role.\n   *\n   * @param {IIdentified} entity\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const newRole: IIdentified = {\n   *    name: 'Custom role'\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await inventoryRoleService.create(newRole);\n   *  })();\n   * ```\n   */\n  async create(entity: IIdentified): Promise<IResult<IIdentified>> {\n    return super.create(entity);\n  }\n\n  /**\n   * Updates inventory role data.\n   *\n   * @param {IIdentified} entity\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const updateObject: IIdentified = {\n   *    id: 1,\n   *    name: 'changed role'\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await inventoryRoleService.update(updateObject);\n   *  })();\n   * ```\n   */\n  async update(entity: IIdentified): Promise<IResult<IIdentified>> {\n    return super.update(entity);\n  }\n\n  /**\n   * Gets the list of inventory roles filtered by parameters.\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {object} filter Object containing filters for querying alarms.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await inventoryRoleService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}): Promise<IResultList<IIdentified>> {\n    return super.list(filter);\n  }\n\n  /**\n   * Removes an inventory role with given id.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {IExternalIdentity} identity Identity object with mandantory fragments.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   const id: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await identityService.delete(id);\n   *   })();\n   * ```\n   */\n  async delete(entityOrId: string | number | IIdentified): Promise<IResult<null>> {\n    return super.delete(entityOrId);\n  }\n}\n","import { btoa } from 'b2a';\nimport {IIdentified, Service, IResult} from '../core';\nimport {\n  IDeviceRegistration,\n  IDeviceRegistrationCreate} from './IDeviceRegistration';\nimport { DeviceRegistrationStatus } from './DeviceRegistrationStatus';\nimport { IDeviceCredentials } from './IDeviceCredentials';\n\n/**\n * Interface to use as options parameter\n * to bootstrap a new device.\n */\nexport interface IDeviceBootstrapOptions {\n  /**\n   * If already logged in it is accessible via\n   * client.auth.getHeader, see [[BasicAuth.getHeader]]\n   *\n   * **Example**\n   * ``` typescript\n   *\n   * // tenant/username:password\n   * const basicAuthToken = 'Basic dGVuYW50L3VzZXJuYW1lOnBhc3N3b3Jk';\n   * ```\n   */\n  basicAuthToken?: string;\n  /**\n   * Object to define username and password\n   * as string.\n   *\n   * **Example**\n   * ``` typescript\n   *\n   *    const basicAuth = {\n   *      user: 'username',\n   *      pass: 'password'\n   *    }\n   * ```\n   */\n  basicAuth?: {\n    user: string;\n    pass: string;\n  };\n}\n\n/**\n * This class allows registration of a new device.\n */\nexport class DeviceRegistrationService extends Service<IDeviceRegistration> {\n  protected baseUrl = 'devicecontrol';\n  protected listUrl = 'newDeviceRequests';\n  protected propertyName = 'newDeviceRequests';\n\n  /**\n   * Gets the details of device registration.\n   *\n   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const entityId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await deviceRegistrationService.detail(entityId);\n   *    })();\n   * ```\n   */\n  async detail(entityOrId: string | number | IIdentified) {\n    return super.detail(entityOrId);\n  }\n\n  /**\n   * Creates a new device registration.\n   *\n   * @param {IDeviceRegistrationCreate} entity Device registration object with mandantory fragments.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const mandantoryObject: IDeviceRegistrationCreate = {\n   *      id: 1,\n   *    };\n   *\n   *    (async () => {\n   *      const {data, res} = await deviceRegistrationService.create(mandantoryObject);\n   *    })();\n   * ```\n   */\n  async create(entity: IDeviceRegistrationCreate) {\n    return super.create(entity);\n  }\n\n  /**\n   * Gets the list of device registrations by parameters.\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {object} filter Object containing filters for querying registrations.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   const filter: object = {\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await deviceRegistrationService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}) {\n    return super.list(filter);\n  }\n\n  /**\n   * Removes an registration with given id.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {string | number | IIdentified} entityOrId entity or id of the registration.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   const id = 'abc';\n   *\n   *   (async () => {\n   *     const {data, res} = await deviceRegistrationService.delete(id);\n   *     // data will be null\n   *   })();\n   * ```\n   */\n  async delete(entityOrId: string | number | IIdentified) {\n    return super.delete(entityOrId);\n  }\n\n  /**\n   * Accepts the device registration for given id.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {string | number | IIdentified} entityOrId entity or id of registration.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   const id = 'abc';\n   *\n   *   (async () => {\n   *     const {data, res} = await deviceRegistrationService.accept(id);\n   *   })();\n   * ```\n   */\n  async accept(entityOrId: string | number | IIdentified): Promise<IResult<IDeviceRegistration>> {\n    const id = this.getIdString(entityOrId);\n    const update = Object.getPrototypeOf(this).update.bind(this);\n    return update({id , status: DeviceRegistrationStatus.ACCEPTED});\n  }\n\n  /**\n   * Bootstraps the device with given id.\n   *\n   * @param entityOrId entity or id of registration.\n   * @param options for details see [[IDeviceBootstrapOptions]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   const id: 'abc';\n   *   const options: IDeviceBootstrapOptions = {\n   *     basicAuthToken: 'Basic dGVuYW50L3VzZXJuYW1lOnBhc3N3b3Jk',\n   *     basicAuth: {\n   *       user: 'username',\n   *       pass: 'password'\n   *     }\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res} = await deviceRegistrationService.bootstrap(id, options);\n   *   })();\n   * ```\n   */\n  async bootstrap(\n    entityOrId: string | number | IIdentified,\n    options: IDeviceBootstrapOptions): Promise<IResult<IDeviceCredentials>> {\n    const id = this.getIdString(entityOrId);\n    const body = JSON.stringify({id});\n    const url = `${this.baseUrl}/deviceCredentials`;\n    const { basicAuth } = options;\n    let { basicAuthToken } = options;\n    if (basicAuth) {\n       const { user, pass } = basicAuth;\n       basicAuthToken = btoa(`${user}:${pass}`);\n    }\n    const headers = {\n      Authorization: `Basic ${basicAuthToken}`,\n      accept: 'application/json',\n      'content-type': 'application/json',\n    };\n    const method = 'POST';\n    const res = await this.client.fetch(url, { body, headers, method });\n    const data = await res.json();\n    if (res.status > 400) {\n      throw { res,  data };\n    }\n    return { res, data };\n  }\n\n  protected onBeforeCreate(entity: IDeviceRegistrationCreate): IDeviceRegistrationCreate {\n    return entity;\n  }\n\n  protected onBeforeUpdate(entity: IDeviceRegistrationCreate): IDeviceRegistrationCreate {\n    const noIdEntity = Object.assign({}, entity);\n    delete noIdEntity.id;\n    return noIdEntity;\n  }\n}\n","import FormData from 'form-data';\nimport { Stream } from 'stream';\nimport { IFetchClient, IResult } from '../core';\nimport { IDeviceRegistrationBulkResult } from './IDeviceRegistrationBulkResult';\n\n/**\n * This class allows for bulk registering devices.\n */\nexport class DeviceRegistrationBulkService {\n  protected client: IFetchClient;\n\n  /**\n   * Instantiate class and assign client\n   * @param {IFetchClient} client\n   */\n  constructor(client: IFetchClient) {\n    this.client = client;\n  }\n\n  /**\n   * A new device registration as bulk.\n   *\n   * @param {Stream | Buffer} csv\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const csvString = `\n   *  ID,CREDENTIALS,TENANT,TYPE,NAME,ICCID,IDTYPE,PATH,SHELL\n   *  e2eDeviceRegistrationId,e2epassword123!,e2edocker,c8y_e2eDevice,e2eDevice,123456789,89456,e2eDeviceGroup,1\n   *  900001,e2epassword123!,e2edocker,c8y_e2eDevice1,e2eDevice1,123456789,89456,e2eDeviceGroup,1\n   *  900002,e2epassword123!,e2edocker,c8y_e2eDevice2,e2eDevice2,123456789,89456,e2eDeviceGroup,1`.trim();\n   *\n   *  const csvBuffer = Buffer.from(csvString):\n   *\n   *  (async () => {\n   *    const {data, res} = await deviceRegistrationBulkService.create(csvBuffer);\n   *  })();\n   * ```\n   */\n  async create(inputFile: Stream | Buffer | File | Blob): Promise<IResult<IDeviceRegistrationBulkResult>> {\n    let csv = inputFile;\n    const url = '/devicecontrol/bulkNewDeviceRequests';\n    const method = 'POST';\n    const body = new FormData();\n    let fileName = 'bulk-registration.csv';\n    if (typeof(File) !== 'undefined' && csv instanceof File) {\n      fileName = csv.name;\n      const checkPattern = /\\.csv$/;\n      if (csv.name.match(checkPattern)) {\n        csv = new File([csv], csv.name, { type: 'text/csv' });\n      }\n    }\n    body.append('file', csv, fileName);\n    let bodyHeaders;\n    if (typeof body.getHeaders === 'function') {\n      bodyHeaders = body.getHeaders();\n    }\n    const headers = Object.assign({\n      accept: 'application/json'\n    }, bodyHeaders);\n    const res = await this.client.fetch(url, {method, body, headers});\n    const data = await res.json();\n    return { res, data };\n  }\n}\n","import {Service} from '../core';\nimport { IRole } from './IRole';\n\n/**\n * @description\n * This service allows for fetch user roles.\n */\nexport class UserRoleService extends Service<IRole> {\n  protected baseUrl = 'user';\n  protected listUrl = 'roles';\n  protected propertyName = 'roles';\n\n  /**\n   * Gets the details of given role.\n   *\n   * @param {string|number|IRole} entityOrId Roles's id or role object.\n   *\n   * @returns Returns promise object that is resolved with the IRole wrapped by IResult.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const roleId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await userRoleService.detail(roleId);\n   *   })();\n   * ```\n   */\n  async detail(entityOrId: string | number | IRole) {\n    return super.detail(entityOrId);\n  }\n\n  /**\n   * Gets the list of user roles filtered by parameters.\n   *\n   * @param {object} filter Object containing filters for querying roles.\n   *\n   * @returns Returns promise object that is resolved with the IRole wrapped by IResultList.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     severity: Severity.MAJOR,\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await userRoleService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}) {\n    return super.list(filter);\n  }\n}\n","import {Service, IIdentified, IResult, ISource} from '../core';\nimport { IUserGroup } from './IUserGroup';\n\nenum ChildType {\n  ROLES = 'roles',\n  USERS = 'users',\n}\n\n/**\n * @description\n * This service allows for managing user groups.\n */\nexport class UserGroupService extends Service<IUserGroup> {\n  protected baseUrl = 'user';\n  protected propertyName = 'groups';\n\n  protected get listUrl() {\n    return `${this.client.tenant}/groups`;\n  }\n\n  /**\n   * Gets the details of given user group.\n   *\n   * @param {string|number|IUserGroup} entityOrId Group's id or role object.\n   *\n   * @returns Returns promise object that is resolved with the IUserGroup wrapped by IResult.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const groupId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await userGroupService.detail(roleId);\n   *   })();\n   * ```\n   */\n  async detail(entityOrId: string | number | IUserGroup) {\n    return super.detail(entityOrId);\n  }\n\n  /**\n   * Creates a new user group.\n   *\n   * @param {IUserGroup} entity User Group object.\n   *\n   * @returns {IResult<IUserGroup>} Returns promise object that is resolved with\n   * the details of newly created user group.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const userGroupObject: IUserGroup = {\n   *    name: \"new user group\"\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await userGroupService.create(userGroupObject);\n   *  })();\n   * ```\n   */\n  async create(entity: Partial<IUserGroup>) {\n    return super.create(entity);\n  }\n\n  /**\n   * Updates user group data.\n   *\n   * @param {Partial<IUserGroup>} entity User group is partially updatable.\n   *\n   * @returns {IResult<IUserGroup>} Returns promise object that is resolved with the saved user group object.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const partialUpdateObject: Partial<IUserGroup> = {\n   *     \"id\" : 1,\n   *     \"self\" : \"[URL to this resource]\",\n   *     \"name\" : \"PlatformAdministrators\",\n   *     ...\n   *   }\n   *\n   *  (async () => {\n   *    const {data, res} = await userGroupService.update(partialUpdateObject);\n   *  })();\n   * ```\n   */\n  async update(entity: Partial<IUserGroup>) {\n    return super.update(entity);\n  }\n\n  /**\n   * Gets the list of user groups filtered by parameters.\n   *\n   * @param {object} filter Object containing filters for querying User Groups.\n   *\n   * @returns Returns promise object that is resolved with the IUserGroup wrapped by IResultList.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     severity: Severity.MAJOR,\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await userGroupService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}) {\n    return super.list(filter);\n  }\n\n  /**\n   * Removes user group.\n   *\n   * @param {number | IIdentified} entityOrId User group's id or user group object.\n   *\n   * @returns Returns promise object that is resolved with the IResult of null.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const userGroupId: number = 1;\n   *\n   *    (async () => {\n   *      const {data, res} = await userGroupService.delete(userGroupId);\n   *   })();\n   * ```\n   * When group is removed, suitable audit records are created with type 'User'\n   * and activity 'User updated' with information that user has been removed from group.\n   *\n   * Please, note that the ADMINS and DEVICES groups can not be deleted.\n   */\n  async delete(entityOrId: number | IIdentified) {\n    return super.delete(entityOrId);\n  }\n\n  /**\n   * Assign role to user group.\n   *\n   * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.\n   * @param {string | Partial<ISource>} childEntityOrSelf Url to role resource or IRoleReference object.\n   *\n   * @returns Returns promise object that is resolved with the IRoleReference wrapped by IResult.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const userGroupId: number = 1;\n   *    const roleResource: string = \"[URL to the Role resource]\";\n   *\n   *    (async () => {\n   *      const {data, res} = await userGroupService.addRoleToGroup(userGroupId, roleResource);\n   *   })();\n   * ```\n   * When role is assigned to user, suitable audit record is created with type 'User' and activity 'User updated'.\n   */\n  async addRoleToGroup(\n    entityOrId: string | number | Partial<IUserGroup>,\n    childEntityOrSelf: string | Partial<ISource>\n  ) {\n    return this.addChild(ChildType.ROLES, entityOrId, childEntityOrSelf);\n  }\n\n  /**\n   * Unassign role from user\n   *\n   * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.\n   * @param {string | Partial<ISource>} childEntityOrSelf Url to user resource or IRoleReference object.\n   *\n   * @returns Returns promise object that is resolved with the IResult of null.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const userGroupId: number = 1;\n   *    const userResource: string = \"[URL to the Role resource]\";\n   *\n   *    (async () => {\n   *      const {data, res} = await userGroupService.removeRoleFromGroup(userGroupId, userResource);\n   *   })();\n   * ```\n   */\n   async removeRoleFromGroup(\n    entityOrId: string | number | Partial<IUserGroup>,\n    childEntityOrSelf: string | Partial<ISource>\n  ) {\n    return this.removeChild(ChildType.ROLES, entityOrId, childEntityOrSelf);\n  }\n\n  /**\n   * Assign user to user group.\n   *\n   * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.\n   * @param {string | Partial<ISource>} childEntityOrSelf Url to user resource or IUserReference object.\n   *\n   * @returns Returns promise object that is resolved with the IUserReference wrapped by IResult.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const userGroupId: number = 1;\n   *    const userResource: string = \"[URL to the User resource]\";\n   *\n   *    (async () => {\n   *      const {data, res} = await userGroupService.addUserToGroup(userGroupId, userResource);\n   *   })();\n   * ```\n   * When user is added to group, suitable audit record is created with type 'User' and activity 'User updated'.\n   */\n  async addUserToGroup(\n    entityOrId: string | number | Partial<IUserGroup>,\n    childEntityOrSelf: string | Partial<ISource>\n  ) {\n    return this.addChild(ChildType.USERS, entityOrId, childEntityOrSelf);\n  }\n\n  /**\n   * Remove user from a group\n   *\n   * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.\n   * @param {string | Partial<ISource>} childEntityOrSelf Url to user resource or IUserReference object.\n   *\n   * @returns Returns promise object that is resolved with the IResult of null.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const userGroupId: number = 1;\n   *    const userResource: string = \"[URL to the User resource]\";\n   *\n   *    (async () => {\n   *      const {data, res} = await userGroupService.removeUserFromGroup(userGroupId, userResource);\n   *   })();\n   * ```\n   * When user is removed from group, suitable audit record is created with type 'User' and activity 'User updated'.\n   */\n  async removeUserFromGroup(\n    entityOrId: string | number | Partial<IUserGroup>,\n    childEntityOrSelf: string | Partial<ISource>\n  ) {\n    return this.removeChild(ChildType.USERS, entityOrId, childEntityOrSelf);\n  }\n\n  protected getSelf(childReference: string | Partial<ISource>): string {\n    if (typeof childReference === 'object' && childReference.self) {\n      return childReference.self;\n    } else {\n      return childReference as string;\n    }\n  }\n\n  private getChildUrl(type: ChildType, userGroupOrId: string | number | Partial<IUserGroup>): string {\n    return `${this.getDetailUrl(userGroupOrId)}/${type}`;\n  }\n\n  private getChildReferenceAsBody(type: ChildType, childReference: string | Partial<ISource>) {\n    const childSelf = this.getSelf(childReference);\n    switch (type) {\n      case ChildType.ROLES:\n        return JSON.stringify({role: {self: String(childSelf)}});\n      case ChildType.USERS:\n        return JSON.stringify({user: {self: String(childSelf)}});\n    }\n    throw new Error('UserGroupService -> getChild -> unsupported child type');\n  }\n\n  private async addChild(\n    type: ChildType,\n    userGroupOrId: string | number | Partial<IUserGroup>,\n    childReference: string | Partial<ISource>\n  ): Promise<IResult<IIdentified>> {\n    const url = this.getChildUrl(type, userGroupOrId);\n    const method = 'POST';\n    const body = this.getChildReferenceAsBody(type, childReference);\n    const headers = {\n      accept: 'application/json',\n      'content-type': 'application/json'\n    };\n    const res = await this.fetch(url, { method, body, headers});\n    let data = await res.json();\n    data = data.managedObject;\n    return { res, data };\n  }\n\n  private async removeChild(\n    type: ChildType,\n    userGroupOrId: string | number | Partial<IUserGroup>,\n    childReference: string | IIdentified\n  ): Promise<IResult<null>> {\n    const childId = this.getIdString(childReference);\n    const url = `${this.getChildUrl(type, userGroupOrId)}/${encodeURIComponent(String(childId))}`;\n    const method = 'DELETE';\n    const headers = { accept: 'application/json' };\n    const res = await this.fetch(url, { method, headers });\n    const data = null;\n    return { res, data };\n  }\n}\n","import {\n  Service,\n  IResult,\n  IResultList,\n  IFetchClient,\n  IFetchOptions,\n  IFetchResponse\n} from '../core';\nimport { IExternalIdentity } from './IExternalIdentity';\n\n/**\n * This class allwos for managing external identifiers.\n */\nexport class IdentityService {\n  private baseUrl: string = 'identity';\n  private propertyName: string = 'externalIds';\n  private client: IFetchClient;\n\n  constructor(client: IFetchClient) {\n    this.client = client;\n  }\n\n  /**\n   * Gets the list of identities filtered by parameters.\n   *\n   * @returns Response wrapped in [[IResultList]]\n   *\n   * @param {object} filter Object containing filters for querying identity.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const filter: object = {\n   *     pageSize: 100,\n   *     withTotalPages: true\n   *   };\n   *\n   *   (async () => {\n   *     const {data, res, paging} = await identityService.list(filter);\n   *   })();\n   * ```\n   */\n  async list(managedObjectId: string): Promise<IResultList<IExternalIdentity>> {\n    const headers = { accept: 'application/json' };\n    const url = this.getExternalIdsOfGlobalIdUrl(managedObjectId);\n    const res = await this.fetch(url, { headers });\n    const json = await res.json();\n    const data = json[this.propertyName];\n    return { res, data };\n  }\n\n  /**\n   * Creates a new identity.\n   *\n   * @param {IExternalIdentity} identity Identity object with mandantory fragments.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *   const linkedManagedObjectId = '123';\n   *   const identity: IExternalIdentity = {\n   *      type: 'type',\n   *      externalId: '1',\n   *      managedObject: {\n   *        id: linkedManagedObjectId\n   *      }\n   *    };\n   *\n   *    (async () => {\n   *      const {data, res} = await identityService.create(identity);\n   *   })();\n   * ```\n   */\n  async create(identity: IExternalIdentity): Promise<IResult<IExternalIdentity>> {\n    const headers = { 'content-type': 'application/json', accept: 'application/json' };\n    const method = 'POST';\n    const body = JSON.stringify(identity);\n    const url = this.getExternalIdsOfGlobalIdUrl(identity.managedObject.id);\n    const res = await this.fetch(url, { headers, method, body });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  /**\n   * Gets the details of an identity.\n   *\n   * @param {IExternalIdentity} identity Identity object with mandantory fragments.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const identity: IExternalIdentity = {\n   *      type: 'type',\n   *      externalId: '1'\n   *    };\n   *\n   *    (async () => {\n   *      const {data, res} = await identityService.detail(identity);\n   *   })();\n   * ```\n   */\n  async detail(identity: IExternalIdentity): Promise<IResult<IExternalIdentity>> {\n    const headers = { accept: 'application/json' };\n    const url = this.getExternalIdUrl(identity);\n    const res = await this.fetch(url, { headers });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  /**\n   * Removes an identity with given id.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {IExternalIdentity} identity Identity object with mandantory fragments.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   const identity: IExternalIdentity = {\n   *      type: 'type',\n   *      externalId: '1'\n   *    };\n   *\n   *    (async () => {\n   *      const {data, res} = await identityService.delete(identity);\n   *   })();\n   * ```\n   */\n  async delete(identity: IExternalIdentity): Promise<IResult<IExternalIdentity>> {\n    const headers = { accept: 'application/json' };\n    const method = 'DELETE';\n    const url = this.getExternalIdUrl(identity);\n    const res = await this.fetch(url, { headers, method });\n    return { res, data: null };\n  }\n\n  private async fetch(url: string, init?: IFetchOptions): Promise<IFetchResponse> {\n    const res: IFetchResponse = await this.client.fetch(url, init);\n    if (res.status >= 400) {\n      let data = null;\n      try {\n        data = await res.json();\n      } catch (ex) {\n        try {\n          data = await res.text();\n        } catch (ex) {\n          // do nothing\n        }\n      }\n      throw { res, data };\n    }\n    return res;\n  }\n\n  private getExternalIdsOfGlobalIdUrl(managedObjectId: string | number): string {\n    return `/${this.baseUrl}/globalIds/${managedObjectId}/externalIds`;\n  }\n\n  private getExternalIdUrl(identity: IExternalIdentity): string {\n    return `/${this.baseUrl}/externalIds/${identity.type}/${identity.externalId}`;\n  }\n}\n","import { ApplicationService } from '../application';\nimport { IFetchClient, IResult } from '../core';\nimport { Service } from '../core/Service';\nimport { IdReference, IManagedObject } from '../inventory';\nexport class SmartGroupsService extends Service<IManagedObject> {\n  protected baseUrl = 'inventory';\n  protected listUrl = 'managedObjects';\n  private applicationService: ApplicationService;\n  private readonly SMART_GROUP_TYPE = 'c8y_DynamicGroup';\n  private readonly SMART_GROUP_FRAGMENT_TYPE = 'c8y_IsDynamicGroup';\n  private readonly DEVICE_GROUP_FRAGMENT_TYPE = 'c8y_IsDeviceGroup';\n  private readonly DEVICE_GROUP_TYPE = 'c8y_DeviceGroup';\n  private readonly DEVICE_SUBGROUP_TYPE = 'c8y_DeviceSubgroup';\n  private readonly SMART_GROUPS_V2_MICROSERVICE_APP_NAME = 'smartgroup';\n  private readonly SMART_GROUPS_V2_MICROSERVICE_BASE_PATH = 'service/smartgroup';\n  private readonly SMART_GROUPS_V2_MICROSERVICE_ENDPOINT_PATH = `${\n    this.SMART_GROUPS_V2_MICROSERVICE_BASE_PATH\n  }/smartgroups`;\n\n  constructor(client: IFetchClient) {\n    super(client);\n    this.applicationService = new ApplicationService(client);\n  }\n\n  /**\n   * Gets the details of managed object\n   *\n   * @param {IdReference} entityOrId Entity or Id of the ManagedObject.\n   * @param {object} filter Filter object.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @example\n   * ```typescript\n   *\n   *    const id: string = '1';\n   *    const filter: any = { withChildren: false };\n   *\n   *    (async () => {\n   *      const {data, res} = await smartGroupsService.detail(id, filter);\n   *   })();\n   * ```\n   */\n  async detail(entityOrId: IdReference, filter: object = {}): Promise<IResult<IManagedObject>> {\n    return super.detail(entityOrId, filter);\n  }\n\n  /**\n   * Updates smart group managed object with given id.\n   *\n   * @param {Partial<IManagedObject>} mo Partial managed object of the smart group.\n   * @param {object} filter Filter object.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @example\n   * ```typescript\n   *\n   *    const smartGroup = { id: '1', name: 'newName' };\n   *\n   *    (async () => {\n   *      await smartGroupsService.update(smartGroup);\n   *   })();\n   * ```\n   */\n  async update(mo: Partial<IManagedObject>, filter: object = {}): Promise<IResult<IManagedObject>> {\n    const { id } = mo;\n\n    const { data: isInstalled } = await this.isSmartGroupsV2MicroserviceInstalled();\n    const { data: groupMo } = await this.detail(id, { withChildren: false });\n\n    return isInstalled && this.isSmartGroupV2(groupMo)\n      ? this.updateSmartGroupV2(mo, filter)\n      : super.update(mo);\n  }\n\n  /**\n   * Updates smart group v2 managed object with given id.\n   *\n   * @param {Partial<IManagedObject>} mo Partial managed object of the smart group v2.\n   * @param {object} filter Filter object.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @example\n   * ```typescript\n   *\n   *    const smartGroupV2 = { id: '1', name: 'newName' };\n   *\n   *    (async () => {\n   *      await smartGroupsService.updateSmartGroupV2(smartGroupV2);\n   *   })();\n   * ```\n   */\n  async updateSmartGroupV2(\n    mo: Partial<IManagedObject>,\n    filter: object = {}\n  ): Promise<IResult<IManagedObject>> {\n    const { id, ...partialMo } = mo;\n    const method = 'PUT';\n    const body = JSON.stringify(this.onBeforeUpdate(partialMo));\n    const headers = { 'content-type': 'application/json', accept: 'application/json' };\n    const url = `${this.SMART_GROUPS_V2_MICROSERVICE_ENDPOINT_PATH}/${id}`;\n    const res = await this.fetch(url, { method, body, headers, params: { ...filter } });\n\n    const data = await res.json();\n\n    return { res, data };\n  }\n\n  /**\n   * Removes managed object with given id.\n   *\n   * @param {IManagedObject} group Managed object of the group.\n   * @param {object} params Additional query params.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @example\n   * ```typescript\n   *\n   *   const group = { id: '1' } as IManagedObject;\n   *   const params: any = {\n   *     withChildren: false\n   *   }\n   *\n   *    (async () => {\n   *      await smartGroupsService.delete(group, params);\n   *   })();\n   * ```\n   */\n  async delete(entityOrId: IdReference, params: any = {}): Promise<IResult<null>> {\n    const { data: isInstalled } = await this.isSmartGroupsV2MicroserviceInstalled();\n    const data = (await this.detail(entityOrId, { withChildren: false })).data;\n\n    return isInstalled && this.isSmartGroupV2(data)\n      ? await this.removeSmartGroupV2(data)\n      : await super.delete(data, params);\n  }\n\n  /**\n   * Checks if the smart groups v2 microservice is installed.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @example\n   * ```typescript\n   *\n   *    (async () => {\n   *      const {data, res} = await smartGroupsService.isSmartGroupsV2MicroserviceInstalled();\n   *   })();\n   * ```\n   */\n  isSmartGroupsV2MicroserviceInstalled(): Promise<IResult<boolean>> {\n    return this.applicationService.isAvailable({\n      name: this.SMART_GROUPS_V2_MICROSERVICE_APP_NAME\n    });\n  }\n\n  /**\n   * Checks whether a given managed object is a smart group\n   *\n   * @param {IManagedObject} mo Managed object to check.\n   *\n   * @returns boolean\n   *\n   * @example\n   * ```typescript\n   *\n   *    const mo: IManagedObject = {id: 1, type: \"c8y_DeviceGroup\", c8y_IsDeviceGroup: {}} as IManagedObject;\n   *\n   *    (() => {\n   *      const isSmartGroup = smartGroupsService.isSmartGroup(mo);\n   *   })();\n   * ```\n   */\n  isSmartGroup(mo: Partial<IManagedObject>): boolean {\n    const hasSmartGroupFragmentType = mo.hasOwnProperty(this.SMART_GROUP_FRAGMENT_TYPE);\n    const isSmartGroupType = mo && mo.type === this.SMART_GROUP_TYPE;\n\n    return hasSmartGroupFragmentType || isSmartGroupType;\n  }\n\n  /**\n   * Checks whether a given managed object is a smart group v2\n   *\n   * @param {IManagedObject} mo Managed object to check.\n   *\n   * @returns boolean\n   *\n   * @example\n   * ```typescript\n   *\n   *    const mo: IManagedObject = {id: 1, type: \"c8y_DeviceGroup\", c8y_IsDeviceGroup: {}} as IManagedObject;\n   *\n   *    (() => {\n   *      const isSmartGroup = smartGroupsService.isSmartGroupV2(mo);\n   *   })();\n   * ```\n   */\n  isSmartGroupV2(mo: Partial<IManagedObject>): boolean {\n    const hasSmartGroupFragmentType = mo.hasOwnProperty(this.SMART_GROUP_FRAGMENT_TYPE);\n    const hasDeviceGroupFragmentType = mo.hasOwnProperty(this.DEVICE_GROUP_FRAGMENT_TYPE);\n    const isGroupOrSubgroup =\n      (mo && mo.type === this.DEVICE_GROUP_TYPE) || mo.type === this.DEVICE_SUBGROUP_TYPE;\n\n    return hasSmartGroupFragmentType && hasDeviceGroupFragmentType && isGroupOrSubgroup;\n  }\n\n  /**\n   * Removes smart group v2 managed object with given id.\n   *\n   * @param {IdReference} entityOrId entity or Id of the ManagedObject.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @example\n   * ```typescript\n   *\n   *    const id: string = '1';\n   *\n   *    (async () => {\n   *      await smartGroupsService.removeSmartGroupV2(id);\n   *   })();\n   * ```\n   */\n  async removeSmartGroupV2(entityOrId: IdReference): Promise<IResult<null>> {\n    let id: IdReference;\n\n    if (typeof entityOrId === 'object' && entityOrId.id) {\n      id = entityOrId.id;\n    } else {\n      id = entityOrId as string | number;\n    }\n\n    const method = 'DELETE';\n    const url = `${this.SMART_GROUPS_V2_MICROSERVICE_ENDPOINT_PATH}/${id}`;\n    const res = await this.client.fetch(url, { method });\n\n    return { res, data: null };\n  }\n\n  protected getUrl(url: string = ''): string {\n    const partialUrl = url.replace(/^\\/+/, '');\n    const baseUrl = this.baseUrl.replace(/\\/+$/, '');\n\n    if (url.includes(this.SMART_GROUPS_V2_MICROSERVICE_ENDPOINT_PATH)) {\n      return partialUrl;\n    } else {\n      return `${baseUrl}/${partialUrl}`;\n    }\n  }\n}\n","import { IResult } from '../core';\nimport { IFetchClient } from '../core/IFetchClient';\nimport { Service } from '../core/Service';\nimport { IdReference } from '../inventory';\nimport { IRule } from './IRule';\n\nexport class SmartRulesService extends Service<IRule> {\n  protected readonly baseUrl = 'service/smartrule';\n  protected readonly listUrl;\n  private readonly rulesUrl = 'smartrules';\n  private readonly unupdatableFields = ['type', 'cepModuleId', 'creationTime', 'lastUpdated'];\n\n  constructor(client: IFetchClient) {\n    super(client);\n  }\n\n  /**\n   * Gets a list of smart rules for given managed object.\n   *\n   * @param {IdReference} entityOrId Entity or Id of the ManagedObject.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @example\n   * ```typescript\n   *\n   *    const id: string = '1';\n   *\n   *    (async () => {\n   *      const {data, res} = await smartRulesService.listByContext(id);\n   *   })();\n   * ```\n   */\n  async listByContext(entityOrId: IdReference): Promise<IResult<IRule[]>> {\n    const url = this.contextRulesUrl(entityOrId);\n    const res = await this.fetch(url, { method: 'GET' });\n    const rules = (await res.json()).rules;\n    return { res, data: rules };\n  }\n\n  /**\n   * Deactivates smart rule for given entities list.\n   *\n   * @param {Partial<IRule>} rule Smart rule managed object.\n   * @param {IdReference[]} entitiesOrIdsList List of entities or Id of the ManagedObjects.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @example\n   * ```typescript\n   *\n   *    const rule: IRule = {id: '1', enabledSources: ['2', '3'],...};\n   *    const entityOrIdList: IdReference[] = ['2'];\n   *    (async () => {\n   *      const {data, res} = await smartRulesService.bulkDeactivateEnabledSources(rule, entityOrIdList);\n   *   })();\n   * ```\n   */\n  bulkDeactivateEnabledSources(\n    rule: Partial<IRule>,\n    entitiesOrIdsList: IdReference[]\n  ): Promise<IResult<IRule>> {\n    if (entitiesOrIdsList.length === 0) {\n      return Promise.resolve({ res: null, data: null });\n    }\n    const { enabledSources } = rule;\n    const newEnabledSources = this.disableEnabledSources(enabledSources, entitiesOrIdsList);\n    const ruleCopy = { ...rule };\n\n    Object.assign(ruleCopy, { enabledSources: newEnabledSources });\n    return this.update(ruleCopy);\n  }\n\n  /**\n   * Updates smart rule.\n   *\n   * @param {Parial<IRule>} rule Smart rule managed object.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @example\n   * ```typescript\n   *\n   *    const rule: IRule = {id: '1', enabledSources: ['2', '3'],...};\n   *    (async () => {\n   *      const {data, res} = await smartRulesService.updateSmartRule(rule);\n   *   })();\n   * ```\n   */\n  async update(rule: Partial<IRule>): Promise<IResult<IRule>> {\n    const url = this.getSmartRulesUrl(rule);\n    const method = 'PUT';\n    const body = JSON.stringify(this.removeUnclonableFields(rule, this.unupdatableFields));\n    const headers = { 'content-type': 'application/json', accept: 'application/json' };\n    const res = await this.fetch(url, { method, body, headers });\n    const data = await res.json();\n\n    return { res, data };\n  }\n\n  private disableEnabledSources(\n    enabledSources: string[] = [],\n    entityOrIdList: IdReference[]\n  ): string[] {\n    return enabledSources.filter(id => !this.getListOfStringIds(entityOrIdList).includes(id));\n  }\n\n  private getListOfStringIds(entityOrIdList: IdReference[]): string[] {\n    return entityOrIdList.map(entityOrId => {\n      if (typeof entityOrId === 'object' && entityOrId.id) {\n        return entityOrId.id.toString();\n      }\n      return entityOrId.toString();\n    });\n  }\n\n  private getSmartRulesUrl(rule: Partial<IRule>): string {\n    const contextMoId = rule && rule.c8y_Context && rule.c8y_Context.id;\n    let url = !!contextMoId ? this.contextRulesUrl(contextMoId) : this.rulesUrl;\n\n    if (rule.id) {\n      url = `${url}/${rule.id}`;\n    }\n    return url;\n  }\n\n  private removeUnclonableFields(rule: Partial<IRule>, fieldsToRemove: string[]): Partial<IRule> {\n    const ruleCopy = { ...rule };\n    fieldsToRemove.forEach(f => {\n      delete ruleCopy[f];\n    });\n    return ruleCopy;\n  }\n\n  private contextRulesUrl(entityOrId: IdReference = {}): string {\n    if (typeof entityOrId === 'object' && entityOrId.id) {\n      return `managedObjects/${entityOrId.id}/smartrules`;\n    }\n    return `managedObjects/${entityOrId}/smartrules`;\n  }\n}\n","import { IAuthentication, ICredentials, IMicroserviceSubscriptionsResponse } from './core';\nimport { Realtime } from './realtime';\nimport {\n  FetchClient,\n  BasicAuth,\n  AlarmService,\n  ApplicationService,\n  AuditService,\n  DeviceRegistrationBulkService,\n  DeviceRegistrationService,\n  EventService,\n  InventoryBinaryService,\n  InventoryRoleService,\n  InventoryService,\n  MeasurementService,\n  OperationBulkService,\n  OperationService,\n  SystemOptionsService,\n  TenantOptionsService,\n  TenantSecurityOptionsService,\n  TenantLoginOptionsService,\n  TenantService,\n  UserGroupService,\n  UserRoleService,\n  UserService,\n  IdentityService,\n  SmartGroupsService,\n  SmartRulesService\n} from './services';\n\nexport interface IBootstrapOptions {\n  deviceId: string;\n  basicAuthToken: string;\n  timeout?: number;\n  expire?: number;\n  baseUrl?: string;\n}\n\nexport class Client {\n  /**\n   * Authenticates the given user. Determines the tenant by itself via a call to tenant/currentTenant.\n   *\n   * **Example**\n   * ```typescript\n   *\n   * let client: Client;\n   * (async () => {\n   *  client = await Client.authenticate({\n   *    user: 'testuser',\n   *    password: 'password1337!'\n   *  }, 'https://acme.cumulocity.com');\n   *\n   *  //you have access to the client api now\n   *  const { data, paging, res }); =  await client.inventory.list({ pageSize: 100 });\n   * })();\n   * ```\n   */\n  static async authenticate(credentials: ICredentials, baseUrl?: string): Promise<Client> {\n    const auth = new BasicAuth(credentials);\n    const clientCore = new FetchClient(auth, baseUrl);\n    const res = await clientCore.fetch('/tenant/currentTenant', { method: 'GET'});\n    if (res.status !== 200) {\n      throw { res };\n    }\n    const { name } = await res.json();\n    const client = new Client(auth, baseUrl);\n    client.core.tenant = name;\n    return client;\n  }\n  /**\n   * Allows to use http to register a device on the platform.\n   *\n   * **Deprecated** Please use MQTT to bootstrap a device.\n   */\n  static async deviceBootstrap(options: IBootstrapOptions): Promise<Client> {\n    const { deviceId, timeout, baseUrl, basicAuthToken } = options;\n    let { expire } = options;\n    if (timeout && !expire) {\n      expire = Date.now() + timeout;\n    }\n    const clientCore = new FetchClient(undefined, baseUrl);\n    const deviceRegistration = new DeviceRegistrationService(clientCore);\n    let client;\n    try {\n      const { data } = await deviceRegistration.bootstrap(deviceId, { basicAuthToken });\n      const { username, password, tenantId } = data;\n      const auth = new BasicAuth({user: username, tenant: tenantId, password});\n      client = new Client(auth, baseUrl);\n      client.core.tenant = tenantId;\n    } catch (error) {\n      const retry = (!expire || Date.now() < expire) && error.res.status === 404;\n      if (retry) {\n        return Client.deviceBootstrap(Object.assign({ expire }, options));\n      } else {\n        throw error;\n      }\n    }\n    return client;\n  }\n\n  /**\n   * Retrieves microservice credentials for the subscribed tenants\n   * using provided bootstrap credentials\n   *\n   * **Example**\n   * ```typescript\n   *\n   * (async () => {\n   *  const subscriptions = await Client.getMicroserviceSubscriptions({\n   *    tenant: process.env.C8Y_BOOTSTRAP_TENANT,\n   *    user: process.env.C8Y_BOOTSTRAP_USER,\n   *    password: process.env.C8Y_BOOTSTRAP_PASSWORD\n   *  }, process.env.C8Y_BASEURL);\n   *\n   *  const clients = subscriptions.map(subscription => new Client(new BasicAuth(subscription), process.env.C8Y_BASEURL));\n   *  // you have access to the client api now\n   *  const promiseArray = clients.map(client => client.options.tenant.detail({\n   *    category: process.env.APPLICATION_KEY,\n   *    key: 'someSetting'\n   *  }));\n   * })();\n   * ```\n   */\n  static async getMicroserviceSubscriptions(\n    bootstrapCredentials: ICredentials,\n    baseUrl: string\n  ): Promise<ICredentials[]> {\n    const microserviceSubscriptionsEndpoint = '/application/currentApplication/subscriptions';\n    const clientCore = new FetchClient(new BasicAuth(bootstrapCredentials), baseUrl);\n    const res = await clientCore.fetch(microserviceSubscriptionsEndpoint);\n    const { users }: IMicroserviceSubscriptionsResponse = await res.json();\n    return users.map(({ tenant, name, password }) => {\n      return {\n        tenant,\n        user: name,\n        password\n      } as ICredentials;\n    });\n  }\n\n  alarm: AlarmService;\n  application: ApplicationService;\n  audit: AuditService;\n  core: FetchClient;\n  deviceRegistration: DeviceRegistrationService;\n  deviceRegistrationBulk: DeviceRegistrationBulkService;\n  event: EventService;\n  inventory: InventoryService;\n  inventoryRole: InventoryRoleService;\n  inventoryBinary: InventoryBinaryService;\n  measurement: MeasurementService;\n  operation: OperationService;\n  operationBulk: OperationBulkService;\n  options: {\n    security: TenantSecurityOptionsService;\n    system: SystemOptionsService;\n    login: TenantLoginOptionsService;\n    tenant: TenantOptionsService;\n  };\n  realtime: Realtime;\n  role: InventoryRoleService;\n  tenant: TenantService;\n  user: UserService;\n  userGroup: UserGroupService;\n  userRole: UserRoleService;\n  identity: IdentityService;\n  smartGroups: SmartGroupsService;\n  smartRules: SmartRulesService;\n\n  /**\n   * Initializes a new Client, which allows to request data from the API. Differently\n   * to Client.authenticate([...]) it needs a tenant given and does not verify if the\n   * login is correct.\n   *\n   * **Example**\n   * ```typescript\n   *\n   * const auth = new BasicAuth({\n   *   user: 'youruser',\n   *   password: 'yourpassword',\n   *   tenant: 'acme'\n   * }); // use CookieAuth() if your platform uses oauth (only in browser!)\n   *\n   * const baseUrl = 'https://acme.cumulocity.com';\n   * const client = new Client(auth, baseUrl);\n   * (async () => {\n   *   const { data, paging, res }); =  await client.inventory.list({ pageSize: 100 });\n   * })();\n   * ```\n   *\n   * @param auth The Authentication strategy to use (e.g. new BasicAuth())\n   * @param baseUrl The URL to request (optional in browser, mandatory in node)\n   */\n  constructor(auth: IAuthentication, baseUrl?: string) {\n    const client = new FetchClient(auth, baseUrl);\n    this.realtime = new Realtime(client);\n    this.alarm = new AlarmService(client, this.realtime);\n    this.application = new ApplicationService(client, this.realtime);\n    this.audit = new AuditService(client);\n    this.core = client;\n    this.deviceRegistration = new DeviceRegistrationService(client);\n    this.deviceRegistrationBulk = new DeviceRegistrationBulkService(client);\n    this.event = new EventService(client, this.realtime);\n    this.inventory = new InventoryService(client, this.realtime);\n    this.inventoryBinary = new InventoryBinaryService(client);\n    this.inventoryRole = new InventoryRoleService(client);\n    this.measurement = new MeasurementService(client, this.realtime);\n    this.operation = new OperationService(client);\n    this.operationBulk = new OperationBulkService(client);\n    this.options = {\n      security: new TenantSecurityOptionsService(client),\n      system: new SystemOptionsService(client),\n      login: new TenantLoginOptionsService(client),\n      tenant: new TenantOptionsService(client),\n    };\n    this.role = new InventoryRoleService(client);\n    this.tenant = new TenantService(client);\n    this.user = new UserService(client);\n    this.userGroup = new UserGroupService(client);\n    this.userRole = new UserRoleService(client);\n    this.identity = new IdentityService(client);\n    this.smartGroups = new SmartGroupsService(client);\n    this.smartRules = new SmartRulesService(client);\n  }\n\n  /**\n   * Allows to change the current Authentication\n   * @param auth The new Authentication information.\n   */\n  setAuth(auth: IAuthentication) {\n    this.core.setAuth(auth);\n    this.realtime.disconnect();\n  }\n}\n","import { IAuthentication, ICredentials } from './IAuthentication';\nimport { FetchClient } from './FetchClient';\n\n/**\n * Allows to use Cookies for Authorization to the\n * Cumulocity API.\n */\nexport class CookieAuth implements IAuthentication {\n  user: string;\n  private logoutUrl = 'user/logout';\n\n  updateCredentials({ user }: ICredentials = {}): string {\n    this.user = user;\n    return undefined;\n  }\n\n  getFetchOptions(options) {\n    const xsrfToken = this.getCookieValue('XSRF-TOKEN');\n    const headers: any = { 'X-XSRF-TOKEN': xsrfToken };\n    options.headers = Object.assign(headers, options.headers);\n    return options;\n  }\n\n  getCometdHandshake(config: { ext?: {} } = {}) {\n    const KEY = 'com.cumulocity.authn';\n    const xsrfToken = this.getCookieValue('XSRF-TOKEN');\n    const ext = (config.ext = config.ext || {});\n    ext[KEY] = Object.assign(ext[KEY] || {}, { xsrfToken });\n    return config;\n  }\n\n  async logout() {\n    if (this.user) {\n      delete this.user;\n    }\n    const client = new FetchClient();\n    client.setAuth(this);\n    const method = 'POST';\n    const body = JSON.stringify({});\n    const headers = { 'content-type': 'application/json', accept: 'application/json' };\n    return client.fetch(this.logoutUrl, { headers, body, method });\n  }\n\n  private getCookieValue(name) {\n    const value = document.cookie.match('(^|;)\\\\s*' + name + '\\\\s*=\\\\s*([^;]+)');\n    return value ? value.pop() : '';\n  }\n}\n","import {\n  IAuthentication,\n  ICredentials,\n  IMicroserviceClientRequestHeaders\n} from './IAuthentication';\n\n/**\n * Allows to use either Cookie-Auth or Basic-Auth\n * of a microservice client request header\n * for Authorization to the Cumulocity API.\n */\nexport class MicroserviceClientRequestAuth implements IAuthentication {\n  // Bearer token read from cookie from header\n  private authTokenFromCookie: string;\n  // Bearer/Basic auth token read from header\n  private authTokenFromHeader: string;\n  private xsrfToken: string;\n\n  /**\n   * Authenticates using the credentials which were\n   * provided within the request headers of the\n   * client call to the microservice.\n   * @param headers\n   */\n  constructor(headers: IMicroserviceClientRequestHeaders = {}) {\n    this.xsrfToken = this.getCookieValue(headers, 'XSRF-TOKEN');\n    this.authTokenFromCookie = this.getCookieValue(headers, 'authorization');\n    this.authTokenFromHeader = headers.authorization;\n  }\n\n  updateCredentials(credentials: ICredentials = {}): string {\n    return undefined;\n  }\n\n  getFetchOptions(options: any) {\n    const headers: any = {\n      Authorization: this.authTokenFromCookie\n        ? `Bearer ${this.authTokenFromCookie}`\n        : this.authTokenFromHeader,\n      ...(this.xsrfToken ? { 'X-XSRF-TOKEN': this.xsrfToken } : undefined)\n    };\n    options.headers = Object.assign(headers, options.headers);\n    return options;\n  }\n\n  getCometdHandshake(config: { ext?: { [key: string]: any } } = {}) {\n    const KEY = 'com.cumulocity.authn';\n    const xsrfToken = this.xsrfToken;\n    let token = this.authTokenFromCookie;\n    if (!token && this.authTokenFromHeader) {\n      token = this.authTokenFromHeader.replace('Basic ', '').replace('Bearer ', '');\n    }\n    const ext = (config.ext = config.ext || {});\n    ext[KEY] = Object.assign(ext[KEY] || {}, { token, ...(xsrfToken ? { xsrfToken } : undefined) });\n    return config;\n  }\n\n  logout() {\n    if (this.authTokenFromCookie) {\n      delete this.authTokenFromCookie;\n    }\n    if (this.authTokenFromHeader) {\n      delete this.authTokenFromHeader;\n    }\n    if (this.xsrfToken) {\n      delete this.xsrfToken;\n    }\n  }\n\n  private getCookieValue(headers: IMicroserviceClientRequestHeaders, name: string) {\n    try {\n      const value =\n        headers && headers.cookie && headers.cookie.match('(^|;)\\\\s*' + name + '\\\\s*=\\\\s*([^;]+)');\n      return value ? value.pop() : undefined;\n    } catch (ex) {\n      return undefined;\n    }\n  }\n}\n","import { IFetchOptions, IFetchResponse, Service } from '../core';\nimport { ITrustedCertificate } from './ITrustedCertificate';\n\n/**\n * This class allows for managing trusted certificates.\n */\nexport class TrustedCertificateService extends Service<ITrustedCertificate> {\n  protected get baseUrl() {\n    return `/tenant/tenants/${this.client.tenant}`;\n  }\n  protected listUrl = 'trusted-certificates';\n  protected propertyName = 'certificates';\n\n  /**\n   * Gets a list of trusted certificates.\n   *\n   * @returns Response wrapped in [[IResultList]].\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   (async () => {\n   *     const {data, res} = await trustedCertificateService.list();\n   *   })();\n   * ```\n   */\n  async list(filter: object = {}) {\n    return super.list(filter);\n  }\n\n  /**\n   * Gets the details of trusted certificate\n   *\n   * @param entityOrId Trusted certificate object or trusted certificate fingerprint.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *    const fingerprint: string = 'abc';\n   *\n   *    (async () => {\n   *      const {data, res} = await trustedCertificateService.detail(fingerprint);\n   *   })();\n   * ```\n   */\n  async detail(entityOrId: string | ITrustedCertificate) {\n    return super.detail(entityOrId);\n  }\n\n  /**\n   * Removes a trusted certificate with given fingerprint.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param entityOrId Trusted certificate object or trusted certificate fingerprint.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   const fingerprint: string = 'abc';\n   *\n   *    (async () => {\n   *      const {data, res} = await trustedCertificateService.delete(fingerprint);\n   *   })();\n   * ```\n   */\n  async delete(entityOrId: string | ITrustedCertificate) {\n    return super.delete(entityOrId);\n  }\n\n  /**\n   * Updates trusted certificate data.\n   *\n   * @param entity Trusted certificate partial object.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const certificate: Partial<ITrustedCertificate> = {\n   *    name: 'Name'\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await trustedCertificateService.update(certificate);\n   *  })();\n   * ```\n   */\n  async update(entity: Partial<ITrustedCertificate>) {\n    return super.update(entity);\n  }\n\n  /**\n   * Creates a new trusted certificate.\n   *\n   * @param Trusted certificate object.\n   *\n   * @returns Response wrapped in [[IResult]]\n   *\n   * **Example**\n   * ```typescript\n   *\n   *  const certificate: Partial<ITrustedCertificate> = {\n   *    name: 'Name',\n   *    certInPemFormat: 'MIID+DCCAuCgAwIBAgIJAO1Q9t/M9gYlMA0GC...',\n   *    status: 'ENABLED'\n   *  };\n   *\n   *  (async () => {\n   *    const {data, res} = await trustedCertificateService.create(certificate);\n   *  })();\n   * ```\n   */\n  async create(entity: Partial<ITrustedCertificate>) {\n    return super.create(entity);\n  }\n\n  protected getDetailUrl(entityOrId: string | ITrustedCertificate): string {\n    let id: string | number;\n    if (typeof entityOrId === 'object' && entityOrId.fingerprint) {\n      id = entityOrId.fingerprint;\n    } else {\n      id = entityOrId as string;\n    }\n    return `${this.listUrl}/${id}`;\n  }\n}\n","import FormData from 'form-data';\nimport { Stream } from 'stream';\nimport { Service, IResult, IFetchResponse } from '../core';\nimport { IEvent } from './IEvent';\nimport { IEventBinary } from './IEventBinary';\n\nexport class EventBinaryService extends Service<IEventBinary> {\n  protected baseUrl = 'event';\n  protected listUrl = 'events';\n\n  /**\n   * Uploads an event binary.\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {Stream | Buffer | File | Blob} file file to upload.\n   * @param {string | number | IEvent} eventOrId Event or Id of the Event.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   const file = Buffer.from('aaa');\n   *   const eventId: string | number = 123;\n   *\n   *    (async () => {\n   *      const {data, res} = await eventBinaryService.upload(file, eventId);\n   *   })();\n   * ```\n   */\n  async upload(\n    file: Stream | Buffer | File | Blob,\n    entityOrId: string | number | IEvent\n  ): Promise<IResult<IEventBinary>> {\n    const method = 'POST';\n    const url = this.getDetailUrl(entityOrId);\n    const body = new FormData();\n\n    body.append('file', file);\n    const headers = {\n      accept: 'application/json'\n    };\n    const res = await this.fetch(url, { method, body, headers });\n    const data = await res.json();\n    return { res, data };\n  }\n\n  /**\n   * Downloads the binary for a given event.\n   * @returns Response wrapped in [[IFetchResponse]]\n   *\n   * @param {string | number | IEvent} eventOrId Event or Id of the Event.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   const eventId: string | number = 123;\n   *\n   *    (async () => {\n   *      const res = await eventBinaryService.download(eventId);\n   *   })();\n   */\n  async download(entityOrId: string | number | IEvent): Promise<IFetchResponse> {\n    const url = this.getDetailUrl(entityOrId);\n    return await this.fetch(url);\n  }\n\n  /**\n   * Removes the binary for a given event.\n   * @returns Response wrapped in [[IResult]]\n   *\n   * @param {string | number | IEvent} eventOrId Event or Id of the Event.\n   *\n   * **Example**\n   * ```typescript\n   *\n   *   const eventId: string | number = 123;\n   *\n   *    (async () => {\n   *      const {data, res} = await eventBinaryService.delete(eventId);\n   *   })();\n   * ```\n   */\n  async delete(entityOrId: string | number | IEvent) {\n    return super.delete(entityOrId);\n  }\n\n  protected getDetailUrl(entityOrId: string | number | IEvent): string {\n    let id: string | number;\n    if (typeof entityOrId === 'object' && entityOrId.id) {\n      id = entityOrId.id;\n    } else {\n      id = entityOrId as string;\n    }\n    return `${this.listUrl}/${id}/binaries`;\n  }\n}\n"],"names":["MetaChannel","module","Utils","isString","value","undefined","String","isArray","Array","inArray","element","array","i","length","Transport","_type","_cometd","_url","this","registered","type","cometd","unregistered","_debug","apply","arguments","_mixin","getConfiguration","getAdvice","setTimeout","funktion","delay","clearTimeout","id","convertToMessages","response","JSON","parse","x","Object","accept","version","crossDomain","url","getType","getURL","setURL","send","envelope","metaConnect","reset","init","abort","toString","derive","baseObject","F","prototype","RequestTransport","_super","_self","_requestIds","_metaConnectRequest","_requests","_envelopes","_transportSend","request","transportSend","expired","sync","maxDelay","maxNetworkDelay","timeout","self","errorMessage","failure","reason","xhr","httpCode","xhrStatus","abortXHR","complete","onFailure","messages","_queueSend","requestId","maxConnections","push","call","_complete","success","index","splice","envelopeAndRequest","shift","nextEnvelope","nextRequest","autoBatch","newEnvelope","newRequest","concat","transportSuccess","responses","onSuccess","transportFailure","metaConnectRequest","state","readyState","window","XMLHttpRequest","UNSENT","status","LongPollingTransport","_supportsCrossDomain","newXMLHttpRequest","xhrSend","packet","context","e","_copyContext","withCredentials","open","headers","headerName","hasOwnProperty","setRequestHeader","onload","responseText","onError","statusText","onabort","onerror","body","sameStack","transport","requestHeaders","stringify","received","exception","CallbackPollingTransport","jsonp","_failTransportFn","jsonpSend","head","document","getElementsByTagName","script","createElement","callbackName","removeChild","indexOf","encodeURIComponent","src","async","appendChild","start","lengths","json","slice","urlLength","encodeURI","maxLength","maxURILength","envelopeToSend","begin","end","join","xx","WebSocketTransport","_webSocketSupported","_webSocketConnected","_stickyReconnect","_context","_connecting","_connected","_successCallback","_forceClose","event","webSocketClose","code","onClose","_sameContext","_storeEnvelope","messageIds","message","envelopes","_webSocketSend","webSocket","timeouts","_send","replace","protocol","WebSocket","stickyReconnect","connectTimeout","connectTimer","onclose","onopen","onOpen","_warn","onmessage","wsMessage","onMessage","_notifySuccess","fn","_notifyFailure","key","close","data","test","channel","removed","j","ids","split","websocketCode","websocketEnabled","_z85EncodeTable","_z85DecodeTable","CometD","name","_transport","_handshakeProps","_handshakeCallback","_handleMessages","_handleFailure","_scheduler","_ids","_tasks","register","unregister","_name","_crossDomain","_transports","_types","getTransportTypes","findTransportTypes","result","negotiateTransport","types","add","existing","find","remove","clear","_status","_messageId","_clientId","_batch","_messageQueue","_internalBatch","_listenerId","_listeners","_backoff","_scheduledSend","_extensions","_advice","_callbacks","_remoteCalls","_reestablish","_unconnectTime","_handshakeMessages","_metaConnect","_config","useWorkerScheduler","backoffIncrement","maxBackoff","logLevel","appendMessageTypeToURL","urls","advice","interval","reconnect","maxInterval","_fieldValue","object","_isString","_isFunction","_zeroPad","Math","pow","_log","level","args","console","logger","now","Date","getHours","getMinutes","getSeconds","getMilliseconds","_splitURL","RegExp","exec","_configure","configuration","urlParts","hostAndPort","uri","afterURI","_isCrossDomain","_info","uriSegments","lastSegmentIndex","match","Worker","Blob","URL","cmd","postMessage","substring","lastIndexOf","blob","blobURL","createObjectURL","worker","_removeListener","subscription","subscriptions","listener","_removeSubscription","_clearSubscriptions","_setStatus","newStatus","_isDisconnected","_nextMessageId","_applyExtension","scope","callback","outgoing","handler","onExtensionException","_applyOutgoingExtensions","extension","_notify","onListenerException","_notifyListeners","channelParts","last","channelPart","_cancelDelayedSend","_delayedSend","operation","time","extraPath","messageId","clientId","rcvdMessages","conduit","getTransport","connectionType","_resetBackoff","_flushBatch","_delayedConnect","bayeuxMessage","_connect","_updateAdvice","newAdvice","_disconnect","_notifyTransportException","oldTransport","newTransport","onTransportException","_handshake","handshakeProps","handshakeCallback","transportTypes","minimumVersion","supportedConnectionTypes","_putCallback","_notifyCallback","onCallbackException","_handleCallback","_getCallback","_handleRemoteCall","_handleTransportFailure","failureInfo","action","_delayedHandshake","_failHandshake","onTransportFailure","_handshakeFailure","cause","_matchMetaConnect","connect","_failConnect","_connectFailure","_failDisconnect","_disconnectFailure","_failSubscribe","_subscribeFailure","_failUnsubscribe","_unsubscribeFailure","_failMessage","_messageFailure","_receive","incoming","_applyIncomingExtensions","successful","reestablish","_handshakeResponse","_connectResponse","_disconnectResponse","_subscribeResponse","_unsubscribeResponse","_messageResponse","_hasSubscriptions","_resolveScopedCallback","delegate","method","_addListener","isListener","deep","target","objects","propName","prop","targ","source","location","host","failureHandler","transports","getTransportRegistry","getBackoffPeriod","oldTransportType","newTransportType","increaseBackoffPeriod","getTime","expiration","unconnected","resetBackoffPeriod","receive","failureMessage","registerTransport","unregisterTransport","unregisterTransports","findTransport","configure","handshake","disconnect","disconnectProps","disconnectCallback","startBatch","endBatch","_endBatch","batch","addListener","removeListener","clearListeners","subscribe","subscribeProps","subscribeCallback","unsubscribe","unsubscribeProps","unsubscribeCallback","resubscribe","clearSubscriptions","publish","content","publishProps","publishCallback","publishBinary","meta","ArrayBuffer","ext","binary","remoteCall","callProps","error","remoteCallBinary","getStatus","isDisconnected","setBackoffIncrement","period","getBackoffIncrement","setLogLevel","registerExtension","existingExtension","unregisterExtension","getExtension","getName","getClientId","Z85","encode","bytes","buffer","Uint8Array","byteLength","remainder","padding","view","DataView","isPadding","getUint8","divisor","floor","decode","string","p","charIdx","byteIdx","charCodeAt","setUint8","factory","lib","default","Realtime","[object Object]","client","msg","Error","HANDSHAKE","metaHandshake","checkConnection","getFetchOptions","config","getUrl","getCometdHandshake","Paging","service","statistics","filter","currentPage","nextPage","prevPage","pageSize","totalPages","list","getFilter","page","assign","Service","realtime","Map","getPrototypeOf","forEach","defineProperty","listUrl","res","fetch","changeFetchOptions","params","propertyName","paging","getPaging","entityOrId","getDetailUrl","entity","onBeforeCreate","content-type","onBeforeUpdate","obj","objWithId","options","baseUrl","fullUrl","ex","text","reference","getCurrentPageFromLink","next","prev","link","matches","parseInt","__root__","root","support","searchParams","iterable","Symbol","formData","arrayBuffer","viewClasses","isDataView","isPrototypeOf","isArrayBufferView","isView","Headers","append","normalizeName","normalizeValue","oldValue","map","get","has","set","thisArg","keys","items","iteratorFor","values","entries","iterator","methods","Request","clone","_bodyInit","Body","Response","redirectStatuses","redirect","RangeError","input","Promise","resolve","reject","rawHeaders","getAllResponseHeaders","line","parts","trim","responseURL","TypeError","ontimeout","credentials","responseType","polyfill","toLowerCase","done","header","getOwnPropertyNames","consumed","bodyUsed","fileReaderReady","reader","readBlobAsArrayBuffer","FileReader","promise","readAsArrayBuffer","bufferClone","buf","_initBody","_bodyText","_bodyBlob","FormData","_bodyFormData","URLSearchParams","_bodyArrayBuffer","rejected","then","readAsText","chars","fromCharCode","readArrayBufferAsText","upcased","mode","toUpperCase","referrer","form","decodeURIComponent","bodyInit","ok","exports","auths","WeakMap","FetchClient","authOrBaseUrl","setAuth","resolveServerUrl","auth","fetchFn","paramPart","k","vals","encodedKey","v","defaultHeaders","UseXBasic","startsWith","E","_btoa","btoa","block","charCode","str","output","idx","charAt","p1","utf8","secrets","BasicAuth","updateCredentials","tenant","user","password","token","tfa","secret","xsrfToken","getCookieValue","Authorization","X-XSRF-TOKEN","tfatoken","KEY","cookie","pop","gettext","t","Severity","QueriesUtil","__not","operand","buildQueryFilter","__and","__or","__eq","contextKey","quoteString","__gt","__ge","__lt","__le","__in","stmts","op","glue","__bygroupid","__has","__useFilterQueryString","queryString","query","q","__filter","orderBy","buildQueryOrderby","__orderby","queryFilter","_queryKey","_glueType","queryKey","glueType","qFilter","_q","operatorFns","queryOrderbys","o","addFilter","operator","oldFilter","newFilter","skipEmptyObjects","orderbys","addOrderbys","how","oldOrderbys","newOrderbys","newQuery","isEmptyObject","s","objs","EventService","detail","create","update","delete","InventoryBinaryService","file","managedObject","fileName","fileType","bodyHeaders","File","getHeaders","managedObjectOrId","regexp","ChildType","InventoryService","super","queriesUtil","inventoriesQueryParamName","buildQuery","devicesQueryParamName","parentReference","listChildren","ADDITIONS","createChild","childReference","addChild","ASSETS","addChildBulk","DEVICES","lastUpdated","childId","getIdString","getChildrenUrl","references","ref","pagingFilter","mimeType","childReferenceArray","aggregationType","MeasurementService","sourceId","AlarmStatus","AlarmService","OperationService","OperationBulkStatus","OperationBulkGeneralStatus","OperationStatus","OperationBulkService","operationOrId","TenantStatus","TfaStrategy","TenantService","currentTenantUrl","fetchOptions","tenantData","current","customProperties","tenantType","application","applicationId","UserInventoryRoleService","userUrl","PasswordStrength","UserService","currentUserUrl","totpCurrentUserURL","newsletterEmailsUrl","Accept","email","tenantId","passwordResetUrl","newPassword","pin","verifyTFACodeUrl","verifyTOTPCodeUrl","isActive","activateTOTPCodeUrl","revokeTOTPSecretUrl","phoneNumber","currentUserPhoneUrl","phone","roleId","hasRoleInUser","hasRoleInGroups","roleIds","every","hasRole","some","userName","effectiveRoles","hasRoleInReferences","roles","groups","groupRef","group","role","ApplicationType","ApplicationBinaryService","applicationOrId","createBinaryRequestBody","onProgress","upload","addEventListener","rej","binaryOrId","pluginName","pluginFile","bufferOrStream","Buffer","from","files","contents","path","binaryId","uploadFileName","BillingMode","Isolation","ApplicationAvailability","ApplicationService","tenantOrName","tenantService","tenantName","userOrId","userService","userId","appId","EXTERNAL","externalUrl","public","contextPath","listByUser","dropOverwrittenApps","noPaging","availableApp","isMatch","el","includes","SystemOptionsService","option","category","TenantOptionsService","encodedCategory","securityOptionsCategories","securityOptionsListUrl","TenantSecurityOptionsService","tenantSecurityOption","TenantLoginOptionType","GrantType","UserManagementSource","TenantLoginOptionsService","entityIdentityOrId","management","AuditRecordType","ChangeType","AuditService","DeviceRegistrationStatus","InventoryRoleService","DeviceRegistrationService","bind","ACCEPTED","basicAuth","basicAuthToken","pass","noIdEntity","DeviceRegistrationBulkService","inputFile","csv","checkPattern","UserRoleService","UserGroupService","childEntityOrSelf","ROLES","USERS","userGroupOrId","childSelf","getSelf","getChildUrl","getChildReferenceAsBody","IdentityService","managedObjectId","getExternalIdsOfGlobalIdUrl","identity","getExternalIdUrl","externalId","SmartGroupsService","SMART_GROUPS_V2_MICROSERVICE_BASE_PATH","applicationService","mo","isInstalled","isSmartGroupsV2MicroserviceInstalled","groupMo","withChildren","isSmartGroupV2","updateSmartGroupV2","partialMo","SMART_GROUPS_V2_MICROSERVICE_ENDPOINT_PATH","removeSmartGroupV2","isAvailable","SMART_GROUPS_V2_MICROSERVICE_APP_NAME","hasSmartGroupFragmentType","SMART_GROUP_FRAGMENT_TYPE","isSmartGroupType","SMART_GROUP_TYPE","hasDeviceGroupFragmentType","DEVICE_GROUP_FRAGMENT_TYPE","isGroupOrSubgroup","DEVICE_GROUP_TYPE","DEVICE_SUBGROUP_TYPE","partialUrl","SmartRulesService","contextRulesUrl","rules","rule","entitiesOrIdsList","enabledSources","newEnabledSources","disableEnabledSources","ruleCopy","getSmartRulesUrl","removeUnclonableFields","unupdatableFields","entityOrIdList","getListOfStringIds","contextMoId","c8y_Context","rulesUrl","fieldsToRemove","f","Client","alarm","audit","core","deviceRegistration","deviceRegistrationBulk","inventory","inventoryBinary","inventoryRole","measurement","operationBulk","security","system","login","userGroup","userRole","smartGroups","smartRules","deviceId","expire","clientCore","bootstrap","username","deviceBootstrap","bootstrapCredentials","users","logoutUrl","authTokenFromCookie","authTokenFromHeader","authorization","fingerprint"],"mappings":"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"}