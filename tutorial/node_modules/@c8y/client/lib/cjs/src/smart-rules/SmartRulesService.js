"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartRulesService = void 0;
const Service_1 = require("../core/Service");
class SmartRulesService extends Service_1.Service {
    constructor(client) {
        super(client);
        this.baseUrl = 'service/smartrule';
        this.rulesUrl = 'smartrules';
        this.unupdatableFields = ['type', 'cepModuleId', 'creationTime', 'lastUpdated'];
    }
    /**
     * Gets a list of smart rules for given managed object.
     *
     * @param {IdReference} entityOrId Entity or Id of the ManagedObject.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const id: string = '1';
     *
     *    (async () => {
     *      const {data, res} = await smartRulesService.listByContext(id);
     *   })();
     * ```
     */
    listByContext(entityOrId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.contextRulesUrl(entityOrId);
            const res = yield this.fetch(url, { method: 'GET' });
            const rules = (yield res.json()).rules;
            return { res, data: rules };
        });
    }
    /**
     * Deactivates smart rule for given entities list.
     *
     * @param {Partial<IRule>} rule Smart rule managed object.
     * @param {IdReference[]} entitiesOrIdsList List of entities or Id of the ManagedObjects.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const rule: IRule = {id: '1', enabledSources: ['2', '3'],...};
     *    const entityOrIdList: IdReference[] = ['2'];
     *    (async () => {
     *      const {data, res} = await smartRulesService.bulkDeactivateEnabledSources(rule, entityOrIdList);
     *   })();
     * ```
     */
    bulkDeactivateEnabledSources(rule, entitiesOrIdsList) {
        if (entitiesOrIdsList.length === 0) {
            return Promise.resolve({ res: null, data: null });
        }
        const { enabledSources } = rule;
        const newEnabledSources = this.disableEnabledSources(enabledSources, entitiesOrIdsList);
        const ruleCopy = Object.assign({}, rule);
        Object.assign(ruleCopy, { enabledSources: newEnabledSources });
        return this.update(ruleCopy);
    }
    /**
     * Updates smart rule.
     *
     * @param {Parial<IRule>} rule Smart rule managed object.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const rule: IRule = {id: '1', enabledSources: ['2', '3'],...};
     *    (async () => {
     *      const {data, res} = await smartRulesService.updateSmartRule(rule);
     *   })();
     * ```
     */
    update(rule) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.getSmartRulesUrl(rule);
            const method = 'PUT';
            const body = JSON.stringify(this.removeUnclonableFields(rule, this.unupdatableFields));
            const headers = { 'content-type': 'application/json', accept: 'application/json' };
            const res = yield this.fetch(url, { method, body, headers });
            const data = yield res.json();
            return { res, data };
        });
    }
    disableEnabledSources(enabledSources = [], entityOrIdList) {
        return enabledSources.filter(id => !this.getListOfStringIds(entityOrIdList).includes(id));
    }
    getListOfStringIds(entityOrIdList) {
        return entityOrIdList.map(entityOrId => {
            if (typeof entityOrId === 'object' && entityOrId.id) {
                return entityOrId.id.toString();
            }
            return entityOrId.toString();
        });
    }
    getSmartRulesUrl(rule) {
        const contextMoId = rule && rule.c8y_Context && rule.c8y_Context.id;
        let url = !!contextMoId ? this.contextRulesUrl(contextMoId) : this.rulesUrl;
        if (rule.id) {
            url = `${url}/${rule.id}`;
        }
        return url;
    }
    removeUnclonableFields(rule, fieldsToRemove) {
        const ruleCopy = Object.assign({}, rule);
        fieldsToRemove.forEach(f => {
            delete ruleCopy[f];
        });
        return ruleCopy;
    }
    contextRulesUrl(entityOrId = {}) {
        if (typeof entityOrId === 'object' && entityOrId.id) {
            return `managedObjects/${entityOrId.id}/smartrules`;
        }
        return `managedObjects/${entityOrId}/smartrules`;
    }
}
exports.SmartRulesService = SmartRulesService;
//# sourceMappingURL=SmartRulesService.js.map