import { Component, ContentChild } from '@angular/core';
import { RangeDirective } from './range.directive';
/**
 * An component which renders a range slider in Cumulocity layout. You need
 * to wrap the default range input in this component.
 *
 * Example:
 * ```
 * <c8y-range>
 *   <input id="range" type="range" min="0" max="100000" value="0" step="1">
 * </c8y-range>
 * ```
 */
export class RangeComponent {
    constructor() {
        this.changeEventListener = () => this.setValue();
    }
    ngAfterContentInit() {
        this.setValue();
        this.range.elementRef.nativeElement.addEventListener('input', this.changeEventListener);
    }
    ngOnDestroy() {
        this.range.elementRef.nativeElement.removeEventListener('input', this.changeEventListener);
    }
    setValue() {
        const range = this.range.elementRef.nativeElement;
        const newValue = Number(((range.value - range.min) * 100) / (range.max - range.min));
        const newPosition = 12 - newValue * 0.24;
        this.value = range.value;
        this.left = `calc(${newValue}% + (${newPosition}px))`;
    }
}
RangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-range',
                template: "<div class=\"range-wrap\" style=\"--track-width: {{left}}\">\n  <div class=\"range-value\" [style.left]=\"left\">\n    <span *ngIf=\"!rangeValue\">{{ value }}</span>\n    <ng-container *ngTemplateOutlet=\"rangeValue\"></ng-container>\n  </div>\n  <ng-content></ng-content>\n</div>\n"
            },] }
];
RangeComponent.propDecorators = {
    range: [{ type: ContentChild, args: [RangeDirective, { static: true },] }],
    rangeValue: [{ type: ContentChild, args: ['c8yRangeValue', { static: true },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9mb3Jtcy9yYW5nZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQTBCLE1BQU0sZUFBZSxDQUFDO0FBQ2hGLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUVuRDs7Ozs7Ozs7OztHQVVHO0FBS0gsTUFBTSxPQUFPLGNBQWM7SUFKM0I7UUFhRSx3QkFBbUIsR0FBa0IsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBa0I3RCxDQUFDO0lBaEJDLGtCQUFrQjtRQUNoQixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDaEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQztJQUMxRixDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7SUFDN0YsQ0FBQztJQUVELFFBQVE7UUFDTixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7UUFDbEQsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDckYsTUFBTSxXQUFXLEdBQUcsRUFBRSxHQUFHLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDekMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxJQUFJLEdBQUcsUUFBUSxRQUFRLFFBQVEsV0FBVyxNQUFNLENBQUM7SUFDeEQsQ0FBQzs7O1lBOUJGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsV0FBVztnQkFDckIsc1NBQXFDO2FBQ3RDOzs7b0JBRUUsWUFBWSxTQUFDLGNBQWMsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7eUJBRzdDLFlBQVksU0FBQyxlQUFlLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIE9uRGVzdHJveSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJhbmdlRGlyZWN0aXZlIH0gZnJvbSAnLi9yYW5nZS5kaXJlY3RpdmUnO1xuXG4vKipcbiAqIEFuIGNvbXBvbmVudCB3aGljaCByZW5kZXJzIGEgcmFuZ2Ugc2xpZGVyIGluIEN1bXVsb2NpdHkgbGF5b3V0LiBZb3UgbmVlZFxuICogdG8gd3JhcCB0aGUgZGVmYXVsdCByYW5nZSBpbnB1dCBpbiB0aGlzIGNvbXBvbmVudC5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgXG4gKiA8Yzh5LXJhbmdlPlxuICogICA8aW5wdXQgaWQ9XCJyYW5nZVwiIHR5cGU9XCJyYW5nZVwiIG1pbj1cIjBcIiBtYXg9XCIxMDAwMDBcIiB2YWx1ZT1cIjBcIiBzdGVwPVwiMVwiPlxuICogPC9jOHktcmFuZ2U+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYzh5LXJhbmdlJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3JhbmdlLmNvbXBvbmVudC5odG1sJyxcbn0pXG5leHBvcnQgY2xhc3MgUmFuZ2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBAQ29udGVudENoaWxkKFJhbmdlRGlyZWN0aXZlLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICByYW5nZTogUmFuZ2VEaXJlY3RpdmU7XG5cbiAgQENvbnRlbnRDaGlsZCgnYzh5UmFuZ2VWYWx1ZScsIHsgc3RhdGljOiB0cnVlIH0pXG4gIHJhbmdlVmFsdWU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgbGVmdDogc3RyaW5nO1xuICB2YWx1ZTogc3RyaW5nO1xuICBjaGFuZ2VFdmVudExpc3RlbmVyOiBFdmVudExpc3RlbmVyID0gKCkgPT4gdGhpcy5zZXRWYWx1ZSgpO1xuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLnNldFZhbHVlKCk7XG4gICAgdGhpcy5yYW5nZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmNoYW5nZUV2ZW50TGlzdGVuZXIpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5yYW5nZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmNoYW5nZUV2ZW50TGlzdGVuZXIpO1xuICB9XG5cbiAgc2V0VmFsdWUoKSB7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzLnJhbmdlLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IE51bWJlcigoKHJhbmdlLnZhbHVlIC0gcmFuZ2UubWluKSAqIDEwMCkgLyAocmFuZ2UubWF4IC0gcmFuZ2UubWluKSk7XG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSAxMiAtIG5ld1ZhbHVlICogMC4yNDtcbiAgICB0aGlzLnZhbHVlID0gcmFuZ2UudmFsdWU7XG4gICAgdGhpcy5sZWZ0ID0gYGNhbGMoJHtuZXdWYWx1ZX0lICsgKCR7bmV3UG9zaXRpb259cHgpKWA7XG4gIH1cbn1cbiJdfQ==