import { DatePipe as NgDatePipe } from '@angular/common';
import { Inject, LOCALE_ID, Pipe } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { gettext } from '../i18n/gettext';
/**
 * The range of times supported by ECMAScript Date objects in milliseconds.
 * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.1
 */
export const ES_MAX_TIME_MILLISECONDS = 8640000000000000;
/**
 * Formats a date value according to locale rules. If no other format specified it defaults to `medium`
 * used as standard date/time format.
 *
 * Extends Angular's DatePipe in a way so that date values exceeding the range supported by ECMAScript
 * are displayed as earliest/latest supported point in time printed in the desired format pre- or postfixed
 * by the word `before` or `after`, respectively.
 * In all other cases the pipe behaves as the standard [DatePipe]{@link https://angular.io/api/common/DatePipe}.
 *
 * ```html
 * <span class="highlight">{{ deadline | c8yDate }}</span> <!-- e.g. 7 May 2020, 17:45:19 (en-GB) or 07.05.2020, 17:45:19 (de) -->
 * <span>{{ lastUpdated | c8yDate: 'a h:MM:ss' }}</span> <!-- e.g. pm 5:45:19 -->
 * <span>{{ 8640000000000000 + 1 | c8yDate }}</span> <!-- e.g. after 13 Sep 275760, 03:00:00 --> ```
 */
export class DatePipe extends NgDatePipe {
    constructor(locale, translateService) {
        super(locale);
        this.translateService = translateService;
    }
    transform(value, format = 'medium', timezone, locale) {
        let valueInBounds = value;
        let valueBefore = false;
        let valueBeyond = false;
        if (typeof value === 'number' && !isNaN(value)) {
            valueInBounds = Math.min(value, ES_MAX_TIME_MILLISECONDS);
            valueInBounds = Math.max(valueInBounds, -ES_MAX_TIME_MILLISECONDS);
            valueBefore = value < -ES_MAX_TIME_MILLISECONDS;
            valueBeyond = value > ES_MAX_TIME_MILLISECONDS;
        }
        let result = super.transform(valueInBounds, format, timezone, locale);
        if (valueBefore) {
            result = this.translateService.instant(gettext(`before {{date}}`), { date: result });
        }
        else if (valueBeyond) {
            result = this.translateService.instant(gettext(`after {{date}}`), { date: result });
        }
        return result;
    }
}
DatePipe.decorators = [
    { type: Pipe, args: [{ name: 'c8yDate' },] }
];
DatePipe.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: TranslateService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5waXBlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9jb21tb24vZGF0ZS5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxRQUFRLElBQUksVUFBVSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekQsT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3hELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUUxQzs7O0dBR0c7QUFDSCxNQUFNLENBQUMsTUFBTSx3QkFBd0IsR0FBVyxnQkFBZ0IsQ0FBQztBQUVqRTs7Ozs7Ozs7Ozs7OztHQWFHO0FBRUgsTUFBTSxPQUFPLFFBQVMsU0FBUSxVQUFVO0lBQ3RDLFlBQStCLE1BQWMsRUFBVSxnQkFBa0M7UUFDdkYsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRHVDLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7SUFFekYsQ0FBQztJQUVELFNBQVMsQ0FDUCxLQUFVLEVBQ1YsU0FBaUIsUUFBUSxFQUN6QixRQUFpQixFQUNqQixNQUFlO1FBRWYsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDO1FBQzFCLElBQUksV0FBVyxHQUFZLEtBQUssQ0FBQztRQUNqQyxJQUFJLFdBQVcsR0FBWSxLQUFLLENBQUM7UUFFakMsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDOUMsYUFBYSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLHdCQUF3QixDQUFDLENBQUM7WUFDMUQsYUFBYSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLENBQUMsd0JBQXdCLENBQUMsQ0FBQztZQUVuRSxXQUFXLEdBQUcsS0FBSyxHQUFHLENBQUMsd0JBQXdCLENBQUM7WUFDaEQsV0FBVyxHQUFHLEtBQUssR0FBRyx3QkFBd0IsQ0FBQztTQUNoRDtRQUNELElBQUksTUFBTSxHQUFXLEtBQUssQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFOUUsSUFBSSxXQUFXLEVBQUU7WUFDZixNQUFNLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO1NBQ3RGO2FBQU0sSUFBSSxXQUFXLEVBQUU7WUFDdEIsTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztTQUNyRjtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7OztZQWhDRixJQUFJLFNBQUMsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFOzs7eUNBRVYsTUFBTSxTQUFDLFNBQVM7WUF6QnRCLGdCQUFnQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGVQaXBlIGFzIE5nRGF0ZVBpcGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSW5qZWN0LCBMT0NBTEVfSUQsIFBpcGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcbmltcG9ydCB7IGdldHRleHQgfSBmcm9tICcuLi9pMThuL2dldHRleHQnO1xuXG4vKipcbiAqIFRoZSByYW5nZSBvZiB0aW1lcyBzdXBwb3J0ZWQgYnkgRUNNQVNjcmlwdCBEYXRlIG9iamVjdHMgaW4gbWlsbGlzZWNvbmRzLlxuICogQHNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTUuOS4xLjFcbiAqL1xuZXhwb3J0IGNvbnN0IEVTX01BWF9USU1FX01JTExJU0VDT05EUzogbnVtYmVyID0gODY0MDAwMDAwMDAwMDAwMDtcblxuLyoqXG4gKiBGb3JtYXRzIGEgZGF0ZSB2YWx1ZSBhY2NvcmRpbmcgdG8gbG9jYWxlIHJ1bGVzLiBJZiBubyBvdGhlciBmb3JtYXQgc3BlY2lmaWVkIGl0IGRlZmF1bHRzIHRvIGBtZWRpdW1gXG4gKiB1c2VkIGFzIHN0YW5kYXJkIGRhdGUvdGltZSBmb3JtYXQuXG4gKlxuICogRXh0ZW5kcyBBbmd1bGFyJ3MgRGF0ZVBpcGUgaW4gYSB3YXkgc28gdGhhdCBkYXRlIHZhbHVlcyBleGNlZWRpbmcgdGhlIHJhbmdlIHN1cHBvcnRlZCBieSBFQ01BU2NyaXB0XG4gKiBhcmUgZGlzcGxheWVkIGFzIGVhcmxpZXN0L2xhdGVzdCBzdXBwb3J0ZWQgcG9pbnQgaW4gdGltZSBwcmludGVkIGluIHRoZSBkZXNpcmVkIGZvcm1hdCBwcmUtIG9yIHBvc3RmaXhlZFxuICogYnkgdGhlIHdvcmQgYGJlZm9yZWAgb3IgYGFmdGVyYCwgcmVzcGVjdGl2ZWx5LlxuICogSW4gYWxsIG90aGVyIGNhc2VzIHRoZSBwaXBlIGJlaGF2ZXMgYXMgdGhlIHN0YW5kYXJkIFtEYXRlUGlwZV17QGxpbmsgaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9jb21tb24vRGF0ZVBpcGV9LlxuICpcbiAqIGBgYGh0bWxcbiAqIDxzcGFuIGNsYXNzPVwiaGlnaGxpZ2h0XCI+e3sgZGVhZGxpbmUgfCBjOHlEYXRlIH19PC9zcGFuPiA8IS0tIGUuZy4gNyBNYXkgMjAyMCwgMTc6NDU6MTkgKGVuLUdCKSBvciAwNy4wNS4yMDIwLCAxNzo0NToxOSAoZGUpIC0tPlxuICogPHNwYW4+e3sgbGFzdFVwZGF0ZWQgfCBjOHlEYXRlOiAnYSBoOk1NOnNzJyB9fTwvc3Bhbj4gPCEtLSBlLmcuIHBtIDU6NDU6MTkgLS0+XG4gKiA8c3Bhbj57eyA4NjQwMDAwMDAwMDAwMDAwICsgMSB8IGM4eURhdGUgfX08L3NwYW4+IDwhLS0gZS5nLiBhZnRlciAxMyBTZXAgMjc1NzYwLCAwMzowMDowMCAtLT4gYGBgXG4gKi9cbkBQaXBlKHsgbmFtZTogJ2M4eURhdGUnIH0pXG5leHBvcnQgY2xhc3MgRGF0ZVBpcGUgZXh0ZW5kcyBOZ0RhdGVQaXBlIHtcbiAgY29uc3RydWN0b3IoQEluamVjdChMT0NBTEVfSUQpIGxvY2FsZTogc3RyaW5nLCBwcml2YXRlIHRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0ZVNlcnZpY2UpIHtcbiAgICBzdXBlcihsb2NhbGUpO1xuICB9XG5cbiAgdHJhbnNmb3JtKFxuICAgIHZhbHVlOiBhbnksXG4gICAgZm9ybWF0OiBzdHJpbmcgPSAnbWVkaXVtJyxcbiAgICB0aW1lem9uZT86IHN0cmluZyxcbiAgICBsb2NhbGU/OiBzdHJpbmdcbiAgKTogYW55IHtcbiAgICBsZXQgdmFsdWVJbkJvdW5kcyA9IHZhbHVlO1xuICAgIGxldCB2YWx1ZUJlZm9yZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGxldCB2YWx1ZUJleW9uZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgdmFsdWVJbkJvdW5kcyA9IE1hdGgubWluKHZhbHVlLCBFU19NQVhfVElNRV9NSUxMSVNFQ09ORFMpO1xuICAgICAgdmFsdWVJbkJvdW5kcyA9IE1hdGgubWF4KHZhbHVlSW5Cb3VuZHMsIC1FU19NQVhfVElNRV9NSUxMSVNFQ09ORFMpO1xuXG4gICAgICB2YWx1ZUJlZm9yZSA9IHZhbHVlIDwgLUVTX01BWF9USU1FX01JTExJU0VDT05EUztcbiAgICAgIHZhbHVlQmV5b25kID0gdmFsdWUgPiBFU19NQVhfVElNRV9NSUxMSVNFQ09ORFM7XG4gICAgfVxuICAgIGxldCByZXN1bHQ6IHN0cmluZyA9IHN1cGVyLnRyYW5zZm9ybSh2YWx1ZUluQm91bmRzLCBmb3JtYXQsIHRpbWV6b25lLCBsb2NhbGUpO1xuXG4gICAgaWYgKHZhbHVlQmVmb3JlKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnRyYW5zbGF0ZVNlcnZpY2UuaW5zdGFudChnZXR0ZXh0KGBiZWZvcmUge3tkYXRlfX1gKSwgeyBkYXRlOiByZXN1bHQgfSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZUJleW9uZCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy50cmFuc2xhdGVTZXJ2aWNlLmluc3RhbnQoZ2V0dGV4dChgYWZ0ZXIge3tkYXRlfX1gKSwgeyBkYXRlOiByZXN1bHQgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuIl19