import { DecimalPipe as NgDecimalPipe } from '@angular/common';
import { Inject, LOCALE_ID, Pipe } from '@angular/core';
export const NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
/**
 * Formats a value according to digit options and locale rules.
 * Extends the behavior of Angular's <code>number</code> pipe by
 * providing an option to define if a truncated value should be
 * rounded up or down (with the <code>number</code> pipe the
 * value will be rounded using the "to-nearest" method).
 *
 * ```html
 * <span>{{ 3.45612 | c8yNumber: 'ceil':'1.1-3' }}</span> <!-- 3.457 -->
 * <span>{{ 3.46 | c8yNumber: 'ceil':'1.3-3' }}</span> <!-- 3.460 -->
 * <span>{{ 3.45685 | c8yNumber: 'floor':'1.1-3' }}</span> <!-- 3.456 -->```
 */
export class NumberPipe extends NgDecimalPipe {
    constructor(locale) {
        super(locale);
    }
    /**
     * @param value The value to be formatted.
     * @param round When the value needs to be truncated defines if it will be rounded up (='ceil') or down (='floor')
     * @param digitsInfo Sets digit and decimal representation.
     * @param locale Specifies what locale format rules to use.
     */
    transform(value, round, digitsInfo, locale) {
        if (round) {
            let maxFractionPart = 0;
            if (digitsInfo) {
                const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
                if (parts === null) {
                    throw new Error(`${digitsInfo} is not a valid digit info`);
                }
                maxFractionPart = Number.parseInt(parts[5], 10);
            }
            const multiplicator = Math.pow(10, maxFractionPart);
            value = strToNumber(value);
            value = Math[round](value * multiplicator) / multiplicator;
        }
        return super.transform(value, digitsInfo, locale);
    }
}
NumberPipe.decorators = [
    { type: Pipe, args: [{ name: 'c8yNumber' },] }
];
NumberPipe.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
/**
 * Transforms a string into a number (if needed).
 */
function strToNumber(value) {
    // Convert strings to numbers
    if (typeof value === 'string' && !isNaN(Number(value) - parseFloat(value))) {
        return Number(value);
    }
    if (typeof value !== 'number') {
        throw new Error(`${value} is not a number`);
    }
    return value;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnVtYmVyLnBpcGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL2NvbW1vbi9udW1iZXIucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsV0FBVyxJQUFJLGFBQWEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9ELE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV4RCxNQUFNLENBQUMsTUFBTSxvQkFBb0IsR0FBRyw2QkFBNkIsQ0FBQztBQUVsRTs7Ozs7Ozs7Ozs7R0FXRztBQUVILE1BQU0sT0FBTyxVQUFXLFNBQVEsYUFBYTtJQUMzQyxZQUErQixNQUFjO1FBQzNDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNoQixDQUFDO0lBY0Q7Ozs7O09BS0c7SUFDSCxTQUFTLENBQ1AsS0FBeUMsRUFDekMsS0FBMEMsRUFDMUMsVUFBbUIsRUFDbkIsTUFBZTtRQUVmLElBQUksS0FBSyxFQUFFO1lBQ1QsSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFDO1lBQ3hCLElBQUksVUFBVSxFQUFFO2dCQUNkLE1BQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsb0JBQW9CLENBQUMsQ0FBQztnQkFFckQsSUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFO29CQUNsQixNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsVUFBVSw0QkFBNEIsQ0FBQyxDQUFDO2lCQUM1RDtnQkFDRCxlQUFlLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7YUFDakQ7WUFFRCxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxlQUFlLENBQUMsQ0FBQztZQUVwRCxLQUFLLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzNCLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxHQUFHLGFBQWEsQ0FBQyxHQUFHLGFBQWEsQ0FBQztTQUM1RDtRQUNELE9BQU8sS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3BELENBQUM7OztZQS9DRixJQUFJLFNBQUMsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFOzs7eUNBRVosTUFBTSxTQUFDLFNBQVM7O0FBZ0QvQjs7R0FFRztBQUNILFNBQVMsV0FBVyxDQUFDLEtBQXNCO0lBQ3pDLDZCQUE2QjtJQUM3QixJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDMUUsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDdEI7SUFDRCxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtRQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsS0FBSyxrQkFBa0IsQ0FBQyxDQUFDO0tBQzdDO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVjaW1hbFBpcGUgYXMgTmdEZWNpbWFsUGlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3QsIExPQ0FMRV9JRCwgUGlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5leHBvcnQgY29uc3QgTlVNQkVSX0ZPUk1BVF9SRUdFWFAgPSAvXihcXGQrKT9cXC4oKFxcZCspKC0oXFxkKykpPyk/JC87XG5cbi8qKlxuICogRm9ybWF0cyBhIHZhbHVlIGFjY29yZGluZyB0byBkaWdpdCBvcHRpb25zIGFuZCBsb2NhbGUgcnVsZXMuXG4gKiBFeHRlbmRzIHRoZSBiZWhhdmlvciBvZiBBbmd1bGFyJ3MgPGNvZGU+bnVtYmVyPC9jb2RlPiBwaXBlIGJ5XG4gKiBwcm92aWRpbmcgYW4gb3B0aW9uIHRvIGRlZmluZSBpZiBhIHRydW5jYXRlZCB2YWx1ZSBzaG91bGQgYmVcbiAqIHJvdW5kZWQgdXAgb3IgZG93biAod2l0aCB0aGUgPGNvZGU+bnVtYmVyPC9jb2RlPiBwaXBlIHRoZVxuICogdmFsdWUgd2lsbCBiZSByb3VuZGVkIHVzaW5nIHRoZSBcInRvLW5lYXJlc3RcIiBtZXRob2QpLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxzcGFuPnt7IDMuNDU2MTIgfCBjOHlOdW1iZXI6ICdjZWlsJzonMS4xLTMnIH19PC9zcGFuPiA8IS0tIDMuNDU3IC0tPlxuICogPHNwYW4+e3sgMy40NiB8IGM4eU51bWJlcjogJ2NlaWwnOicxLjMtMycgfX08L3NwYW4+IDwhLS0gMy40NjAgLS0+XG4gKiA8c3Bhbj57eyAzLjQ1Njg1IHwgYzh5TnVtYmVyOiAnZmxvb3InOicxLjEtMycgfX08L3NwYW4+IDwhLS0gMy40NTYgLS0+YGBgXG4gKi9cbkBQaXBlKHsgbmFtZTogJ2M4eU51bWJlcicgfSlcbmV4cG9ydCBjbGFzcyBOdW1iZXJQaXBlIGV4dGVuZHMgTmdEZWNpbWFsUGlwZSB7XG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoTE9DQUxFX0lEKSBsb2NhbGU6IHN0cmluZykge1xuICAgIHN1cGVyKGxvY2FsZSk7XG4gIH1cblxuICB0cmFuc2Zvcm0oXG4gICAgdmFsdWU6IG51bWJlciB8IHN0cmluZyxcbiAgICByb3VuZDogJ2NlaWwnIHwgJ2Zsb29yJyB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgZGlnaXRzSW5mbz86IHN0cmluZyxcbiAgICBsb2NhbGU/OiBzdHJpbmdcbiAgKTogc3RyaW5nIHwgbnVsbDtcbiAgdHJhbnNmb3JtKFxuICAgIHZhbHVlOiBudWxsIHwgdW5kZWZpbmVkLFxuICAgIHJvdW5kOiAnY2VpbCcgfCAnZmxvb3InIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBkaWdpdHNJbmZvPzogc3RyaW5nLFxuICAgIGxvY2FsZT86IHN0cmluZ1xuICApOiBudWxsO1xuICAvKipcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWQuXG4gICAqIEBwYXJhbSByb3VuZCBXaGVuIHRoZSB2YWx1ZSBuZWVkcyB0byBiZSB0cnVuY2F0ZWQgZGVmaW5lcyBpZiBpdCB3aWxsIGJlIHJvdW5kZWQgdXAgKD0nY2VpbCcpIG9yIGRvd24gKD0nZmxvb3InKVxuICAgKiBAcGFyYW0gZGlnaXRzSW5mbyBTZXRzIGRpZ2l0IGFuZCBkZWNpbWFsIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcGFyYW0gbG9jYWxlIFNwZWNpZmllcyB3aGF0IGxvY2FsZSBmb3JtYXQgcnVsZXMgdG8gdXNlLlxuICAgKi9cbiAgdHJhbnNmb3JtKFxuICAgIHZhbHVlOiBudW1iZXIgfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgIHJvdW5kOiAnY2VpbCcgfCAnZmxvb3InIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBkaWdpdHNJbmZvPzogc3RyaW5nLFxuICAgIGxvY2FsZT86IHN0cmluZ1xuICApOiBzdHJpbmcge1xuICAgIGlmIChyb3VuZCkge1xuICAgICAgbGV0IG1heEZyYWN0aW9uUGFydCA9IDA7XG4gICAgICBpZiAoZGlnaXRzSW5mbykge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGRpZ2l0c0luZm8ubWF0Y2goTlVNQkVSX0ZPUk1BVF9SRUdFWFApO1xuXG4gICAgICAgIGlmIChwYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtkaWdpdHNJbmZvfSBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbmZvYCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4RnJhY3Rpb25QYXJ0ID0gTnVtYmVyLnBhcnNlSW50KHBhcnRzWzVdLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG11bHRpcGxpY2F0b3IgPSBNYXRoLnBvdygxMCwgbWF4RnJhY3Rpb25QYXJ0KTtcblxuICAgICAgdmFsdWUgPSBzdHJUb051bWJlcih2YWx1ZSk7XG4gICAgICB2YWx1ZSA9IE1hdGhbcm91bmRdKHZhbHVlICogbXVsdGlwbGljYXRvcikgLyBtdWx0aXBsaWNhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIudHJhbnNmb3JtKHZhbHVlLCBkaWdpdHNJbmZvLCBsb2NhbGUpO1xuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIHN0cmluZyBpbnRvIGEgbnVtYmVyIChpZiBuZWVkZWQpLlxuICovXG5mdW5jdGlvbiBzdHJUb051bWJlcih2YWx1ZTogbnVtYmVyIHwgc3RyaW5nKTogbnVtYmVyIHtcbiAgLy8gQ29udmVydCBzdHJpbmdzIHRvIG51bWJlcnNcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIWlzTmFOKE51bWJlcih2YWx1ZSkgLSBwYXJzZUZsb2F0KHZhbHVlKSkpIHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgbnVtYmVyYCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuIl19