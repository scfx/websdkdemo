import { Component, Input } from '@angular/core';
import { HeaderService } from '../header/header.service';
import { BehaviorSubject } from 'rxjs';
/**
 * The component shows all nodes that have been added to the navigator.
 * In addition, it allows you to add a header and a footer to the navigator.
 *
 * ## Example:
 * ```html
 * <c8y-navigator-outlet [nodes]="navigatorService.items$ | async" [open]="isOpen">
 *   <header class="navigator-slot-top"></header>
 *   <footer class="navigator-slot-bottom"></footer>
 * </c8y-navigator-outlet>
 * ```
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../header/header.service';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from './navigator-node.component';

function NavigatorOutletComponent_nav_0_c8y_navigator_node_display_3_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "c8y-navigator-node-display", 4);
    ɵngcc0.ɵɵlistener("nodeClick", function NavigatorOutletComponent_nav_0_c8y_navigator_node_display_3_Template_c8y_navigator_node_display_nodeClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(2); return ctx_r3.collapseNavigator($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r2 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("node", node_r2)("isRoot", true);
} }
const _c0 = function (a0) { return { open: a0 }; };
function NavigatorOutletComponent_nav_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "nav", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementStart(2, "ul", 2);
    ɵngcc0.ɵɵtemplate(3, NavigatorOutletComponent_nav_0_c8y_navigator_node_display_3_Template, 1, 2, "c8y-navigator-node-display", 3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵprojection(4, 1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c0, ctx_r0.open));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.nodes)("ngForTrackBy", ctx_r0.trackByPathOrLabel);
} }
const _c1 = [[["", 8, "navigator-slot-top"]], [["", 8, "navigator-slot-bottom"]]];
const _c2 = [".navigator-slot-top", ".navigator-slot-bottom"];
export class NavigatorOutletComponent {
    constructor(headerService) {
        this.headerService = headerService;
        /**
         * Determines whether the navigator menu should be open/closed.
         */
        this.open = true;
        /**
         * Determines whether the navigator pane should be rendered.
         */
        this.isShown$ = new BehaviorSubject(false);
    }
    /**
     * @ignore
     */
    ngOnChanges() {
        this.isShown$.next(this.nodes && this.nodes.length > 0);
    }
    /**
     * Closes the navigator menu after clicking an item in the menu, in case of insufficient screen width.
     */
    collapseNavigator(from) {
        if (from === 'link' && !this.headerService.largeWidth) {
            this.headerService.closeNavigator();
        }
    }
    /**
     * @ignore
     */
    trackByPathOrLabel(index, node) {
        return node.path ? node.path : node.label;
    }
}
NavigatorOutletComponent.ɵfac = function NavigatorOutletComponent_Factory(t) { return new (t || NavigatorOutletComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.HeaderService)); };
NavigatorOutletComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NavigatorOutletComponent, selectors: [["c8y-navigator-outlet"], ["c8y-ui-navigator"]], inputs: { open: "open", nodes: "nodes" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c2, decls: 2, vars: 3, consts: [["class", "navigator", 3, "ngClass", 4, "ngIf"], [1, "navigator", 3, "ngClass"], [1, "navigatorContent"], [3, "node", "isRoot", "nodeClick", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "node", "isRoot", "nodeClick"]], template: function NavigatorOutletComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c1);
        ɵngcc0.ɵɵtemplate(0, NavigatorOutletComponent_nav_0_Template, 5, 5, "nav", 0);
        ɵngcc0.ɵɵpipe(1, "async");
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBind1(1, 1, ctx.isShown$));
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgClass, ɵngcc2.NgForOf, ɵngcc3.NavigatorNodeComponent], pipes: [ɵngcc2.AsyncPipe], encapsulation: 2 });
NavigatorOutletComponent.ctorParameters = () => [
    { type: HeaderService }
];
NavigatorOutletComponent.propDecorators = {
    nodes: [{ type: Input }],
    open: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorOutletComponent, [{
        type: Component,
        args: [{
                selector: 'c8y-navigator-outlet, c8y-ui-navigator',
                template: "<nav class=\"navigator\" *ngIf=\"isShown$ | async\" [ngClass]=\"{ open: open }\">\n  <ng-content select=\".navigator-slot-top\"></ng-content>\n  <ul class=\"navigatorContent\">\n    <c8y-navigator-node-display (nodeClick)=\"collapseNavigator($event)\" [node]=\"node\" *ngFor=\"let node of nodes trackBy trackByPathOrLabel\" [isRoot]=\"true\"></c8y-navigator-node-display>\n  </ul>\n  <ng-content select=\".navigator-slot-bottom\"></ng-content>\n</nav>\n"
            }]
    }], function () { return [{ type: ɵngcc1.HeaderService }]; }, { open: [{
            type: Input
        }], nodes: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdG9yLW91dGxldC5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvbmF2aWdhdG9yL25hdmlnYXRvci1vdXRsZXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRWpELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtILE1BQU0sT0FBTyx3QkFBd0I7QUFDckMsSUFhRSxZQUFvQixhQUE0QjtBQUFJLFFBQWhDLGtCQUFhLEdBQWIsYUFBYSxDQUFlO0FBQUMsUUFUakQ7QUFDRjtBQUVBLFdBREs7QUFDTCxRQUFXLFNBQUksR0FBRyxJQUFJLENBQUM7QUFDdkIsUUFBRTtBQUNGO0FBRUEsV0FESztBQUNMLFFBQUUsYUFBUSxHQUE2QixJQUFJLGVBQWUsQ0FBVSxLQUFLLENBQUMsQ0FBQztBQUMzRSxJQUNxRCxDQUFDO0FBQ3RELElBQ0U7QUFDRjtBQUNFLE9BQUc7QUFDTCxJQUFFLFdBQVc7QUFBSyxRQUNkLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDNUQsSUFBRSxDQUFDO0FBQ0gsSUFDRTtBQUNGO0FBQ0UsT0FBRztBQUNMLElBQUUsaUJBQWlCLENBQUMsSUFBa0M7QUFDdEQsUUFBSSxJQUFJLElBQUksS0FBSyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsRUFBRTtBQUMzRCxZQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDMUMsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNILElBQ0U7QUFDRjtBQUNFLE9BQUc7QUFDTCxJQUFFLGtCQUFrQixDQUFDLEtBQUssRUFBRSxJQUFJO0FBQ2hDLFFBQUksT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0FBQzlDLElBQUUsQ0FBQztBQUNIO29EQTFDQyxTQUFTLFNBQUMsa0JBQ1QsUUFBUSxFQUFFLHdDQUF3QyxrQkFDbEQ7K2JBQWdELGNBQ2pEOzs7Ozs7a0pBQ0k7QUFBQztBQUVJLFlBckJELGFBQWE7QUFBRztBQUFHO0FBQ2Qsb0JBc0JYLEtBQUs7QUFBSyxtQkFJVixLQUFLO0FBQUk7Ozs7Ozs7Ozs7O29CQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOYXZpZ2F0b3JOb2RlIH0gZnJvbSAnLi9uYXZpZ2F0b3Itbm9kZSc7XG5pbXBvcnQgeyBIZWFkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vaGVhZGVyL2hlYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgc2hvd3MgYWxsIG5vZGVzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBuYXZpZ2F0b3IuXG4gKiBJbiBhZGRpdGlvbiwgaXQgYWxsb3dzIHlvdSB0byBhZGQgYSBoZWFkZXIgYW5kIGEgZm9vdGVyIHRvIHRoZSBuYXZpZ2F0b3IuXG4gKlxuICogIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxjOHktbmF2aWdhdG9yLW91dGxldCBbbm9kZXNdPVwibmF2aWdhdG9yU2VydmljZS5pdGVtcyQgfCBhc3luY1wiIFtvcGVuXT1cImlzT3BlblwiPlxuICogICA8aGVhZGVyIGNsYXNzPVwibmF2aWdhdG9yLXNsb3QtdG9wXCI+PC9oZWFkZXI+XG4gKiAgIDxmb290ZXIgY2xhc3M9XCJuYXZpZ2F0b3Itc2xvdC1ib3R0b21cIj48L2Zvb3Rlcj5cbiAqIDwvYzh5LW5hdmlnYXRvci1vdXRsZXQ+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYzh5LW5hdmlnYXRvci1vdXRsZXQsIGM4eS11aS1uYXZpZ2F0b3InLFxuICB0ZW1wbGF0ZVVybDogJy4vbmF2aWdhdG9yLW91dGxldC5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgTmF2aWdhdG9yT3V0bGV0Q29tcG9uZW50IHtcbiAgLyoqXG4gICAqIE5hdmlnYXRvciBub2RlcyBsaXN0LlxuICAgKi9cbiAgQElucHV0KCkgbm9kZXM6IE5hdmlnYXRvck5vZGVbXTtcbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0aGUgbmF2aWdhdG9yIG1lbnUgc2hvdWxkIGJlIG9wZW4vY2xvc2VkLlxuICAgKi9cbiAgQElucHV0KCkgb3BlbiA9IHRydWU7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdmlnYXRvciBwYW5lIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICovXG4gIGlzU2hvd24kOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGhlYWRlclNlcnZpY2U6IEhlYWRlclNlcnZpY2UpIHt9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG5nT25DaGFuZ2VzKCk6IHZvaWQge1xuICAgIHRoaXMuaXNTaG93biQubmV4dCh0aGlzLm5vZGVzICYmIHRoaXMubm9kZXMubGVuZ3RoID4gMCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBuYXZpZ2F0b3IgbWVudSBhZnRlciBjbGlja2luZyBhbiBpdGVtIGluIHRoZSBtZW51LCBpbiBjYXNlIG9mIGluc3VmZmljaWVudCBzY3JlZW4gd2lkdGguXG4gICAqL1xuICBjb2xsYXBzZU5hdmlnYXRvcihmcm9tOiAnaWNvbicgfCAnZXhwYW5kZXInIHwgJ2xpbmsnKSB7XG4gICAgaWYgKGZyb20gPT09ICdsaW5rJyAmJiAhdGhpcy5oZWFkZXJTZXJ2aWNlLmxhcmdlV2lkdGgpIHtcbiAgICAgIHRoaXMuaGVhZGVyU2VydmljZS5jbG9zZU5hdmlnYXRvcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICB0cmFja0J5UGF0aE9yTGFiZWwoaW5kZXgsIG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5wYXRoID8gbm9kZS5wYXRoIDogbm9kZS5sYWJlbDtcbiAgfVxufVxuIl19