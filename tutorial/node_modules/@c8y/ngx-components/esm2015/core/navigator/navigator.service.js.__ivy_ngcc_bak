import { Injectable, InjectionToken, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { BehaviorSubject, Subject } from 'rxjs';
import { map, shareReplay } from 'rxjs/operators';
import { fromTriggerOnce, sortByPriority, stateToFactory } from '../common/extension-hooks';
import { StateService } from '../common/state-service.abstract';
import { NavigatorNodeRoot } from './navigator-node-root';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
/**
 * A hook to use for Multi Provider extension.
 */
export const HOOK_NAVIGATOR_NODES = new InjectionToken('NavigatorNodesFactory');
/**
 * A service which defines the navigator.
 */
export class NavigatorService extends StateService {
    constructor(injector, router) {
        super();
        this.injector = injector;
        this.router = router;
        /**
         * Refresh the extension factories subject.
         * @readonly
         */
        this.refreshTrigger = new Subject();
        /**
         * @ignore
         */
        this.state$ = new BehaviorSubject(new Set());
        /**
         * Indicates whether the menu entry associated with the given URL should be expanded.
         */
        this.firstUrl = true;
        /**
         * Additional factories that can be added by plugins.
         */
        this.factories = [];
        const rootNode = new NavigatorNodeRoot();
        this.items$ = fromTriggerOnce(router, this.refreshTrigger, [
            () => this.injector.get(HOOK_NAVIGATOR_NODES, []),
            () => this.factories,
            stateToFactory(this.state$)
        ]).pipe(map((nodes) => {
            const noParent = nodes.filter(node => !node.parent);
            const withParent = nodes.filter(node => node.parent);
            // Based on the sortedNodes array, the nodes are sequentially created.
            // Nodes sorting is done in two steps to have the top-level nodes first.
            // This way, by the time we are adding a child node, the parent node is already present.
            const sortedNodes = sortByPriority(noParent).concat(sortByPriority(withParent));
            rootNode.empty();
            sortedNodes.forEach(node => rootNode.addRoot(node));
            return rootNode.children;
        }), shareReplay(1));
    }
    /**
     * Checks whenever a navigator entry associated with the given URL should be expanded.
     * @param {NavigatorNode} node Navigator node.
     */
    openOnFirstUrl(node) {
        if (this.firstUrl && !!node.path) {
            return (this.router.isActive(node.path, node.routerLinkExact) || node.openOnStart(this.router.url));
        }
        return false;
    }
    /**
     * Returns the current state.
     * @readonly
     * @returns The current set of actions.
     */
    get state() {
        return this.state$.value;
    }
    /**
     * Refresh the extension factories.
     */
    refresh() {
        this.refreshTrigger.next(1);
    }
    /**
     * Adds a new node to the navigator.
     * @param {NavigatorNode} node Navigator node to add.
     */
    add(node) {
        this.state.add(node);
        this.emitNewState();
    }
    /**
     * Removes a node from the navigator.
     * @param {NavigatorNode} node Navigator node to remove.
     */
    remove(node) {
        this.state.delete(node);
        this.emitNewState();
    }
}
NavigatorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function NavigatorService_Factory() { return new NavigatorService(i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.Router)); }, token: NavigatorService, providedIn: "root" });
NavigatorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
NavigatorService.ctorParameters = () => [
    { type: Injector },
    { type: Router }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdG9yLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL25hdmlnYXRvci9uYXZpZ2F0b3Iuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFBRSxlQUFlLEVBQWMsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzVELE9BQU8sRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEQsT0FBTyxFQUdMLGVBQWUsRUFDZixjQUFjLEVBQ2QsY0FBYyxFQUNmLE1BQU0sMkJBQTJCLENBQUM7QUFDbkMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBR2hFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDOzs7QUFzQjFEOztHQUVHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sb0JBQW9CLEdBQUcsSUFBSSxjQUFjLENBQ3BELHVCQUF1QixDQUN4QixDQUFDO0FBRUY7O0dBRUc7QUFJSCxNQUFNLE9BQU8sZ0JBQWlCLFNBQVEsWUFBWTtJQTJCaEQsWUFBb0IsUUFBa0IsRUFBVSxNQUFjO1FBQzVELEtBQUssRUFBRSxDQUFDO1FBRFUsYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUFVLFdBQU0sR0FBTixNQUFNLENBQVE7UUFyQjlEOzs7V0FHRztRQUNNLG1CQUFjLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUV4Qzs7V0FFRztRQUNNLFdBQU0sR0FBRyxJQUFJLGVBQWUsQ0FBcUIsSUFBSSxHQUFHLEVBQWlCLENBQUMsQ0FBQztRQUVwRjs7V0FFRztRQUNILGFBQVEsR0FBRyxJQUFJLENBQUM7UUFFaEI7O1dBRUc7UUFDSCxjQUFTLEdBQXlCLEVBQUUsQ0FBQztRQUluQyxNQUFNLFFBQVEsR0FBRyxJQUFJLGlCQUFpQixFQUFFLENBQUM7UUFDekMsSUFBSSxDQUFDLE1BQU0sR0FBRyxlQUFlLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDekQsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsb0JBQW9CLEVBQUUsRUFBRSxDQUFDO1lBQ2pELEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTO1lBQ3BCLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQzVCLENBQUMsQ0FBQyxJQUFJLENBQ0wsR0FBRyxDQUFDLENBQUMsS0FBbUMsRUFBRSxFQUFFO1lBQzFDLE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNwRCxNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRXJELHNFQUFzRTtZQUN0RSx3RUFBd0U7WUFDeEUsd0ZBQXdGO1lBQ3hGLE1BQU0sV0FBVyxHQUFHLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDaEYsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2pCLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDcEQsT0FBTyxRQUFRLENBQUMsUUFBUSxDQUFDO1FBQzNCLENBQUMsQ0FBQyxFQUNGLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FDZixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7T0FHRztJQUNILGNBQWMsQ0FBQyxJQUFtQjtRQUNoQyxJQUFJLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDaEMsT0FBTyxDQUNMLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FDM0YsQ0FBQztTQUNIO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQUksS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDM0IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsT0FBTztRQUNMLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxHQUFHLENBQUMsSUFBbUI7UUFDckIsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLENBQUMsSUFBbUI7UUFDeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3RCLENBQUM7Ozs7WUFuR0YsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUFoRG9DLFFBQVE7WUFDcEMsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCBzaGFyZVJlcGxheSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7XG4gIEV4dGVuc2lvbkZhY3RvcnksXG4gIEV4dGVuc2lvblBvaW50LFxuICBmcm9tVHJpZ2dlck9uY2UsXG4gIHNvcnRCeVByaW9yaXR5LFxuICBzdGF0ZVRvRmFjdG9yeVxufSBmcm9tICcuLi9jb21tb24vZXh0ZW5zaW9uLWhvb2tzJztcbmltcG9ydCB7IFN0YXRlU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9zdGF0ZS1zZXJ2aWNlLmFic3RyYWN0JztcbmltcG9ydCB7IE5hdmlnYXRvck5vZGUgfSBmcm9tICcuL25hdmlnYXRvci1ub2RlJztcbmltcG9ydCB7IE5hdmlnYXRvck5vZGVEYXRhIH0gZnJvbSAnLi9uYXZpZ2F0b3Itbm9kZS1kYXRhJztcbmltcG9ydCB7IE5hdmlnYXRvck5vZGVSb290IH0gZnJvbSAnLi9uYXZpZ2F0b3Itbm9kZS1yb290JztcblxuLyoqXG4gKiBBbiBleHRlbnNpb24gSE9PSyBjYW4gdXNlIGVpdGhlciBhIHB1cmUgdmFsdWU6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgeyBwcm92aWRlOiBIT09LX1gsIHVzZVZhbHVlOiB7IC4uLmhvb2tWYWx1ZSB9LCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqXG4gKiBPciBhbiBhcnJheSB0byBkaXJlY3RseSByZWdpc3RlciBtdWx0aXBsZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICB7IHByb3ZpZGU6IEhPT0tfWCwgdXNlVmFsdWU6IFt7IC4uLmhvb2tWYWx1ZXMgfV0sIG11bHRpOiB0cnVlIH1cbiAqIGBgYFxuICpcbiAqIE9yIGFuIEV4dGVuc2lvbkZhY3Rvcnkgd2hpY2ggYWxsb3dzIHRvIGRlZmluZSBhIGdldCgpIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBnZXRzIGNhbGxlZCBvbiBlYWNoIG5hdmlnYXRpb24gd2l0aCB0aGUgY3VycmVudCByb3V0ZSBhbmQgY2FuIHJldHVybiB2YWx1ZXNcbiAqIGFzeW5jIChvYnNlcnZhYmxlIG9yIHByb21pc2UpLlxuICogYGBgdHlwZXNjcmlwdFxuICogIHsgcHJvdmlkZTogSE9PS19YLCB1c2VGYWN0b3J5OiB7IGdldDogKHJvdXRlKSA9PiBkb1NvbWV0aGluZ0FzeW5jKHJvdXRlKSB9LCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqL1xudHlwZSBOYXZpZ2F0b3JFeHRlbnNpb24gPSBOYXZpZ2F0b3JOb2RlIHwgTmF2aWdhdG9yTm9kZVtdIHwgRXh0ZW5zaW9uRmFjdG9yeTxOYXZpZ2F0b3JOb2RlPjtcblxuLyoqXG4gKiBBIGhvb2sgdG8gdXNlIGZvciBNdWx0aSBQcm92aWRlciBleHRlbnNpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBIT09LX05BVklHQVRPUl9OT0RFUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxOYXZpZ2F0b3JFeHRlbnNpb25bXT4oXG4gICdOYXZpZ2F0b3JOb2Rlc0ZhY3RvcnknXG4pO1xuXG4vKipcbiAqIEEgc2VydmljZSB3aGljaCBkZWZpbmVzIHRoZSBuYXZpZ2F0b3IuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRvclNlcnZpY2UgZXh0ZW5kcyBTdGF0ZVNlcnZpY2UgaW1wbGVtZW50cyBFeHRlbnNpb25Qb2ludDxOYXZpZ2F0b3JFeHRlbnNpb24+IHtcbiAgLyoqXG4gICAqIE5hdmlnYXRvciBtZW51IGl0ZW1zIG9ic2VydmFibGUuIEl0IGVtaXRzIHRoZSBjdXJyZW50IGxpc3Qgb2Ygbm9kZXMgaW4gdGhlIG5hdmlnYXRvci5cbiAgICovXG4gIGl0ZW1zJDogT2JzZXJ2YWJsZTxOYXZpZ2F0b3JOb2RlW10+O1xuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSBleHRlbnNpb24gZmFjdG9yaWVzIHN1YmplY3QuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgcmVhZG9ubHkgcmVmcmVzaFRyaWdnZXIgPSBuZXcgU3ViamVjdCgpO1xuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICByZWFkb25seSBzdGF0ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFNldDxOYXZpZ2F0b3JOb2RlPj4obmV3IFNldDxOYXZpZ2F0b3JOb2RlPigpKTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1lbnUgZW50cnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBVUkwgc2hvdWxkIGJlIGV4cGFuZGVkLlxuICAgKi9cbiAgZmlyc3RVcmwgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIGZhY3RvcmllcyB0aGF0IGNhbiBiZSBhZGRlZCBieSBwbHVnaW5zLlxuICAgKi9cbiAgZmFjdG9yaWVzOiBOYXZpZ2F0b3JFeHRlbnNpb25bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLCBwcml2YXRlIHJvdXRlcjogUm91dGVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCByb290Tm9kZSA9IG5ldyBOYXZpZ2F0b3JOb2RlUm9vdCgpO1xuICAgIHRoaXMuaXRlbXMkID0gZnJvbVRyaWdnZXJPbmNlKHJvdXRlciwgdGhpcy5yZWZyZXNoVHJpZ2dlciwgW1xuICAgICAgKCkgPT4gdGhpcy5pbmplY3Rvci5nZXQoSE9PS19OQVZJR0FUT1JfTk9ERVMsIFtdKSxcbiAgICAgICgpID0+IHRoaXMuZmFjdG9yaWVzLFxuICAgICAgc3RhdGVUb0ZhY3RvcnkodGhpcy5zdGF0ZSQpXG4gICAgXSkucGlwZShcbiAgICAgIG1hcCgobm9kZXM6IFBhcnRpYWw8TmF2aWdhdG9yTm9kZURhdGFbXT4pID0+IHtcbiAgICAgICAgY29uc3Qgbm9QYXJlbnQgPSBub2Rlcy5maWx0ZXIobm9kZSA9PiAhbm9kZS5wYXJlbnQpO1xuICAgICAgICBjb25zdCB3aXRoUGFyZW50ID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5wYXJlbnQpO1xuXG4gICAgICAgIC8vIEJhc2VkIG9uIHRoZSBzb3J0ZWROb2RlcyBhcnJheSwgdGhlIG5vZGVzIGFyZSBzZXF1ZW50aWFsbHkgY3JlYXRlZC5cbiAgICAgICAgLy8gTm9kZXMgc29ydGluZyBpcyBkb25lIGluIHR3byBzdGVwcyB0byBoYXZlIHRoZSB0b3AtbGV2ZWwgbm9kZXMgZmlyc3QuXG4gICAgICAgIC8vIFRoaXMgd2F5LCBieSB0aGUgdGltZSB3ZSBhcmUgYWRkaW5nIGEgY2hpbGQgbm9kZSwgdGhlIHBhcmVudCBub2RlIGlzIGFscmVhZHkgcHJlc2VudC5cbiAgICAgICAgY29uc3Qgc29ydGVkTm9kZXMgPSBzb3J0QnlQcmlvcml0eShub1BhcmVudCkuY29uY2F0KHNvcnRCeVByaW9yaXR5KHdpdGhQYXJlbnQpKTtcbiAgICAgICAgcm9vdE5vZGUuZW1wdHkoKTtcbiAgICAgICAgc29ydGVkTm9kZXMuZm9yRWFjaChub2RlID0+IHJvb3ROb2RlLmFkZFJvb3Qobm9kZSkpO1xuICAgICAgICByZXR1cm4gcm9vdE5vZGUuY2hpbGRyZW47XG4gICAgICB9KSxcbiAgICAgIHNoYXJlUmVwbGF5KDEpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hlbmV2ZXIgYSBuYXZpZ2F0b3IgZW50cnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBVUkwgc2hvdWxkIGJlIGV4cGFuZGVkLlxuICAgKiBAcGFyYW0ge05hdmlnYXRvck5vZGV9IG5vZGUgTmF2aWdhdG9yIG5vZGUuXG4gICAqL1xuICBvcGVuT25GaXJzdFVybChub2RlOiBOYXZpZ2F0b3JOb2RlKSB7XG4gICAgaWYgKHRoaXMuZmlyc3RVcmwgJiYgISFub2RlLnBhdGgpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMucm91dGVyLmlzQWN0aXZlKG5vZGUucGF0aCwgbm9kZS5yb3V0ZXJMaW5rRXhhY3QpIHx8IG5vZGUub3Blbk9uU3RhcnQodGhpcy5yb3V0ZXIudXJsKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqIEByZWFkb25seVxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzZXQgb2YgYWN0aW9ucy5cbiAgICovXG4gIGdldCBzdGF0ZSgpOiBTZXQ8TmF2aWdhdG9yTm9kZT4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlJC52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSBleHRlbnNpb24gZmFjdG9yaWVzLlxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLnJlZnJlc2hUcmlnZ2VyLm5leHQoMSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBub2RlIHRvIHRoZSBuYXZpZ2F0b3IuXG4gICAqIEBwYXJhbSB7TmF2aWdhdG9yTm9kZX0gbm9kZSBOYXZpZ2F0b3Igbm9kZSB0byBhZGQuXG4gICAqL1xuICBhZGQobm9kZTogTmF2aWdhdG9yTm9kZSkge1xuICAgIHRoaXMuc3RhdGUuYWRkKG5vZGUpO1xuICAgIHRoaXMuZW1pdE5ld1N0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGUgbmF2aWdhdG9yLlxuICAgKiBAcGFyYW0ge05hdmlnYXRvck5vZGV9IG5vZGUgTmF2aWdhdG9yIG5vZGUgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlKG5vZGU6IE5hdmlnYXRvck5vZGUpIHtcbiAgICB0aGlzLnN0YXRlLmRlbGV0ZShub2RlKTtcbiAgICB0aGlzLmVtaXROZXdTdGF0ZSgpO1xuICB9XG59XG4iXX0=