import { Injectable, Inject } from '@angular/core';
import { mapValues, each } from 'lodash-es';
import { HOOK_PATTERN_MESSAGES } from './patterns-message.hook';
import { formatDate } from '@angular/common';
import * as i0 from "@angular/core";
import * as i1 from "./patterns-message.hook";
/**
 * A service to translate messages by using regexp patterns.
 */
export class PatternMessagesService {
    constructor(patterns) {
        this.patterns = {};
        this.pipes = {
            absoluteDate: (date) => formatDate(date, 'medium', this.translateService.currentLang),
            translate: (key) => this.translateService.instant(key)
        };
        each(patterns, (pattern) => {
            Object.assign(this.patterns, pattern);
        });
    }
    translate(message) {
        const translation = this.translateWithPatterns(message);
        return (translation !== message) ? translation : '';
    }
    translateWithPatterns(message, patterns = this.patterns) {
        let translatedMessage = message;
        each(patterns, (patternCfg, pattern) => {
            const globalRegExp = new RegExp(pattern, 'g');
            let globalMatch;
            if (!globalRegExp.test(translatedMessage)) {
                return;
            }
            globalRegExp.test(''); // reset the regexp
            globalMatch = globalRegExp.exec(translatedMessage);
            while (globalMatch !== null) {
                const [localMatch] = globalMatch;
                const placeholderValues = mapValues(patternCfg.placeholders, (placeholder) => {
                    const expr = placeholder.capture || placeholder;
                    let replacement = localMatch.replace(new RegExp(pattern, 'g'), expr);
                    if (placeholder.translate) {
                        replacement = this.translateWithPatterns(replacement, placeholder.translate);
                    }
                    return replacement;
                });
                translatedMessage = translatedMessage.replace(localMatch, this.translateWithParams(patternCfg, placeholderValues));
                globalMatch = globalRegExp.exec(translatedMessage);
            }
        });
        return translatedMessage;
    }
    translateWithParams(patternCfg, params = {}) {
        const { defaultLang, currentLang, compiler } = this.translateService;
        const translations = this.translateService.store.translations[currentLang];
        const defaultTranslations = this.translateService.store.translations[defaultLang];
        const originalKey = patternCfg.gettext;
        let originalValue = originalKey;
        if (translations) {
            if (translations[originalKey]) {
                originalValue = translations[originalKey];
            }
            else if (defaultTranslations) {
                if (defaultTranslations[originalKey]) {
                    originalValue = defaultTranslations[originalKey];
                }
            }
        }
        let key = originalKey;
        let value = originalValue;
        const interpolateParams = Object.assign(Object.assign({}, params), { noPatternMessages: true });
        let match;
        const pipeRegex = RegExp('{{\\s*([^\\s]+)\\s*\\|\\s*([^\\s]+)\\s*}}', 'g');
        // tslint:disable-next-line:no-conditional-assignment
        while ((match = pipeRegex.exec(originalKey)) !== null) {
            const [placeholder, paramName, pipeName] = match;
            if (this.pipes[pipeName]) {
                key = key.replace(placeholder, `{{${paramName}}}`);
                value = value.replace(placeholder, `{{${paramName}}}`);
                interpolateParams[paramName] = this.pipes[pipeName](params[paramName]);
            }
        }
        if (translations) {
            translations[key] = compiler.compile(value, currentLang);
        }
        return this.translateService.instant(key, interpolateParams);
    }
}
PatternMessagesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PatternMessagesService_Factory() { return new PatternMessagesService(i0.ɵɵinject(i1.HOOK_PATTERN_MESSAGES)); }, token: PatternMessagesService, providedIn: "root" });
PatternMessagesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PatternMessagesService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [HOOK_PATTERN_MESSAGES,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGF0dGVybi1tZXNzYWdlcy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9pMThuL3BhdHRlcm4tbWVzc2FnZXMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVuRCxPQUFPLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUM1QyxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0saUJBQWlCLENBQUM7OztBQUU3Qzs7R0FFRztBQUlILE1BQU0sT0FBTyxzQkFBc0I7SUFVakMsWUFDaUMsUUFBUTtRQVR6QyxhQUFRLEdBQVEsRUFBRSxDQUFDO1FBQ25CLFVBQUssR0FBRztZQUNOLFlBQVksRUFBRSxDQUFDLElBQXdCLEVBQUUsRUFBRSxDQUN6QyxVQUFVLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDO1lBQy9ELFNBQVMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQ2pCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO1NBQ3JDLENBQUM7UUFLQSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUU7WUFDekIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3hDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELFNBQVMsQ0FBQyxPQUFlO1FBQ3ZCLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN4RCxPQUFPLENBQUMsV0FBVyxLQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FB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QUM7UUFFRixJQUFJLEtBQUssQ0FBQztRQUNWLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQywyQ0FBMkMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUMzRSxxREFBcUQ7UUFDckQsT0FBTyxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssSUFBSSxFQUFFO1lBQ3JELE1BQU0sQ0FBQyxXQUFXLEVBQUUsU0FBUyxFQUFFLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQztZQUNqRCxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQ3hCLEdBQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxLQUFLLFNBQVMsSUFBSSxDQUFDLENBQUM7Z0JBQ25ELEtBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxLQUFLLFNBQVMsSUFBSSxDQUFDLENBQUM7Z0JBQ3ZELGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7YUFDeEU7U0FDRjtRQUVELElBQUksWUFBWSxFQUFFO1lBQ2hCLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztTQUMxRDtRQUNELE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztJQUMvRCxDQUFDOzs7O1lBdEdGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7OzRDQVlJLE1BQU0sU0FBQyxxQkFBcUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcbmltcG9ydCB7IG1hcFZhbHVlcywgZWFjaCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBIT09LX1BBVFRFUk5fTUVTU0FHRVMgfSBmcm9tICcuL3BhdHRlcm5zLW1lc3NhZ2UuaG9vayc7XG5pbXBvcnQgeyBmb3JtYXREYXRlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBBIHNlcnZpY2UgdG8gdHJhbnNsYXRlIG1lc3NhZ2VzIGJ5IHVzaW5nIHJlZ2V4cCBwYXR0ZXJucy5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgUGF0dGVybk1lc3NhZ2VzU2VydmljZSB7XG4gIHRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0ZVNlcnZpY2U7XG4gIHBhdHRlcm5zOiBhbnkgPSB7fTtcbiAgcGlwZXMgPSB7XG4gICAgYWJzb2x1dGVEYXRlOiAoZGF0ZTogc3RyaW5nfG51bWJlcnxEYXRlKSA9PlxuICAgICAgZm9ybWF0RGF0ZShkYXRlLCAnbWVkaXVtJywgdGhpcy50cmFuc2xhdGVTZXJ2aWNlLmN1cnJlbnRMYW5nKSxcbiAgICB0cmFuc2xhdGU6IChrZXkpID0+XG4gICAgICB0aGlzLnRyYW5zbGF0ZVNlcnZpY2UuaW5zdGFudChrZXkpXG4gIH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChIT09LX1BBVFRFUk5fTUVTU0FHRVMpIHBhdHRlcm5zXG4gICkge1xuICAgIGVhY2gocGF0dGVybnMsIChwYXR0ZXJuKSA9PiB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMucGF0dGVybnMsIHBhdHRlcm4pO1xuICAgIH0pO1xuICB9XG5cbiAgdHJhbnNsYXRlKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIGNvbnN0IHRyYW5zbGF0aW9uID0gdGhpcy50cmFuc2xhdGVXaXRoUGF0dGVybnMobWVzc2FnZSk7XG4gICAgcmV0dXJuICh0cmFuc2xhdGlvbiAhPT0gbWVzc2FnZSkgPyB0cmFuc2xhdGlvbiA6ICcnO1xuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc2xhdGVXaXRoUGF0dGVybnMobWVzc2FnZSwgcGF0dGVybnMgPSB0aGlzLnBhdHRlcm5zKSB7XG4gICAgbGV0IHRyYW5zbGF0ZWRNZXNzYWdlID0gbWVzc2FnZTtcblxuICAgIGVhY2gocGF0dGVybnMsIChwYXR0ZXJuQ2ZnLCBwYXR0ZXJuKSA9PiB7XG4gICAgICBjb25zdCBnbG9iYWxSZWdFeHAgPSBuZXcgUmVnRXhwKHBhdHRlcm4sICdnJyk7XG4gICAgICBsZXQgZ2xvYmFsTWF0Y2g7XG5cbiAgICAgIGlmICghZ2xvYmFsUmVnRXhwLnRlc3QodHJhbnNsYXRlZE1lc3NhZ2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGdsb2JhbFJlZ0V4cC50ZXN0KCcnKTsgLy8gcmVzZXQgdGhlIHJlZ2V4cFxuICAgICAgZ2xvYmFsTWF0Y2ggPSBnbG9iYWxSZWdFeHAuZXhlYyh0cmFuc2xhdGVkTWVzc2FnZSk7XG4gICAgICB3aGlsZSAoZ2xvYmFsTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgWyBsb2NhbE1hdGNoIF0gPSBnbG9iYWxNYXRjaDtcblxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlclZhbHVlcyA9IG1hcFZhbHVlcyhwYXR0ZXJuQ2ZnLnBsYWNlaG9sZGVycywgKHBsYWNlaG9sZGVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhwciA9IHBsYWNlaG9sZGVyLmNhcHR1cmUgfHwgcGxhY2Vob2xkZXI7XG4gICAgICAgICAgbGV0IHJlcGxhY2VtZW50ID0gbG9jYWxNYXRjaC5yZXBsYWNlKG5ldyBSZWdFeHAocGF0dGVybiwgJ2cnKSwgZXhwcik7XG5cbiAgICAgICAgICBpZiAocGxhY2Vob2xkZXIudHJhbnNsYXRlKSB7XG4gICAgICAgICAgICByZXBsYWNlbWVudCA9IHRoaXMudHJhbnNsYXRlV2l0aFBhdHRlcm5zKHJlcGxhY2VtZW50LCBwbGFjZWhvbGRlci50cmFuc2xhdGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zbGF0ZWRNZXNzYWdlID0gdHJhbnNsYXRlZE1lc3NhZ2UucmVwbGFjZShcbiAgICAgICAgICBsb2NhbE1hdGNoLFxuICAgICAgICAgIHRoaXMudHJhbnNsYXRlV2l0aFBhcmFtcyhwYXR0ZXJuQ2ZnLCBwbGFjZWhvbGRlclZhbHVlcylcbiAgICAgICAgKTtcblxuICAgICAgICBnbG9iYWxNYXRjaCA9IGdsb2JhbFJlZ0V4cC5leGVjKHRyYW5zbGF0ZWRNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHJhbnNsYXRlZE1lc3NhZ2U7XG4gIH1cblxuICBwcml2YXRlIHRyYW5zbGF0ZVdpdGhQYXJhbXMocGF0dGVybkNmZzogYW55LCBwYXJhbXM6IGFueSA9IHt9KSB7XG4gICAgY29uc3QgeyBkZWZhdWx0TGFuZywgY3VycmVudExhbmcsIGNvbXBpbGVyIH0gPSB0aGlzLnRyYW5zbGF0ZVNlcnZpY2U7XG4gICAgY29uc3QgdHJhbnNsYXRpb25zID0gdGhpcy50cmFuc2xhdGVTZXJ2aWNlLnN0b3JlLnRyYW5zbGF0aW9uc1tjdXJyZW50TGFuZ107XG4gICAgY29uc3QgZGVmYXVsdFRyYW5zbGF0aW9ucyA9IHRoaXMudHJhbnNsYXRlU2VydmljZS5zdG9yZS50cmFuc2xhdGlvbnNbZGVmYXVsdExhbmddO1xuICAgIGNvbnN0IG9yaWdpbmFsS2V5ID0gcGF0dGVybkNmZy5nZXR0ZXh0O1xuXG4gICAgbGV0IG9yaWdpbmFsVmFsdWUgPSBvcmlnaW5hbEtleTtcbiAgICBpZiAodHJhbnNsYXRpb25zKSB7XG4gICAgICBpZiAodHJhbnNsYXRpb25zW29yaWdpbmFsS2V5XSkge1xuICAgICAgICBvcmlnaW5hbFZhbHVlID0gdHJhbnNsYXRpb25zW29yaWdpbmFsS2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdFRyYW5zbGF0aW9ucykge1xuICAgICAgICBpZiAoZGVmYXVsdFRyYW5zbGF0aW9uc1tvcmlnaW5hbEtleV0pIHtcbiAgICAgICAgICBvcmlnaW5hbFZhbHVlID0gZGVmYXVsdFRyYW5zbGF0aW9uc1tvcmlnaW5hbEtleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQga2V5ID0gb3JpZ2luYWxLZXk7XG4gICAgbGV0IHZhbHVlID0gb3JpZ2luYWxWYWx1ZTtcbiAgICBjb25zdCBpbnRlcnBvbGF0ZVBhcmFtcyA9IHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5vUGF0dGVybk1lc3NhZ2VzOiB0cnVlXG4gICAgfTtcblxuICAgIGxldCBtYXRjaDtcbiAgICBjb25zdCBwaXBlUmVnZXggPSBSZWdFeHAoJ3t7XFxcXHMqKFteXFxcXHNdKylcXFxccypcXFxcfFxcXFxzKihbXlxcXFxzXSspXFxcXHMqfX0nLCAnZycpO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25kaXRpb25hbC1hc3NpZ25tZW50XG4gICAgd2hpbGUgKChtYXRjaCA9IHBpcGVSZWdleC5leGVjKG9yaWdpbmFsS2V5KSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IFtwbGFjZWhvbGRlciwgcGFyYW1OYW1lLCBwaXBlTmFtZV0gPSBtYXRjaDtcbiAgICAgIGlmICh0aGlzLnBpcGVzW3BpcGVOYW1lXSkge1xuICAgICAgICBrZXkgPSBrZXkucmVwbGFjZShwbGFjZWhvbGRlciwgYHt7JHtwYXJhbU5hbWV9fX1gKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHBsYWNlaG9sZGVyLCBge3ske3BhcmFtTmFtZX19fWApO1xuICAgICAgICBpbnRlcnBvbGF0ZVBhcmFtc1twYXJhbU5hbWVdID0gdGhpcy5waXBlc1twaXBlTmFtZV0ocGFyYW1zW3BhcmFtTmFtZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0cmFuc2xhdGlvbnMpIHtcbiAgICAgIHRyYW5zbGF0aW9uc1trZXldID0gY29tcGlsZXIuY29tcGlsZSh2YWx1ZSwgY3VycmVudExhbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVTZXJ2aWNlLmluc3RhbnQoa2V5LCBpbnRlcnBvbGF0ZVBhcmFtcyk7XG4gIH1cbn1cbiJdfQ==