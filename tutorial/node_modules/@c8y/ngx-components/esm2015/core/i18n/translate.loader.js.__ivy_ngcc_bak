import { HttpClient } from '@angular/common/http';
import { of } from 'rxjs';
import { map, catchError, tap } from 'rxjs/operators';
import { Inject, Injectable } from '@angular/core';
import { LOCALE_PATH } from './locale.path';
import { LANGUAGES } from './languages';
import { OptionsService } from '../common/options.service';
import { mapKeys } from 'lodash-es';
import { CachedLocaleDictionaryService } from './cached-locale-dictionary.service';
export class TranslateCustomLoader {
    constructor(http, optionsService, cachedLocaleDictionaryService, path = null, languages = null) {
        this.http = http;
        this.optionsService = optionsService;
        this.cachedLocaleDictionaryService = cachedLocaleDictionaryService;
        this.path = path;
        this.languages = languages;
    }
    getTranslation(lang) {
        const path = this.path || '';
        let url = `${path}${lang}.json`;
        if (this.languages && this.languages[lang] && this.languages[lang].url) {
            url = this.languages[lang].url;
        }
        return this.http.get(url).pipe(map(d => {
            if (this.optionsService.langsDetails && this.optionsService.langsDetails[lang]) {
                return Object.assign(Object.assign({}, d[lang]), this.optionsService.langsDetails[lang]);
            }
            return d[lang];
        }), tap(dictionary => {
            this.cachedLocaleDictionaryService.cachedDictionary[lang] = dictionary;
        }), map(dictionary => this.getDictionaryWithTrimmedKeys(dictionary)), catchError(() => of({})));
    }
    /**
     * We want to have translation keys unified, so they don't contain unnecessary spaces and line breaks.
     * This way we can dynamically build keys from HTML, and match them to extracted string, that might be HTML as well.
     */
    getDictionaryWithTrimmedKeys(dictionary) {
        return mapKeys(dictionary, (value, key) => trimTranslationKey(key));
    }
}
TranslateCustomLoader.decorators = [
    { type: Injectable }
];
TranslateCustomLoader.ctorParameters = () => [
    { type: HttpClient },
    { type: OptionsService },
    { type: CachedLocaleDictionaryService },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_PATH,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [LANGUAGES,] }] }
];
export function trimTranslationKey(key) {
    return key.replace(/(\r\n|\n|\r)/gm, '').replace(/\s{2,}/g, ' ').trim();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRlLmxvYWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvaTE4bi90cmFuc2xhdGUubG9hZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUVsRCxPQUFPLEVBQWMsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDNUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUN4QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDM0QsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUNwQyxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUduRixNQUFNLE9BQU8scUJBQXFCO0lBQ2hDLFlBQ1UsSUFBZ0IsRUFDaEIsY0FBOEIsRUFDOUIsNkJBQTRELEVBQ3ZDLE9BQWUsSUFBSSxFQUNyQixZQUFpQixJQUFJO1FBSnhDLFNBQUksR0FBSixJQUFJLENBQVk7UUFDaEIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLGtDQUE2QixHQUE3Qiw2QkFBNkIsQ0FBK0I7UUFDdkMsU0FBSSxHQUFKLElBQUksQ0FBZTtRQUNyQixjQUFTLEdBQVQsU0FBUyxDQUFZO0lBQy9DLENBQUM7SUFFSixjQUFjLENBQUMsSUFBWTtRQUN6QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUM3QixJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxJQUFJLE9BQU8sQ0FBQztRQUNoQyxJQUFJLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRTtZQUN0RSxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUM7U0FDaEM7UUFFRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FDNUIsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ04sSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDOUUsdUNBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFLLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFHO2FBQ2xFO1lBQ0QsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDakIsQ0FBQyxDQUFDLEVBQ0YsR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ2YsSUFBSSxDQUFDLDZCQUE2QixDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQztRQUN6RSxDQUFDLENBQUMsRUFDRixHQUFHLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsNEJBQTRCLENBQUMsVUFBVSxDQUFDLENBQUMsRUFDaEUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUN6QixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7T0FHRztJQUNILDRCQUE0QixDQUFDLFVBQWtCO1FBQzdDLE9BQU8sT0FBTyxDQUFDLFVBQVUsRUFBRSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUN4QyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FDeEIsQ0FBQztJQUNKLENBQUM7OztZQXhDRixVQUFVOzs7WUFYRixVQUFVO1lBT1YsY0FBYztZQUVkLDZCQUE2Qjt5Q0FRakMsTUFBTSxTQUFDLFdBQVc7NENBQ2xCLE1BQU0sU0FBQyxTQUFTOztBQXFDckIsTUFBTSxVQUFVLGtCQUFrQixDQUFDLEdBQUc7SUFDcEMsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLGdCQUFnQixFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDMUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBUcmFuc2xhdGVMb2FkZXIgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAsIGNhdGNoRXJyb3IsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTE9DQUxFX1BBVEggfSBmcm9tICcuL2xvY2FsZS5wYXRoJztcbmltcG9ydCB7IExBTkdVQUdFUyB9IGZyb20gJy4vbGFuZ3VhZ2VzJztcbmltcG9ydCB7IE9wdGlvbnNTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL29wdGlvbnMuc2VydmljZSc7XG5pbXBvcnQgeyBtYXBLZXlzIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IENhY2hlZExvY2FsZURpY3Rpb25hcnlTZXJ2aWNlIH0gZnJvbSAnLi9jYWNoZWQtbG9jYWxlLWRpY3Rpb25hcnkuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUcmFuc2xhdGVDdXN0b21Mb2FkZXIgaW1wbGVtZW50cyBUcmFuc2xhdGVMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGh0dHA6IEh0dHBDbGllbnQsXG4gICAgcHJpdmF0ZSBvcHRpb25zU2VydmljZTogT3B0aW9uc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBjYWNoZWRMb2NhbGVEaWN0aW9uYXJ5U2VydmljZTogQ2FjaGVkTG9jYWxlRGljdGlvbmFyeVNlcnZpY2UsXG4gICAgQEluamVjdChMT0NBTEVfUEFUSCkgcHJpdmF0ZSBwYXRoOiBzdHJpbmcgPSBudWxsLFxuICAgIEBJbmplY3QoTEFOR1VBR0VTKSBwcml2YXRlIGxhbmd1YWdlczogYW55ID0gbnVsbFxuICApIHt9XG5cbiAgZ2V0VHJhbnNsYXRpb24obGFuZzogc3RyaW5nKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5wYXRoIHx8ICcnO1xuICAgIGxldCB1cmwgPSBgJHtwYXRofSR7bGFuZ30uanNvbmA7XG4gICAgaWYgKHRoaXMubGFuZ3VhZ2VzICYmIHRoaXMubGFuZ3VhZ2VzW2xhbmddICYmIHRoaXMubGFuZ3VhZ2VzW2xhbmddLnVybCkge1xuICAgICAgdXJsID0gdGhpcy5sYW5ndWFnZXNbbGFuZ10udXJsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmh0dHAuZ2V0KHVybCkucGlwZShcbiAgICAgIG1hcChkID0+IHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1NlcnZpY2UubGFuZ3NEZXRhaWxzICYmIHRoaXMub3B0aW9uc1NlcnZpY2UubGFuZ3NEZXRhaWxzW2xhbmddKSB7XG4gICAgICAgICAgcmV0dXJuIHsgLi4uZFtsYW5nXSwgLi4udGhpcy5vcHRpb25zU2VydmljZS5sYW5nc0RldGFpbHNbbGFuZ10gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZFtsYW5nXTtcbiAgICAgIH0pLFxuICAgICAgdGFwKGRpY3Rpb25hcnkgPT4ge1xuICAgICAgICB0aGlzLmNhY2hlZExvY2FsZURpY3Rpb25hcnlTZXJ2aWNlLmNhY2hlZERpY3Rpb25hcnlbbGFuZ10gPSBkaWN0aW9uYXJ5O1xuICAgICAgfSksXG4gICAgICBtYXAoZGljdGlvbmFyeSA9PiB0aGlzLmdldERpY3Rpb25hcnlXaXRoVHJpbW1lZEtleXMoZGljdGlvbmFyeSkpLFxuICAgICAgY2F0Y2hFcnJvcigoKSA9PiBvZih7fSkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSB3YW50IHRvIGhhdmUgdHJhbnNsYXRpb24ga2V5cyB1bmlmaWVkLCBzbyB0aGV5IGRvbid0IGNvbnRhaW4gdW5uZWNlc3Nhcnkgc3BhY2VzIGFuZCBsaW5lIGJyZWFrcy5cbiAgICogVGhpcyB3YXkgd2UgY2FuIGR5bmFtaWNhbGx5IGJ1aWxkIGtleXMgZnJvbSBIVE1MLCBhbmQgbWF0Y2ggdGhlbSB0byBleHRyYWN0ZWQgc3RyaW5nLCB0aGF0IG1pZ2h0IGJlIEhUTUwgYXMgd2VsbC5cbiAgICovXG4gIGdldERpY3Rpb25hcnlXaXRoVHJpbW1lZEtleXMoZGljdGlvbmFyeTogb2JqZWN0KSB7XG4gICAgcmV0dXJuIG1hcEtleXMoZGljdGlvbmFyeSwgKHZhbHVlLCBrZXkpID0+XG4gICAgICB0cmltVHJhbnNsYXRpb25LZXkoa2V5KVxuICAgICk7XG4gIH1cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJpbVRyYW5zbGF0aW9uS2V5KGtleSkge1xuICByZXR1cm4ga2V5LnJlcGxhY2UoLyhcXHJcXG58XFxufFxccikvZ20sICcnKS5yZXBsYWNlKC9cXHN7Mix9L2csICcgJykudHJpbSgpO1xufVxuIl19