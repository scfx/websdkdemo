import { Injectable, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { BsModalService } from 'ngx-bootstrap/modal';
import { BehaviorSubject, Subject } from 'rxjs';
import { map, shareReplay } from 'rxjs/operators';
import { fromTrigger, stateToFactory } from '../common/extension-hooks';
import { StateService } from '../common/state-service.abstract';
import { WizardComponent } from './wizard.component';
import { HOOK_WIZARD } from './wizard.model';
import * as i0 from "@angular/core";
import * as i1 from "ngx-bootstrap/modal";
import * as i2 from "@angular/router";
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'ngx-bootstrap/modal';
import * as ɵngcc2 from '@angular/router';
export class WizardService extends StateService {
    constructor(bsModalService, injector, router) {
        super();
        this.bsModalService = bsModalService;
        this.injector = injector;
        this.router = router;
        /** Wizard header subject. It emits header template. */
        this.headerTemplate$ = new Subject();
        /** Wizard body subject. It emits body template. */
        this.bodyTemplate$ = new Subject();
        /** Wizard footer subject. It emits footer template. */
        this.footerTemplate$ = new Subject();
        /**
         * @ignore
         */
        this.state$ = new BehaviorSubject(new Set());
        /** Refresh the extension factories subject. */
        this.refreshTrigger = new Subject();
        /** Additional factories that can be added by plugins. */
        this.factories = [];
        this.items$ = fromTrigger(this.router, this.refreshTrigger, [
            () => this.injector.get(HOOK_WIZARD, []),
            () => this.factories,
            stateToFactory(this.state$)
        ]).pipe(map(entries => entries), shareReplay(1));
    }
    /**
     * Returns the current state.
     * @returns The current set of entries.
     * @readonly
     */
    get state() {
        return this.state$.value;
    }
    /**
     * Refresh the extension factories.
     */
    refresh() {
        this.refreshTrigger.next();
    }
    /**
     * Adds a new entry in the wizard.
     * @param entry Wizard entry to add.
     */
    add(entry) {
        this.state.add(entry);
        this.emitNewState();
    }
    /**
     * Removes entry from the wizard.
     * @param entry Wizard entry to remove.
     */
    remove(entry) {
        this.state.delete(entry);
        this.emitNewState();
    }
    /**
     * List of wizard entries matching the given id.
     * @param id
     * @returns observable with list of wizard entries.
     */
    getEntriesListById(id) {
        return this.items$.pipe(map(entries => entries.filter(entry => entry.wizardId === id)));
    }
    /**
     * Shows a wizard modal.
     * @param modalOptions Modal options.
     * @returns a reference to the modal.
     */
    show(modalOptions = {}) {
        const options = Object.assign({ class: 'modal-sm', backdrop: 'static' }, modalOptions);
        return this.bsModalService.show(WizardComponent, options);
    }
}
WizardService.ɵfac = function WizardService_Factory(t) { return new (t || WizardService)(ɵngcc0.ɵɵinject(ɵngcc1.BsModalService), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(ɵngcc2.Router)); };
WizardService.ɵprov = i0.ɵɵdefineInjectable({ factory: function WizardService_Factory() { return new WizardService(i0.ɵɵinject(i1.BsModalService), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i2.Router)); }, token: WizardService, providedIn: "root" });
WizardService.ctorParameters = () => [
    { type: BsModalService },
    { type: Injector },
    { type: Router }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(WizardService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.BsModalService }, { type: ɵngcc0.Injector }, { type: ɵngcc2.Router }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2l6YXJkLnNlcnZpY2UuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvd2l6YXJkL3dpemFyZC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFlLE1BQU0sZUFBZSxDQUFDO0FBQ2xFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QyxPQUFPLEVBQWMsY0FBYyxFQUFnQixNQUFNLHFCQUFxQixDQUFDO0FBQy9FLE9BQU8sRUFBRSxlQUFlLEVBQWMsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzVELE9BQU8sRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEQsT0FBTyxFQUFrQixXQUFXLEVBQUUsY0FBYyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDeEYsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNyRCxPQUFPLEVBQUUsV0FBVyxFQUFnQyxNQUFNLGdCQUFnQixDQUFDO0FBQzNFO0FBR0M7QUFDd0M7Ozs7QUFBekMsTUFBTSxPQUFPLGFBQWMsU0FBUSxZQUFZO0FBQUcsSUFvQmhELFlBQ1UsY0FBOEIsRUFDOUIsUUFBa0IsRUFDbEIsTUFBYztBQUN2QixRQUNDLEtBQUssRUFBRSxDQUFDO0FBQ1osUUFMWSxtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7QUFBQyxRQUMvQixhQUFRLEdBQVIsUUFBUSxDQUFVO0FBQUMsUUFDbkIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtBQUMxQixRQXJCRSx1REFBdUQ7QUFDekQsUUFBVyxvQkFBZSxHQUN0QixJQUFJLE9BQU8sRUFBRSxDQUFDO0FBQ2xCLFFBQUUsbURBQW1EO0FBQ3JELFFBQVcsa0JBQWEsR0FBOEQsSUFBSSxPQUFPLEVBQUUsQ0FBQztBQUNwRyxRQUFFLHVEQUF1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cnQgeyBJbmplY3RhYmxlLCBJbmplY3RvciwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBCc01vZGFsUmVmLCBCc01vZGFsU2VydmljZSwgTW9kYWxPcHRpb25zIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC9tb2RhbCc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgc2hhcmVSZXBsYXkgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBFeHRlbnNpb25Qb2ludCwgZnJvbVRyaWdnZXIsIHN0YXRlVG9GYWN0b3J5IH0gZnJvbSAnLi4vY29tbW9uL2V4dGVuc2lvbi1ob29rcyc7XG5pbXBvcnQgeyBTdGF0ZVNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vc3RhdGUtc2VydmljZS5hYnN0cmFjdCc7XG5pbXBvcnQgeyBXaXphcmRDb21wb25lbnQgfSBmcm9tICcuL3dpemFyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSE9PS19XSVpBUkQsIFdpemFyZEVudHJ5LCBXaXphcmRFeHRlbnNpb24gfSBmcm9tICcuL3dpemFyZC5tb2RlbCc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFdpemFyZFNlcnZpY2UgZXh0ZW5kcyBTdGF0ZVNlcnZpY2UgaW1wbGVtZW50cyBFeHRlbnNpb25Qb2ludDxXaXphcmRFeHRlbnNpb24+IHtcbiAgLyoqIFdpemFyZCBsaXN0IG9ic2VydmFibGUuIEl0IGVtaXRzIHRoZSBjdXJyZW50IGxpc3Qgb2YgdGhlIHdpemFyZCBlbnRyaWVzLiAqL1xuICByZWFkb25seSBpdGVtcyQ6IE9ic2VydmFibGU8V2l6YXJkRW50cnlbXT47XG4gIC8qKiBXaXphcmQgaGVhZGVyIHN1YmplY3QuIEl0IGVtaXRzIGhlYWRlciB0ZW1wbGF0ZS4gKi9cbiAgcmVhZG9ubHkgaGVhZGVyVGVtcGxhdGUkOiBTdWJqZWN0PHsgd2l6YXJkSWQ6IHN0cmluZzsgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4gfT4gPVxuICAgIG5ldyBTdWJqZWN0KCk7XG4gIC8qKiBXaXphcmQgYm9keSBzdWJqZWN0LiBJdCBlbWl0cyBib2R5IHRlbXBsYXRlLiAqL1xuICByZWFkb25seSBib2R5VGVtcGxhdGUkOiBTdWJqZWN0PHsgd2l6YXJkSWQ6IHN0cmluZzsgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4gfT4gPSBuZXcgU3ViamVjdCgpO1xuICAvKiogV2l6YXJkIGZvb3RlciBzdWJqZWN0LiBJdCBlbWl0cyBmb290ZXIgdGVtcGxhdGUuICovXG4gIHJlYWRvbmx5IGZvb3RlclRlbXBsYXRlJDogU3ViamVjdDx7IHdpemFyZElkOiBzdHJpbmc7IHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+IH0+ID1cbiAgICBuZXcgU3ViamVjdCgpO1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgcmVhZG9ubHkgc3RhdGUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxTZXQ8V2l6YXJkRW50cnk+PihuZXcgU2V0PFdpemFyZEVudHJ5PigpKTtcbiAgLyoqIFJlZnJlc2ggdGhlIGV4dGVuc2lvbiBmYWN0b3JpZXMgc3ViamVjdC4gKi9cbiAgcmVhZG9ubHkgcmVmcmVzaFRyaWdnZXIgPSBuZXcgU3ViamVjdCgpO1xuICAvKiogQWRkaXRpb25hbCBmYWN0b3JpZXMgdGhhdCBjYW4gYmUgYWRkZWQgYnkgcGx1Z2lucy4gKi9cbiAgZmFjdG9yaWVzOiBXaXphcmRFeHRlbnNpb25bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgYnNNb2RhbFNlcnZpY2U6IEJzTW9kYWxTZXJ2aWNlLFxuICAgIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIHByaXZhdGUgcm91dGVyOiBSb3V0ZXJcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLml0ZW1zJCA9IGZyb21UcmlnZ2VyKHRoaXMucm91dGVyLCB0aGlzLnJlZnJlc2hUcmlnZ2VyLCBbXG4gICAgICAoKSA9PiB0aGlzLmluamVjdG9yLmdldChIT09LX1dJWkFSRCwgW10pLFxuICAgICAgKCkgPT4gdGhpcy5mYWN0b3JpZXMsXG4gICAgICBzdGF0ZVRvRmFjdG9yeSh0aGlzLnN0YXRlJClcbiAgICBdKS5waXBlKFxuICAgICAgbWFwKGVudHJpZXMgPT4gZW50cmllcyBhcyBXaXphcmRFbnRyeVtdKSxcbiAgICAgIHNoYXJlUmVwbGF5KDEpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzZXQgb2YgZW50cmllcy5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgc3RhdGUoKTogU2V0PFdpemFyZEVudHJ5PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUkLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggdGhlIGV4dGVuc2lvbiBmYWN0b3JpZXMuXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMucmVmcmVzaFRyaWdnZXIubmV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgZW50cnkgaW4gdGhlIHdpemFyZC5cbiAgICogQHBhcmFtIGVudHJ5IFdpemFyZCBlbnRyeSB0byBhZGQuXG4gICAqL1xuICBhZGQoZW50cnk6IFdpemFyZEVudHJ5KSB7XG4gICAgdGhpcy5zdGF0ZS5hZGQoZW50cnkpO1xuICAgIHRoaXMuZW1pdE5ld1N0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBlbnRyeSBmcm9tIHRoZSB3aXphcmQuXG4gICAqIEBwYXJhbSBlbnRyeSBXaXphcmQgZW50cnkgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlKGVudHJ5OiBXaXphcmRFbnRyeSkge1xuICAgIHRoaXMuc3RhdGUuZGVsZXRlKGVudHJ5KTtcbiAgICB0aGlzLmVtaXROZXdTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3Qgb2Ygd2l6YXJkIGVudHJpZXMgbWF0Y2hpbmcgdGhlIGdpdmVuIGlkLlxuICAgKiBAcGFyYW0gaWRcbiAgICogQHJldHVybnMgb2JzZXJ2YWJsZSB3aXRoIGxpc3Qgb2Ygd2l6YXJkIGVudHJpZXMuXG4gICAqL1xuICBnZXRFbnRyaWVzTGlzdEJ5SWQoaWQ6IHN0cmluZyk6IE9ic2VydmFibGU8V2l6YXJkRW50cnlbXT4ge1xuICAgIHJldHVybiB0aGlzLml0ZW1zJC5waXBlKG1hcChlbnRyaWVzID0+IGVudHJpZXMuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LndpemFyZElkID09PSBpZCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93cyBhIHdpemFyZCBtb2RhbC5cbiAgICogQHBhcmFtIG1vZGFsT3B0aW9ucyBNb2RhbCBvcHRpb25zLlxuICAgKiBAcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgbW9kYWwuXG4gICAqL1xuICBzaG93KG1vZGFsT3B0aW9uczogTW9kYWxPcHRpb25zID0ge30pOiBCc01vZGFsUmVmPFdpemFyZENvbXBvbmVudD4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBjbGFzczogJ21vZGFsLXNtJyxcbiAgICAgIGJhY2tkcm9wOiAnc3RhdGljJyxcbiAgICAgIC4uLm1vZGFsT3B0aW9uc1xuICAgIH0gYXMgTW9kYWxPcHRpb25zPFdpemFyZENvbXBvbmVudD47XG4gICAgcmV0dXJuIHRoaXMuYnNNb2RhbFNlcnZpY2Uuc2hvdzxXaXphcmRDb21wb25lbnQ+KFdpemFyZENvbXBvbmVudCwgb3B0aW9ucyk7XG4gIH1cbn1cbiJdfQ==