import { Component, Input, Output, ContentChildren, EventEmitter, ChangeDetectorRef, ElementRef } from '@angular/core';
import { CdkStepper, STEP_STATE } from '@angular/cdk/stepper';
import { C8yStepperIcon } from './stepper-icon.directive';
import { Subject } from 'rxjs';
import { Directionality } from '@angular/cdk/bidi';
/**
 * C8yStepper extends the CdkStepper. You can use cdk based functionality and inputs.
 * Additional to that you are able to modify the behavior and also the look and feel when
 * using the C8yStepper.
 *
 * The C8yStepper is used to present any step-based process to the user.
 * A stepper, C8yStepper and/or CdkStepper is the parent of cdk-steps.
 * Each cdk-step represents one step in the whole process that you want to provide to the user.
 *
 * The C8yStepper will create, based on the given cdk-steps, a kind of stepper-progress which looks like this:
 * (1)---(2)---(3)---(n)
 * The stepper will handle the state of each step and provides styles for active steps, done-steps or in edit-mode.
 * You are able to override icons for each step in the stepper-progress with a template. You are also able to activate
 * default-icons for states like 'edit' and 'done'.
 *
 * To force users through every provided step, set the stepper to 'linear'.
 * This will disable the possibility to move for example from step one to step three.
 *
 * Whenever it comes to validation try to use formGroups. It is possible to
 * assign a formGroup to a cdk-step input called [stepControl], which automatically respects the
 * validation-rules that you created for this formGroup. If fields are required but not filled or
 * any other validation, like a pattern, is not matched the formGroup will be invalid. In this case
 * stepping in a linear stepper to the next step gets impossible.
 *
 * If there is the need to execute asynchronous code you have at least two possibilities.
 * First: As you learned, a cdk-step works with formGroups and Validators, so you are able to use
 * asyncValidators as well.
 * Second: The C8yStepper provides an event-emitter onStepChange which is called whenever a step-button (1)--(2)--(n)
 * in the stepper-progress is clicked. The event of this emitter holds the index of the step as number. You can
 * use this EventEmitter to call for example a custom navigate-method which performs first any async-call and then moves
 * on to the given step.
 *
 * @example
 * ```
 * <c8y-stepper
 * (onStepChange)="navigate($event)"
 * [disableDefaultIcons]="{ edit: true, done: false }"
 * [customClasses]="['m-l-40', 'm-r-40', 'm-t-32']"
 * linear
 * >
 * <!-- override icons -->
 * <ng-template c8yStepperIcon="final">
 *   <span [c8yIcon]="'hand-peace-o'"></span>
 * </ng-template>
 *
 * <cdk-step [stepControl]="formGroupStepOne" label="Name of the hero">
 *   <div class="m-l-40 m-r-40 m-t-32">
 *     <h4 class="p-b-8" translate>What is the name of your hero?</h4>
 *     <c8y-form-group>
 *      <div [formGroup]="formGroupStepOne">
 *       <input
 *         class="form-control"
 *         type="text"
 *         formControlName="name"
 *         placeholder="Mister X"
 *         #nameRef
 *         required
 *       />
 *       <c8y-messages>
 *         <c8y-message *ngIf="!formGroupStepOne.untouched && !nameRef.value" translate
 *           >Enter the name of the Superhero</c8y-message
 *         >
 *       </c8y-messages>
 *      </div>
 *     </c8y-form-group>
 *   </div>
 *   <c8y-stepper-buttons></c8y-stepper-buttons>
 * </cdk-step>
 * <cdk-step>
 *  ...
 * </cdk-step state="final">
 * </c8y-stepper>
 * ```
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/bidi';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from './stepper-progress.component';
import * as ɵngcc4 from '../i18n/c8y-translate.pipe';

const _c0 = function (a0) { return { "active": a0 }; };
function C8yStepper_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li");
    ɵngcc0.ɵɵelementStart(1, "c8y-stepper-progress", 3);
    ɵngcc0.ɵɵlistener("onStepClicked", function C8yStepper_li_1_Template_c8y_stepper_progress_onStepClicked_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.setIndex($event); });
    ɵngcc0.ɵɵpipe(2, "translate");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 4);
    ɵngcc0.ɵɵpipe(4, "translate");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵpipe(6, "translate");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const step_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵpropertyInterpolate("title", ɵngcc0.ɵɵpipeBind1(2, 8, step_r1.label));
    ɵngcc0.ɵɵproperty("iconOverrides", ctx_r0._iconOverrides)("state", ctx_r0.getIndicatorType(i_r2, step_r1.state))("index", i_r2)("selected", ctx_r0.selectedIndex === i_r2)("ngClass", ɵngcc0.ɵɵpureFunction1(14, _c0, ctx_r0.selectedIndex === i_r2));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵpropertyInterpolate("title", ɵngcc0.ɵɵpipeBind1(4, 10, step_r1.label));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind1(6, 12, step_r1.label), " ");
} }
export class C8yStepper extends CdkStepper {
    constructor(dir, changeDetectorRef, elementRef) {
        super(dir, changeDetectorRef, elementRef, document);
        this.dir = dir;
        this.changeDetectorRef = changeDetectorRef;
        this.elementRef = elementRef;
        /**
         * Optional
         * Indicator if icons for edit and done state should be shown in step-header buttons
         */
        this.disableDefaultIcons = { edit: true, done: true };
        /**
         * Will emit the step index number whenever a step-header button was clicked
         * It listens to the stepIndex Subject.
         */
        this.onStepChange = new EventEmitter();
        /** Consumer-specified template-refs to be used to override the header icons. */
        this._iconOverrides = {};
        this._stepIndex = new Subject();
    }
    ngAfterContentInit() {
        super.ngAfterContentInit();
        this._icons.forEach(({ name, templateRef }) => (this._iconOverrides[name] = templateRef));
        this._stepIndexSubscription = this._stepIndex.subscribe(index => this.onStepChange.emit(index));
    }
    ngOnDestroy() {
        if (this._stepIndexSubscription && !this._stepIndexSubscription.closed) {
            this._stepIndexSubscription.unsubscribe();
        }
    }
    /**
     * Manipulates the state based on the disabledDefaultIcons Input()
     * Changing edit or done to false will change the icons within step-header buttons
     * @param index step index
     * @param state step state, like 'done', 'edit', 'error'
     */
    getIndicatorType(index, state) {
        const stepState = this._getIndicatorType(index, state);
        let _state = state;
        switch (stepState) {
            case STEP_STATE.EDIT:
                if (!this.disableDefaultIcons.edit) {
                    _state = STEP_STATE.EDIT;
                }
                break;
            case STEP_STATE.DONE:
                if (!this.disableDefaultIcons.done) {
                    _state = STEP_STATE.DONE;
                }
                else {
                    _state = '_done';
                }
                break;
        }
        return _state;
    }
    /**
     * Pushs the step index to the subject
     * @param index step index
     */
    setIndex(index) {
        this._stepIndex.next(index);
    }
}
C8yStepper.ɵfac = function C8yStepper_Factory(t) { return new (t || C8yStepper)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Directionality), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
C8yStepper.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: C8yStepper, selectors: [["c8y-stepper"]], contentQueries: function C8yStepper_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, C8yStepperIcon, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._icons = _t);
    } }, inputs: { disableDefaultIcons: "disableDefaultIcons", customClasses: "customClasses" }, outputs: { onStepChange: "onStepChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkStepper, useExisting: C8yStepper }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 3, consts: [[1, "c8y-stepper", 3, "ngClass"], [4, "ngFor", "ngForOf"], [3, "ngTemplateOutlet"], [3, "iconOverrides", "state", "index", "selected", "title", "ngClass", "onStepClicked"], [1, "c8y-step__label", 3, "title"]], template: function C8yStepper_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, C8yStepper_li_1_Template, 7, 16, "li", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainer(2, 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.customClasses);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.steps);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.selected.content);
    } }, directives: [ɵngcc2.NgClass, ɵngcc2.NgForOf, ɵngcc2.NgTemplateOutlet, ɵngcc3.C8yStepperProgress], pipes: [ɵngcc4.C8yTranslatePipe], encapsulation: 2 });
C8yStepper.ctorParameters = () => [
    { type: Directionality },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
C8yStepper.propDecorators = {
    disableDefaultIcons: [{ type: Input }],
    customClasses: [{ type: Input }],
    onStepChange: [{ type: Output }],
    _icons: [{ type: ContentChildren, args: [C8yStepperIcon, { descendants: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(C8yStepper, [{
        type: Component,
        args: [{
                selector: 'c8y-stepper',
                template: "<ul class=\"c8y-stepper\" [ngClass]=\"customClasses\">\n  <li *ngFor=\"let step of steps; let i = index\">\n    <c8y-stepper-progress\n      [iconOverrides]=\"_iconOverrides\"\n      [state]=\"getIndicatorType(i, step.state)\"\n      [index]=\"i\"\n      [selected]=\"selectedIndex === i\"\n      (onStepClicked)=\"setIndex($event)\"\n      title=\"{{ step.label | translate }}\"\n      [ngClass]=\"{'active': selectedIndex === i}\"\n    >\n    </c8y-stepper-progress>\n    <div class=\"c8y-step__label\"  title=\"{{ step.label | translate }}\">\n      {{ step.label | translate }}\n    </div>\n  </li>\n</ul>\n<ng-container [ngTemplateOutlet]=\"selected.content\"></ng-container>\n",
                providers: [{ provide: CdkStepper, useExisting: C8yStepper }]
            }]
    }], function () { return [{ type: ɵngcc1.Directionality }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { disableDefaultIcons: [{
            type: Input
        }], onStepChange: [{
            type: Output
        }], customClasses: [{
            type: Input
        }], _icons: [{
            type: ContentChildren,
            args: [C8yStepperIcon, { descendants: true }]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvc3RlcHBlci9zdGVwcGVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUVULEtBQUssRUFDTCxNQUFNLEVBQ04sZUFBZSxFQUlmLFlBQVksRUFDWixpQkFBaUIsRUFDakIsVUFBVSxFQUNYLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxVQUFVLEVBQWEsVUFBVSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDekUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzFELE9BQU8sRUFBRSxPQUFPLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQzdDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1ILE1BQU0sT0FBTyxVQUFXLFNBQVEsVUFBVTtBQUFHLElBbUQzQyxZQUNVLEdBQW1CLEVBQ25CLGlCQUFvQyxFQUNwQyxVQUFvQztBQUM5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QUMsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsQ0FBQyxjQUM5RDs7Ozs7Ozs7Ozs7aUtBQ0k7QUFBQztBQUFvQyxZQWpGakMsY0FBYztBQUFJLFlBTnpCLGlCQUFpQjtBQUNqQixZQUFBLFVBQVU7QUFDVjtBQUFHO0FBQ00sa0NBeUZSLEtBQUs7QUFBSyw0QkFLVixLQUFLO0FBQUssMkJBS1YsTUFBTTtBQUFLLHFCQTRCWCxlQUFlLFNBQUMsY0FBYyxFQUFFLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRTtBQUFNOzs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBUZW1wbGF0ZVJlZixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBRdWVyeUxpc3QsXG4gIEFmdGVyQ29udGVudEluaXQsXG4gIE9uRGVzdHJveSxcbiAgRXZlbnRFbWl0dGVyLFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgRWxlbWVudFJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENka1N0ZXBwZXIsIFN0ZXBTdGF0ZSwgU1RFUF9TVEFURSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zdGVwcGVyJztcbmltcG9ydCB7IEM4eVN0ZXBwZXJJY29uIH0gZnJvbSAnLi9zdGVwcGVyLWljb24uZGlyZWN0aXZlJztcbmltcG9ydCB7IFN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5cbi8qKlxuICogQzh5U3RlcHBlciBleHRlbmRzIHRoZSBDZGtTdGVwcGVyLiBZb3UgY2FuIHVzZSBjZGsgYmFzZWQgZnVuY3Rpb25hbGl0eSBhbmQgaW5wdXRzLlxuICogQWRkaXRpb25hbCB0byB0aGF0IHlvdSBhcmUgYWJsZSB0byBtb2RpZnkgdGhlIGJlaGF2aW9yIGFuZCBhbHNvIHRoZSBsb29rIGFuZCBmZWVsIHdoZW5cbiAqIHVzaW5nIHRoZSBDOHlTdGVwcGVyLlxuICpcbiAqIFRoZSBDOHlTdGVwcGVyIGlzIHVzZWQgdG8gcHJlc2VudCBhbnkgc3RlcC1iYXNlZCBwcm9jZXNzIHRvIHRoZSB1c2VyLlxuICogQSBzdGVwcGVyLCBDOHlTdGVwcGVyIGFuZC9vciBDZGtTdGVwcGVyIGlzIHRoZSBwYXJlbnQgb2YgY2RrLXN0ZXBzLlxuICogRWFjaCBjZGstc3RlcCByZXByZXNlbnRzIG9uZSBzdGVwIGluIHRoZSB3aG9sZSBwcm9jZXNzIHRoYXQgeW91IHdhbnQgdG8gcHJvdmlkZSB0byB0aGUgdXNlci5cbiAqXG4gKiBUaGUgQzh5U3RlcHBlciB3aWxsIGNyZWF0ZSwgYmFzZWQgb24gdGhlIGdpdmVuIGNkay1zdGVwcywgYSBraW5kIG9mIHN0ZXBwZXItcHJvZ3Jlc3Mgd2hpY2ggbG9va3MgbGlrZSB0aGlzOlxuICogKDEpLS0tKDIpLS0tKDMpLS0tKG4pXG4gKiBUaGUgc3RlcHBlciB3aWxsIGhhbmRsZSB0aGUgc3RhdGUgb2YgZWFjaCBzdGVwIGFuZCBwcm92aWRlcyBzdHlsZXMgZm9yIGFjdGl2ZSBzdGVwcywgZG9uZS1zdGVwcyBvciBpbiBlZGl0LW1vZGUuXG4gKiBZb3UgYXJlIGFibGUgdG8gb3ZlcnJpZGUgaWNvbnMgZm9yIGVhY2ggc3RlcCBpbiB0aGUgc3RlcHBlci1wcm9ncmVzcyB3aXRoIGEgdGVtcGxhdGUuIFlvdSBhcmUgYWxzbyBhYmxlIHRvIGFjdGl2YXRlXG4gKiBkZWZhdWx0LWljb25zIGZvciBzdGF0ZXMgbGlrZSAnZWRpdCcgYW5kICdkb25lJy5cbiAqXG4gKiBUbyBmb3JjZSB1c2VycyB0aHJvdWdoIGV2ZXJ5IHByb3ZpZGVkIHN0ZXAsIHNldCB0aGUgc3RlcHBlciB0byAnbGluZWFyJy5cbiAqIFRoaXMgd2lsbCBkaXNhYmxlIHRoZSBwb3NzaWJpbGl0eSB0byBtb3ZlIGZvciBleGFtcGxlIGZyb20gc3RlcCBvbmUgdG8gc3RlcCB0aHJlZS5cbiAqXG4gKiBXaGVuZXZlciBpdCBjb21lcyB0byB2YWxpZGF0aW9uIHRyeSB0byB1c2UgZm9ybUdyb3Vwcy4gSXQgaXMgcG9zc2libGUgdG9cbiAqIGFzc2lnbiBhIGZvcm1Hcm91cCB0byBhIGNkay1zdGVwIGlucHV0IGNhbGxlZCBbc3RlcENvbnRyb2xdLCB3aGljaCBhdXRvbWF0aWNhbGx5IHJlc3BlY3RzIHRoZVxuICogdmFsaWRhdGlvbi1ydWxlcyB0aGF0IHlvdSBjcmVhdGVkIGZvciB0aGlzIGZvcm1Hcm91cC4gSWYgZmllbGRzIGFyZSByZXF1aXJlZCBidXQgbm90IGZpbGxlZCBvclxuICogYW55IG90aGVyIHZhbGlkYXRpb24sIGxpa2UgYSBwYXR0ZXJuLCBpcyBub3QgbWF0Y2hlZCB0aGUgZm9ybUdyb3VwIHdpbGwgYmUgaW52YWxpZC4gSW4gdGhpcyBjYXNlXG4gKiBzdGVwcGluZyBpbiBhIGxpbmVhciBzdGVwcGVyIHRvIHRoZSBuZXh0IHN0ZXAgZ2V0cyBpbXBvc3NpYmxlLlxuICpcbiAqIElmIHRoZXJlIGlzIHRoZSBuZWVkIHRvIGV4ZWN1dGUgYXN5bmNocm9ub3VzIGNvZGUgeW91IGhhdmUgYXQgbGVhc3QgdHdvIHBvc3NpYmlsaXRpZXMuXG4gKiBGaXJzdDogQXMgeW91IGxlYXJuZWQsIGEgY2RrLXN0ZXAgd29ya3Mgd2l0aCBmb3JtR3JvdXBzIGFuZCBWYWxpZGF0b3JzLCBzbyB5b3UgYXJlIGFibGUgdG8gdXNlXG4gKiBhc3luY1ZhbGlkYXRvcnMgYXMgd2VsbC5cbiAqIFNlY29uZDogVGhlIEM4eVN0ZXBwZXIgcHJvdmlkZXMgYW4gZXZlbnQtZW1pdHRlciBvblN0ZXBDaGFuZ2Ugd2hpY2ggaXMgY2FsbGVkIHdoZW5ldmVyIGEgc3RlcC1idXR0b24gKDEpLS0oMiktLShuKVxuICogaW4gdGhlIHN0ZXBwZXItcHJvZ3Jlc3MgaXMgY2xpY2tlZC4gVGhlIGV2ZW50IG9mIHRoaXMgZW1pdHRlciBob2xkcyB0aGUgaW5kZXggb2YgdGhlIHN0ZXAgYXMgbnVtYmVyLiBZb3UgY2FuXG4gKiB1c2UgdGhpcyBFdmVudEVtaXR0ZXIgdG8gY2FsbCBmb3IgZXhhbXBsZSBhIGN1c3RvbSBuYXZpZ2F0ZS1tZXRob2Qgd2hpY2ggcGVyZm9ybXMgZmlyc3QgYW55IGFzeW5jLWNhbGwgYW5kIHRoZW4gbW92ZXNcbiAqIG9uIHRvIHRoZSBnaXZlbiBzdGVwLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIDxjOHktc3RlcHBlclxuICogKG9uU3RlcENoYW5nZSk9XCJuYXZpZ2F0ZSgkZXZlbnQpXCJcbiAqIFtkaXNhYmxlRGVmYXVsdEljb25zXT1cInsgZWRpdDogdHJ1ZSwgZG9uZTogZmFsc2UgfVwiXG4gKiBbY3VzdG9tQ2xhc3Nlc109XCJbJ20tbC00MCcsICdtLXItNDAnLCAnbS10LTMyJ11cIlxuICogbGluZWFyXG4gKiA+XG4gKiA8IS0tIG92ZXJyaWRlIGljb25zIC0tPlxuICogPG5nLXRlbXBsYXRlIGM4eVN0ZXBwZXJJY29uPVwiZmluYWxcIj5cbiAqICAgPHNwYW4gW2M4eUljb25dPVwiJ2hhbmQtcGVhY2UtbydcIj48L3NwYW4+XG4gKiA8L25nLXRlbXBsYXRlPlxuICpcbiAqIDxjZGstc3RlcCBbc3RlcENvbnRyb2xdPVwiZm9ybUdyb3VwU3RlcE9uZVwiIGxhYmVsPVwiTmFtZSBvZiB0aGUgaGVyb1wiPlxuICogICA8ZGl2IGNsYXNzPVwibS1sLTQwIG0tci00MCBtLXQtMzJcIj5cbiAqICAgICA8aDQgY2xhc3M9XCJwLWItOFwiIHRyYW5zbGF0ZT5XaGF0IGlzIHRoZSBuYW1lIG9mIHlvdXIgaGVybz88L2g0PlxuICogICAgIDxjOHktZm9ybS1ncm91cD5cbiAqICAgICAgPGRpdiBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFN0ZXBPbmVcIj5cbiAqICAgICAgIDxpbnB1dFxuICogICAgICAgICBjbGFzcz1cImZvcm0tY29udHJvbFwiXG4gKiAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAqICAgICAgICAgZm9ybUNvbnRyb2xOYW1lPVwibmFtZVwiXG4gKiAgICAgICAgIHBsYWNlaG9sZGVyPVwiTWlzdGVyIFhcIlxuICogICAgICAgICAjbmFtZVJlZlxuICogICAgICAgICByZXF1aXJlZFxuICogICAgICAgLz5cbiAqICAgICAgIDxjOHktbWVzc2FnZXM+XG4gKiAgICAgICAgIDxjOHktbWVzc2FnZSAqbmdJZj1cIiFmb3JtR3JvdXBTdGVwT25lLnVudG91Y2hlZCAmJiAhbmFtZVJlZi52YWx1ZVwiIHRyYW5zbGF0ZVxuICogICAgICAgICAgID5FbnRlciB0aGUgbmFtZSBvZiB0aGUgU3VwZXJoZXJvPC9jOHktbWVzc2FnZVxuICogICAgICAgICA+XG4gKiAgICAgICA8L2M4eS1tZXNzYWdlcz5cbiAqICAgICAgPC9kaXY+XG4gKiAgICAgPC9jOHktZm9ybS1ncm91cD5cbiAqICAgPC9kaXY+XG4gKiAgIDxjOHktc3RlcHBlci1idXR0b25zPjwvYzh5LXN0ZXBwZXItYnV0dG9ucz5cbiAqIDwvY2RrLXN0ZXA+XG4gKiA8Y2RrLXN0ZXA+XG4gKiAgLi4uXG4gKiA8L2Nkay1zdGVwIHN0YXRlPVwiZmluYWxcIj5cbiAqIDwvYzh5LXN0ZXBwZXI+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYzh5LXN0ZXBwZXInLFxuICB0ZW1wbGF0ZVVybDogJy4vc3RlcHBlci5jb21wb25lbnQuaHRtbCcsXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrU3RlcHBlciwgdXNlRXhpc3Rpbmc6IEM4eVN0ZXBwZXIgfV1cbn0pXG5leHBvcnQgY2xhc3MgQzh5U3RlcHBlciBleHRlbmRzIENka1N0ZXBwZXIgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICAvKipcbiAgICogT3B0aW9uYWxcbiAgICogSW5kaWNhdG9yIGlmIGljb25zIGZvciBlZGl0IGFuZCBkb25lIHN0YXRlIHNob3VsZCBiZSBzaG93biBpbiBzdGVwLWhlYWRlciBidXR0b25zXG4gICAqL1xuICBASW5wdXQoKSBkaXNhYmxlRGVmYXVsdEljb25zPzogeyBlZGl0OiBib29sZWFuOyBkb25lOiBib29sZWFuIH0gPSB7IGVkaXQ6IHRydWUsIGRvbmU6IHRydWUgfTtcbiAgLyoqXG4gICAqIE9wdGlvbmFsXG4gICAqIFBvc3NpYmlsaXR5IHRvIGFkZCBhbnkga2luZCBvZiBjdXN0b20gY3NzIGNsYXNzZXMgdG8gdGhlIHN0ZXAtaGVhZGVyXG4gICAqL1xuICBASW5wdXQoKSBjdXN0b21DbGFzc2VzPzogW3N0cmluZ107XG4gIC8qKlxuICAgKiBXaWxsIGVtaXQgdGhlIHN0ZXAgaW5kZXggbnVtYmVyIHdoZW5ldmVyIGEgc3RlcC1oZWFkZXIgYnV0dG9uIHdhcyBjbGlja2VkXG4gICAqIEl0IGxpc3RlbnMgdG8gdGhlIHN0ZXBJbmRleCBTdWJqZWN0LlxuICAgKi9cbiAgQE91dHB1dCgpIG9uU3RlcENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIC8qKlxuICAgKiBIb2xkaW5nIGEgUXVlcnlMaXN0IG9mIEM4eVN0ZXBwZXJJY29uc1xuICAgKiBUaGVzZSBhcmUgdGVtcGxhdGVSZWZzIHdoaWNoIG92ZXJyaWRlcyBhbnkgc3RlcC1oZWFkZXIgYnV0dG9uIGljb24gd2l0aCBtYXRjaGluZyBzdGF0ZSBvZiBjZGstc3RlcFxuICAgKlxuICAgKiBAZXhhbXBsZTpcbiAgICogYGBgXG4gICAqIDwhLS0gb3ZlcnJpZGUgaWNvbnMgLS0+XG4gICAqICA8bmctdGVtcGxhdGUgYzh5U3RlcHBlckljb249XCJmaW5hbFwiPlxuICAgKiAgIDxzcGFuIFtjOHlJY29uXT1cIidoYW5kLXBlYWNlLW8nXCI+PC9zcGFuPlxuICAgKiAgPC9uZy10ZW1wbGF0ZT5cbiAgICpcbiAgICogPGNkay1zdGVwIHN0YXRlPVwiZmluYWxcIiBsYWJlbD1cIkpvYiBkb25lIVwiPlxuICAgKiAgPGRpdiBjbGFzcz1cIm0tbC00MCBtLXItNDAgbS10LTMyXCI+XG4gICAqICAgIDxoNCBjbGFzcz1cInAtYi0zMlwiIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyO1wiIHRyYW5zbGF0ZT5cbiAgICogICAgIFlvdXIgU3VwZXJoZXJvIGlzIG5vdyByZWFkeSB0byBzYXZlIHRoZSB3b3JsZCFcbiAgICogICA8L2g0PlxuICAgKiAgPC9kaXY+XG4gICAqICA8Yzh5LXN0ZXBwZXItYnV0dG9uc1xuICAgKiAgICBbaGlkZGVuXT1cIiFpc01vZGFsXCJcbiAgICogICAgKG9uQmFjayk9XCJjbG9zZSgpXCJcbiAgICogICAgW2xhYmVsc109XCJ7IGJhY2s6ICdHb3QgaXQhJyB9XCJcbiAgICogID48L2M4eS1zdGVwcGVyLWJ1dHRvbnM+XG4gICAqICA8Yzh5LXN0ZXBwZXItYnV0dG9ucyBbaGlkZGVuXT1cImlzTW9kYWxcIj48L2M4eS1zdGVwcGVyLWJ1dHRvbnM+XG4gICAqIDwvY2RrLXN0ZXA+XG4gICAqIGBgYFxuICAgKi9cbiAgQENvbnRlbnRDaGlsZHJlbihDOHlTdGVwcGVySWNvbiwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KSBfaWNvbnM6IFF1ZXJ5TGlzdDxDOHlTdGVwcGVySWNvbj47XG5cbiAgLyoqIENvbnN1bWVyLXNwZWNpZmllZCB0ZW1wbGF0ZS1yZWZzIHRvIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGhlYWRlciBpY29ucy4gKi9cbiAgX2ljb25PdmVycmlkZXM6IHsgW2tleTogc3RyaW5nXTogVGVtcGxhdGVSZWY8YW55PiB9ID0ge307XG5cbiAgcHJpdmF0ZSBfc3RlcEluZGV4OiBTdWJqZWN0PG51bWJlcj4gPSBuZXcgU3ViamVjdCgpO1xuICBwcml2YXRlIF9zdGVwSW5kZXhTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGRpcjogRGlyZWN0aW9uYWxpdHksXG4gICAgcHJpdmF0ZSBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSBlbGVtZW50UmVmPzogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICkge1xuICBzdXBlcihkaXIsIGNoYW5nZURldGVjdG9yUmVmLCBlbGVtZW50UmVmLCBkb2N1bWVudCk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgc3VwZXIubmdBZnRlckNvbnRlbnRJbml0KCk7XG4gICAgdGhpcy5faWNvbnMuZm9yRWFjaCgoeyBuYW1lLCB0ZW1wbGF0ZVJlZiB9KSA9PiAodGhpcy5faWNvbk92ZXJyaWRlc1tuYW1lXSA9IHRlbXBsYXRlUmVmKSk7XG4gICAgdGhpcy5fc3RlcEluZGV4U3Vic2NyaXB0aW9uID0gdGhpcy5fc3RlcEluZGV4LnN1YnNjcmliZShpbmRleCA9PiB0aGlzLm9uU3RlcENoYW5nZS5lbWl0KGluZGV4KSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fc3RlcEluZGV4U3Vic2NyaXB0aW9uICYmICF0aGlzLl9zdGVwSW5kZXhTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICB0aGlzLl9zdGVwSW5kZXhTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFuaXB1bGF0ZXMgdGhlIHN0YXRlIGJhc2VkIG9uIHRoZSBkaXNhYmxlZERlZmF1bHRJY29ucyBJbnB1dCgpXG4gICAqIENoYW5naW5nIGVkaXQgb3IgZG9uZSB0byBmYWxzZSB3aWxsIGNoYW5nZSB0aGUgaWNvbnMgd2l0aGluIHN0ZXAtaGVhZGVyIGJ1dHRvbnNcbiAgICogQHBhcmFtIGluZGV4IHN0ZXAgaW5kZXhcbiAgICogQHBhcmFtIHN0YXRlIHN0ZXAgc3RhdGUsIGxpa2UgJ2RvbmUnLCAnZWRpdCcsICdlcnJvcidcbiAgICovXG4gIGdldEluZGljYXRvclR5cGUoaW5kZXg6IG51bWJlciwgc3RhdGU6IFN0ZXBTdGF0ZSkge1xuICAgIGNvbnN0IHN0ZXBTdGF0ZSA9IHRoaXMuX2dldEluZGljYXRvclR5cGUoaW5kZXgsIHN0YXRlKTtcbiAgICBsZXQgX3N0YXRlID0gc3RhdGU7XG4gICAgc3dpdGNoIChzdGVwU3RhdGUpIHtcbiAgICAgIGNhc2UgU1RFUF9TVEFURS5FRElUOlxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZURlZmF1bHRJY29ucy5lZGl0KSB7XG4gICAgICAgICAgX3N0YXRlID0gU1RFUF9TVEFURS5FRElUO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFNURVBfU1RBVEUuRE9ORTpcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVEZWZhdWx0SWNvbnMuZG9uZSkge1xuICAgICAgICAgIF9zdGF0ZSA9IFNURVBfU1RBVEUuRE9ORTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfc3RhdGUgPSAnX2RvbmUnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gX3N0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1c2hzIHRoZSBzdGVwIGluZGV4IHRvIHRoZSBzdWJqZWN0XG4gICAqIEBwYXJhbSBpbmRleCBzdGVwIGluZGV4XG4gICAqL1xuICBzZXRJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5fc3RlcEluZGV4Lm5leHQoaW5kZXgpO1xuICB9XG59XG4iXX0=