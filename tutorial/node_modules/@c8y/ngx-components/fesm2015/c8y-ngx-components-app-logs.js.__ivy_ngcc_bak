import { Injectable, EventEmitter, Component, Input, Output, ViewChild, NgModule } from '@angular/core';
import { FetchClient } from '@c8y/client';
import { from, Subject, fromEvent, interval, NEVER, of } from 'rxjs';
import { flatMap, merge, debounce, scan, tap, switchMap, takeUntil, filter, finalize, catchError, delay, repeat } from 'rxjs/operators';
import { CommonModule } from '@c8y/ngx-components';
import { ButtonsModule } from 'ngx-bootstrap/buttons';

class AppLogsService {
    constructor(client) {
        this.client = client;
        this.BASE_PATH_APPLICATION = 'application/applications';
        this.header = {
            Accept: 'application/vnd.com.nsn.cumulocity.applicationLogs+json;charset=UTF-8;ver=0.9'
        };
    }
    getLogs$(appId, instanceName, params = {}) {
        const url = `${this.BASE_PATH_APPLICATION}/${appId}/logs/${instanceName}`;
        const defaultConfig = {
            headers: this.header,
            method: 'GET'
        };
        const formattedDateFrom = params.dateFrom ? this.formatDate(params.dateFrom) : null;
        const formattedDateTo = params.dateTo ? this.formatDate(params.dateTo) : null;
        const modifiedParams = Object.assign(Object.assign(Object.assign({}, params), (formattedDateFrom && { dateFrom: formattedDateFrom })), (formattedDateTo && { dateTo: formattedDateTo }));
        const config = params ? Object.assign(Object.assign({}, defaultConfig), { params: modifiedParams }) : Object.assign({}, defaultConfig);
        return from(this.client.fetch(url, config)).pipe(flatMap(res => res.json()));
    }
    formatDate(dateToFormat) {
        return new Date(dateToFormat).toISOString();
    }
}
AppLogsService.decorators = [
    { type: Injectable }
];
AppLogsService.ctorParameters = () => [
    { type: FetchClient }
];

class AppLogsAutoRefreshComponent {
    constructor(appLogsService) {
        this.appLogsService = appLogsService;
        this.cancel$ = new Subject();
        this.isAutoRefreshDisabled = false;
        this.logsToOutput = this.getEmptyLogsJson();
        this.isAutoRefreshOn = true;
        this.onNewLogs = new EventEmitter();
        this.isRealtimeEnabled = new EventEmitter();
        this.toggleState = currentState => !currentState;
    }
    set buttonsDisabled(areDisabled) {
        this.isAutoRefreshDisabled = areDisabled;
        if (areDisabled && this.isAutoRefreshOn) {
            this.isAutoRefreshOn = false;
            this.cancel$.next(false);
        }
    }
    ngAfterViewInit() {
        const clicks$ = fromEvent(this.button.nativeElement, 'click').pipe(merge(this.cancel$), debounce(() => interval(300)), scan(this.toggleState, false), tap(isAutoRefreshOn => this.setButtonState(isAutoRefreshOn)), switchMap(isOn => (isOn ? this.watchForNewLogs() : NEVER)));
        this.subscription = clicks$.subscribe();
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    setButtonState(isAutoRefreshOn) {
        this.isAutoRefreshOn = isAutoRefreshOn;
        this.isRealtimeEnabled.emit(isAutoRefreshOn);
    }
    watchForNewLogs() {
        return this.startPolling().pipe(takeUntil(this.cancel$.pipe(filter(isAutoRefreshOn => isAutoRefreshOn === false))), finalize(() => {
            this.isAutoRefreshOn = false;
        }));
    }
    startPolling() {
        return of(1).pipe(switchMap(() => this.getNewLogs().pipe(catchError(er => of(this.getEmptyLogsJson())))), tap(logs => this.updateLogsToOutput(logs)), delay(10000), repeat());
    }
    getNewLogs() {
        return this.appLogsService.getLogs$(this.getAppId(), this.getInstanceName());
    }
    getAppId() {
        return this.mo.applicationId;
    }
    getInstanceName() {
        return this.selectedInstance.name;
    }
    updateLogsToOutput(newLogs) {
        const { dateFrom, dateTo } = newLogs;
        if (dateFrom && dateTo) {
            this.logsToOutput = Object.assign({}, newLogs);
            this.onNewLogs.emit(this.logsToOutput);
        }
    }
    getEmptyLogsJson() {
        return {
            dateFrom: null,
            dateTo: null,
            logs: '',
            truncated: false
        };
    }
}
AppLogsAutoRefreshComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-app-logs-auto-refresh',
                template: "<button #autoRefresh\n  type=\"button\"\n  class=\"btn btn-link c8y-realtime\"\n  [ngStyle]=\"{'width': 'auto'}\"\n  title=\"{{'Toggle auto refresh' | translate}}\"\n  [disabled]=\"isAutoRefreshDisabled\"\n>\n  <span class=\"c8y-pulse\" [ngClass]=\"isAutoRefreshOn ? 'active' : 'inactive'\"></span>\n  {{'Auto refresh' | translate}}\n</button>"
            },] }
];
AppLogsAutoRefreshComponent.ctorParameters = () => [
    { type: AppLogsService }
];
AppLogsAutoRefreshComponent.propDecorators = {
    selectedInstance: [{ type: Input }],
    mo: [{ type: Input }],
    buttonsDisabled: [{ type: Input }],
    onNewLogs: [{ type: Output }],
    isRealtimeEnabled: [{ type: Output }],
    button: [{ type: ViewChild, args: ['autoRefresh', { static: true },] }]
};

class AppLogsAutoRefreshModule {
}
AppLogsAutoRefreshModule.decorators = [
    { type: NgModule, args: [{
                declarations: [AppLogsAutoRefreshComponent],
                exports: [AppLogsAutoRefreshComponent],
                imports: [CommonModule, ButtonsModule],
                entryComponents: [AppLogsAutoRefreshComponent],
                providers: [AppLogsService]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { AppLogsAutoRefreshComponent, AppLogsAutoRefreshModule, AppLogsService };
//# sourceMappingURL=c8y-ngx-components-app-logs.js.map
