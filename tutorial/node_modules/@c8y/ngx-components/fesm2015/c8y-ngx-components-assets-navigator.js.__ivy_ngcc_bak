import { __awaiter, __rest } from 'tslib';
import * as i4 from '@c8y/ngx-components';
import { NavigatorNode, gettext, DeviceStatusComponent, ModalService, AlertService, BreadcrumbService, AppStateService, ModalModule, DeviceStatusModule, HOOK_NAVIGATOR_NODES, CommonModule } from '@c8y/ngx-components';
import { get, debounce } from 'lodash-es';
import { Subject, empty } from 'rxjs';
import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Optional, Inject, NgModule, EventEmitter, Component, Input, Output, ChangeDetectorRef } from '@angular/core';
import { QueriesUtil, InventoryService, UserService } from '@c8y/client';
import * as i3 from '@c8y/ngx-components/api';
import { ApiService } from '@c8y/ngx-components/api';
import { filter, mergeMap, takeUntil } from 'rxjs/operators';
import * as i1 from '@c8y/client';
import * as i5 from '@c8y/client';
import { CollapseModule } from 'ngx-bootstrap/collapse';
import { BsDropdownModule } from 'ngx-bootstrap/dropdown';
import { TranslateService } from '@ngx-translate/core';

var Action;
(function (Action) {
    Action[Action["FETCH"] = 0] = "FETCH";
    Action[Action["NEXT"] = 1] = "NEXT";
    Action[Action["REFRESH"] = 2] = "REFRESH";
    Action[Action["LOADING_DONE"] = 3] = "LOADING_DONE";
})(Action || (Action = {}));

var GroupFragment;
(function (GroupFragment) {
    GroupFragment["groupType"] = "c8y_DeviceGroup";
    GroupFragment["subGroupType"] = "c8y_DeviceSubgroup";
    GroupFragment["groupFragmentType"] = "c8y_IsDeviceGroup";
    GroupFragment["dataBrokerSourceFragment"] = "c8y_BrokerSource";
    GroupFragment["dynamicGroupType"] = "c8y_DynamicGroup";
    GroupFragment["dynamicGroupFragment"] = "c8y_IsDynamicGroup";
    GroupFragment["dynamicGroupColumnConfig"] = "c8y_UIDeviceFilterConfig";
    GroupFragment["dynamicGroupQueryString"] = "c8y_DeviceQueryString";
})(GroupFragment || (GroupFragment = {}));

class LoadMoreNode extends NavigatorNode {
    constructor() {
        super();
        this.label = gettext('Load more');
        this.icon = 'plus';
        this.droppable = true;
        this.priority = -Infinity;
    }
}

class AssetNode extends NavigatorNode {
    constructor(service, config = {}) {
        super(config);
        this.service = service;
        this.config = config;
        this.root = this.root || false;
        this.mo = this.mo || {};
        this.path = this.getPath();
        this.draggable = !this.service.moduleConfig.disableDragAndDrop && !this.root;
        this.droppable =
            !this.service.moduleConfig.disableDragAndDrop && !this.isDeviceOrProbablyChildDevice;
        this.routerLinkExact = this.root;
        this.updateIcon(false);
        this.onUpdateSubscription = this.service
            .onUpdate(this)
            .subscribe(({ data, method }) => this.refresh(data, method));
        this.setLabel();
        this.iconComponent = this.isDeviceOrProbablyChildDevice ? DeviceStatusComponent : undefined;
    }
    get hasChildren() {
        return this.root || this.service.groups.isGroup(this.mo);
    }
    get isDevice() {
        return !!this.mo.c8y_IsDevice;
    }
    get isDeviceOrProbablyChildDevice() {
        return this.isDevice || this.isNeitherDeviceOrGroup;
    }
    get isNeitherDeviceOrGroup() {
        const { isGroup, isDynamicGroup } = this.service.groups;
        return !isGroup(this.mo) && !isDynamicGroup(this.mo) && !this.isDevice && !this.root;
    }
    getPath() {
        if (this.config.path) {
            return this.config.path;
        }
        return this.root
            ? 'group'
            : this.isDeviceOrProbablyChildDevice
                ? `device/${this.mo.id}`
                : `group/${this.mo.id}`;
    }
    openOnStart(url) {
        const urlRegex = /^\/group\//;
        if (this.root) {
            if (this.service.moduleConfig.openOnStart || urlRegex.test(url)) {
                return true;
            }
        }
        const matches = url.match(/\/(group)\/(\d+)/);
        let isMatch = false;
        if (matches) {
            const id = matches[2];
            isMatch = []
                .concat(get(this.mo, 'childAssets.references', []))
                .some(({ managedObject }) => managedObject.id === id);
            return isMatch;
        }
        return false;
    }
    refresh(mo = {}, method = 'GET') {
        if (mo.id === this.mo.id) {
            this.mo = mo;
            this.setLabel();
        }
        else if (method === 'DELETE') {
            this.parents.forEach((node) => node.refresh());
            return;
        }
        if (this.events) {
            this.events.next(Action.REFRESH);
        }
    }
    setLabel() {
        this.label = this.config.label || (this.root && gettext('Groups')) || this.mo.name || '--';
    }
    click(options = {}) {
        if (this.isDeviceOrProbablyChildDevice) {
            this.service.preferBreadcrumb(this.parents);
            return;
        }
        this.hookEvents();
        this.updateIcon(options.open);
        if (options.open) {
            this.events.next(Action.FETCH);
        }
    }
    sort() {
        this.children.sort((a, b) => {
            if (a.priority > b.priority) {
                return -1;
            }
            else if (a.priority < b.priority) {
                return 1;
            }
            else {
                return 0;
            }
        });
    }
    addManagedObject(mo) {
        const { childAdditions } = this.mo;
        if (!this.isChildAddition(childAdditions, mo)) {
            this.add(this.service.createChildNode(mo));
        }
    }
    isChildAddition(childAdditions, mo) {
        return (childAdditions && childAdditions.references.some(({ managedObject: { id } }) => id === mo.id));
    }
    destroy() {
        this.onUpdateSubscription.unsubscribe();
    }
    get canDrop() {
        const nodeToMove = this.service.draggedData;
        if (nodeToMove) {
            const shouldGetChildOfItsOwn = !!nodeToMove.find(child => child === this);
            const isAlreadyChild = this.children.some(child => child.mo && child.mo.id === nodeToMove.mo.id);
            const preventMove = this === nodeToMove || shouldGetChildOfItsOwn || isAlreadyChild;
            return this.droppable && !preventMove;
        }
        return this.droppable;
    }
    dragStart($event) {
        super.dragStart($event);
        this.service.draggedData = this;
        this.service.rootNode.droppable = !this.isDeviceOrProbablyChildDevice;
    }
    dragEnd($event) {
        super.dragEnd($event);
    }
    drop($event) {
        const _super = Object.create(null, {
            drop: { get: () => super.drop }
        });
        return __awaiter(this, void 0, void 0, function* () {
            _super.drop.call(this, $event);
            const nodeToMove = this.service.draggedData;
            if (this.canDrop) {
                yield this.moveNode(nodeToMove);
            }
            else {
                this.draggedHover = false;
                this.service.draggedData = undefined;
            }
        });
    }
    hookEvents() {
        if (!this.events) {
            this.events = new Subject();
            this.events.subscribe(evt => {
                if (!this.loading) {
                    this.handleEvent(evt);
                }
            });
        }
    }
    fetch() {
        return this.root ? this.service.getRootNodes() : this.service.getGroupItems(this.mo.id);
    }
    handleEvent(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.children.length && evt === Action.FETCH) {
                this.loading = true;
                this.addNodes(yield this.fetch());
                this.loading = false;
            }
            else if (evt === Action.NEXT) {
                this.loadMoreNode.loading = true;
                this.addNodes(yield this.paging.next());
                this.loadMoreNode.loading = false;
            }
            else if (evt === Action.REFRESH) {
                this.loading = false;
                this.paging = undefined;
                this.loadMoreNode = undefined;
                this.empty();
                this.events.next(Action.FETCH);
            }
        });
    }
    addNodes(res) {
        if (res.paging) {
            const { currentPage, nextPage, pageSize } = (this.paging = res.paging);
            if (currentPage === 1) {
                this.empty();
            }
            const itemsCount = res.data.length;
            const moreItemsAvailable = !!nextPage && itemsCount === pageSize;
            this.toggleLoadMore(moreItemsAvailable);
        }
        (res.data || res).map(mo => this.addManagedObject(mo));
        this.events.next(Action.LOADING_DONE);
    }
    toggleLoadMore(show) {
        if (!this.loadMoreNode && show) {
            this.loadMoreNode = new LoadMoreNode();
            this.add(this.loadMoreNode);
            this.loadMoreNode.click = debounce(() => this.events.next(Action.NEXT), 300, { leading: true, trailing: false });
        }
        if (this.loadMoreNode) {
            this.loadMoreNode.hidden = !show;
        }
    }
    moveNode(nodeToMove) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const isCopy = yield this.showDropConfirm(nodeToMove);
                yield this.verifyNodeAccess(nodeToMove);
                yield this.addMovedNode(nodeToMove);
                if (!isCopy) {
                    yield this.removeMovedNode(nodeToMove);
                }
                this.expand();
            }
            catch (ex) {
                if (ex) {
                    this.service.alert.addServerFailure(ex);
                }
            }
            finally {
                this.draggedHover = false;
                this.service.draggedData = undefined;
            }
        });
    }
    showDropConfirm(nodeToMove) {
        return __awaiter(this, void 0, void 0, function* () {
            this.confirm.title = gettext('Move');
            this.confirm.message = gettext('Do you want to move the group?');
            const buttons = [
                {
                    label: gettext('Cancel'),
                    action: () => Promise.reject()
                },
                {
                    label: gettext('Move'),
                    status: 'default',
                    action: () => Promise.resolve(false)
                }
            ];
            if (nodeToMove.isDeviceOrProbablyChildDevice) {
                this.confirm.title = gettext('Move or add');
                this.confirm.message = gettext('Do you want to move or add the device?');
                buttons.push({
                    label: gettext('Add'),
                    status: 'primary',
                    action: () => Promise.resolve(true)
                });
            }
            return this.confirm.show(buttons);
        });
    }
    verifyNodeAccess(nodeToMove) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.inventory.update({ id: nodeToMove.mo.id });
        });
    }
    addMovedNode(nodeToMove) {
        return __awaiter(this, void 0, void 0, function* () {
            let mo;
            if (this.root) {
                const { data } = yield this.service.inventory.update({
                    id: nodeToMove.mo.id,
                    type: GroupFragment.groupType
                });
                mo = data;
            }
            else {
                const { data } = yield this.service.inventory.childAssetsAdd(nodeToMove.mo, this.mo);
                mo = data;
            }
            this.addManagedObject(mo);
        });
    }
    removeMovedNode(nodeToMove) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const parent of nodeToMove.parents) {
                if (parent.mo && parent.mo.type === GroupFragment.dynamicGroupType) {
                    break; // smart groups don't need to be changed
                }
                if (parent.root) {
                    yield this.service.inventory.update({
                        id: nodeToMove.mo.id,
                        type: GroupFragment.subGroupType
                    });
                }
                else {
                    yield this.service.inventory.childAssetsRemove(nodeToMove.mo, parent.mo);
                }
                parent.remove(nodeToMove);
            }
        });
    }
    updateIcon(open) {
        const { icon, iconOpen } = this.config;
        if (icon && iconOpen) {
            this.icon = open ? icon : iconOpen;
        }
        else {
            this.icon = this.service.groups.icon(
            // if it's root we are going to pass a fake mo to get the same icon as groups
            this.root ? { type: GroupFragment.groupType } : this.mo, open);
        }
    }
}

class DynamicGroupNode extends AssetNode {
    constructor(service, config = {}) {
        super(service, config);
        this.service = service;
        this.draggable = false;
        this.droppable = false;
    }
    get hasChildren() {
        return true;
    }
    get query() {
        return this.mo.c8y_DeviceQueryString;
    }
    fetch() {
        return this.service.getDynamicGroupItems(this.query);
    }
}

const ASSET_NAVIGATOR_CONFIG = new InjectionToken('AssetNodeConfig');

class DeviceGroupService {
    constructor() {
        this.icons = {
            brokerSourceInactive: {
                icon: 'c8y-group-remote-inactive'
            },
            brokerSource: {
                icon: 'c8y-group-remote',
                iconOpen: 'c8y-group-remote-open'
            },
            group: {
                icon: 'c8y-group',
                iconOpen: 'c8y-group-open'
            },
            dynamicGroup: {
                icon: 'c8y-group-smart',
                iconOpen: 'c8y-group-smart-open'
            },
            other: {
                icon: 'circle',
                iconClass: 'statusUnknown'
            }
        };
        this.dataBrokerSourceFragmentInactive = `_${GroupFragment.dataBrokerSourceFragment}`;
    }
    isGroup(mo) {
        return (!!mo[GroupFragment.groupFragmentType] ||
            mo.type === GroupFragment.groupType ||
            mo.type === GroupFragment.subGroupType);
    }
    isDynamicGroup(mo) {
        return !!mo[GroupFragment.dynamicGroupFragment] || mo.type === GroupFragment.dynamicGroupType;
    }
    isDataBroker(mo) {
        return (!!mo[GroupFragment.dataBrokerSourceFragment] || !!mo[this.dataBrokerSourceFragmentInactive]);
    }
    isDataBrokerActive(mo) {
        return (!!mo[GroupFragment.dataBrokerSourceFragment] && !mo[this.dataBrokerSourceFragmentInactive]);
    }
    isDevice(mo) {
        return !!mo.c8y_IsDevice;
    }
    icon(mo, open = false) {
        let type = 'other';
        if (this.isDynamicGroup(mo)) {
            type = 'dynamicGroup';
        }
        else if (this.isDataBrokerActive(mo)) {
            type = 'brokerSource';
        }
        else if (this.isDataBroker(mo)) {
            type = 'brokerSourceInactive';
        }
        else if (this.isGroup(mo)) {
            type = 'group';
        }
        const icon = this.icons[type];
        return (open && icon.iconOpen) || icon.icon;
    }
    isAnyGroup(mo) {
        return (this.isGroup(mo) ||
            this.isDynamicGroup(mo) ||
            this.isDataBroker(mo) ||
            this.isDataBrokerActive(mo));
    }
}
DeviceGroupService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DeviceGroupService_Factory() { return new DeviceGroupService(); }, token: DeviceGroupService, providedIn: "root" });
DeviceGroupService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];

class AssetNodeService {
    constructor(inventory, groups, apiService, modal, alert, breadcrumbService, user, appState, moduleConfig) {
        this.inventory = inventory;
        this.groups = groups;
        this.apiService = apiService;
        this.modal = modal;
        this.alert = alert;
        this.breadcrumbService = breadcrumbService;
        this.user = user;
        this.appState = appState;
        this.moduleConfig = moduleConfig;
        this.firstUrl = true;
        this.PAGE_SIZE = 20;
        this.moduleConfig = Object.assign({ rootNodePriority: 2000 }, (moduleConfig || {}));
        this.queriesUtil = new QueriesUtil();
    }
    createRootNode(config = {}) {
        this.rootNode = this.createAssetNode(Object.assign(Object.assign({ root: true }, config), { priority: this.moduleConfig.rootNodePriority }));
        return this.rootNode;
    }
    createDynamicGroupNode(config) {
        return new DynamicGroupNode(this, config);
    }
    createAssetNode(config) {
        return new AssetNode(this, config);
    }
    createChildNode(managedObject) {
        const { type } = managedObject;
        const config = { mo: managedObject };
        if (type === GroupFragment.dynamicGroupType) {
            return this.createDynamicGroupNode(config);
        }
        return this.createAssetNode(config);
    }
    getRootNodes(customFilter) {
        const defaultFilter = {
            pageSize: this.PAGE_SIZE,
            withChildren: false,
            query: this.queriesUtil.buildQuery(this.navRootQueryFilter())
        };
        const groupFilter = customFilter ? customFilter : defaultFilter;
        // due to BE performance limitations we do not allow filtering and sorting for a user without inventory roles
        if (!this.user.hasRole(this.appState.currentUser.value, 'ROLE_INVENTORY_READ')) {
            delete groupFilter.query;
            Object.assign(groupFilter, {
                fragmentType: GroupFragment.groupFragmentType,
                onlyRoots: true
            });
        }
        return this.inventory.list(this.createFilter(groupFilter));
    }
    getGroupItems(moId, extraFilter = {}) {
        const queryFilter = {
            withChildren: false,
            pageSize: this.PAGE_SIZE,
            query: this.groupQueryFilter(moId)
        };
        return this.inventory.childAssetsList(moId, Object.assign(Object.assign({}, queryFilter), extraFilter));
    }
    getDynamicGroupItems(groupQuery, filterObj = {}) {
        const { query } = filterObj, queryParams = __rest(filterObj, ["query"]);
        const orderByQuery = query;
        const queryFilter = Object.assign({ q: this.buildCombinedQuery(groupQuery, orderByQuery) }, queryParams);
        return this.inventory.list(this.createFilter(queryFilter));
    }
    getDeviceChildren(moId, extraFilter = {}) {
        const queryFilter = {
            withChildren: false,
            pageSize: this.PAGE_SIZE,
            query: this.groupQueryFilter(moId)
        };
        return this.inventory.childDevicesList(moId, Object.assign(Object.assign({}, queryFilter), extraFilter));
    }
    groupQueryFilter(moId) {
        return `$filter=(bygroupid(${moId}))$orderby=name`;
    }
    navRootQueryFilter() {
        const navRootFilter = this.rootQueryFilter();
        navRootFilter.__orderby = [{ name: 1 }];
        return navRootFilter;
    }
    rootQueryFilter() {
        const { moduleConfig } = this;
        const rootFilter = {
            __filter: {
                type: `${GroupFragment.groupType}`
            },
            __orderby: []
        };
        if (moduleConfig.smartGroups) {
            const queryFilter = {
                __filter: {
                    __and: [
                        {
                            type: `${GroupFragment.dynamicGroupType}`
                        },
                        {
                            __has: `${GroupFragment.dynamicGroupFragment}`
                        },
                        { __not: { __has: `${GroupFragment.dynamicGroupFragment}.invisible` } }
                    ]
                }
            };
            this.queriesUtil.addOrFilter(rootFilter, queryFilter);
        }
        return rootFilter;
    }
    onUpdate({ mo, root }) {
        if (mo.id) {
            return this.apiService
                .hookResponse(({ url, method }) => ['PUT', 'DELETE', 'POST'].includes(method) &&
                RegExp(`((inventory/managedObjects)|(service/smartgroup/smartgroups))/${mo.id}`).test(url))
                .pipe(filter(() => !this.draggedData), mergeMap(this.apiService.resolveData), filter(response => !response.data.c8y_Dashboard));
        }
        else if (root) {
            return this.apiService
                .hookResponse(({ url, method }) => RegExp('((inventory/managedObjects)|(service/smartgroup/smartgroups))/?$').test(url) &&
                method === 'POST')
                .pipe(mergeMap(this.apiService.resolveData), filter(response => this.isNewManagedObjectRoot(response)));
        }
        else {
            return empty();
        }
    }
    isNewManagedObjectRoot(response = {}) {
        const { data } = response;
        let isRootAsset = false;
        if (typeof data === 'object') {
            isRootAsset = !!data[GroupFragment.groupFragmentType];
            if (!isRootAsset && this.moduleConfig.smartGroups) {
                isRootAsset = !!data[GroupFragment.dynamicGroupFragment];
            }
        }
        return isRootAsset;
    }
    /**
     * There could be multiple breadcrumbs for devices,
     * so we set a preferred one on click on a device.
     * @param parents The parent nodes of the device to select the prefered one.
     */
    preferBreadcrumb(parents) {
        if (parents.length === 1) {
            this.breadcrumbService.selectPreferredByPath(parents[0].path);
        }
    }
    createFilter(extraParams = {}) {
        const params = {
            currentPage: 1,
            withTotalPages: true,
            pageSize: 10
        };
        return Object.assign(Object.assign({}, params), extraParams);
    }
    buildCombinedQuery(query, orderByQuery) {
        let combinedQuery;
        if (query && orderByQuery) {
            const filterQuery = this.queriesUtil.buildQuery({
                __useFilterQueryString: query
            });
            combinedQuery = `${filterQuery} ${orderByQuery}`;
        }
        else {
            combinedQuery = query || orderByQuery || '';
        }
        return combinedQuery;
    }
}
AssetNodeService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AssetNodeService_Factory() { return new AssetNodeService(i0.ɵɵinject(i1.InventoryService), i0.ɵɵinject(DeviceGroupService), i0.ɵɵinject(i3.ApiService), i0.ɵɵinject(i4.ModalService), i0.ɵɵinject(i4.AlertService), i0.ɵɵinject(i4.BreadcrumbService), i0.ɵɵinject(i5.UserService), i0.ɵɵinject(i4.AppStateService), i0.ɵɵinject(ASSET_NAVIGATOR_CONFIG, 8)); }, token: AssetNodeService, providedIn: "root" });
AssetNodeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
AssetNodeService.ctorParameters = () => [
    { type: InventoryService },
    { type: DeviceGroupService },
    { type: ApiService },
    { type: ModalService },
    { type: AlertService },
    { type: BreadcrumbService },
    { type: UserService },
    { type: AppStateService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ASSET_NAVIGATOR_CONFIG,] }] }
];

class AssetNodeFactory {
    constructor(service, moduleConfig) {
        this.service = service;
        this.moduleConfig = moduleConfig;
    }
    get() {
        var _a;
        const rootNavigatorNode = (_a = get(this.moduleConfig, 'rootNavigatorNode')) !== null && _a !== void 0 ? _a : true;
        if (rootNavigatorNode === false) {
            return;
        }
        if (!this.service.rootNode) {
            this.service.createRootNode(rootNavigatorNode === true ? {} : rootNavigatorNode);
        }
        return this.service.rootNode;
    }
}
AssetNodeFactory.decorators = [
    { type: Injectable }
];
AssetNodeFactory.ctorParameters = () => [
    { type: AssetNodeService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ASSET_NAVIGATOR_CONFIG,] }] }
];

class AssetsNavigatorModule {
    static config(config = {}) {
        return {
            ngModule: AssetsNavigatorModule,
            providers: [
                {
                    provide: ASSET_NAVIGATOR_CONFIG,
                    useValue: config
                }
            ]
        };
    }
}
AssetsNavigatorModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [ModalModule, DeviceStatusModule],
                providers: [
                    ModalService,
                    DeviceGroupService,
                    {
                        provide: HOOK_NAVIGATOR_NODES,
                        useClass: AssetNodeFactory,
                        multi: true
                    }
                ],
                entryComponents: [DeviceStatusComponent]
            },] }
];

class GroupNode extends AssetNode {
    // FIXME: Currently hasChildren returns true if it is a group,
    //        Issue is, that we disable the children in the API
    //        getGroupItems service call due to performance. This leads
    //        to that the dropdown chevron is shown always. Issue is,
    //        that even if we return the chevrons, we have no way to determine
    //        if the childAssets contain groups or other assets (like dashboards).
    // get hasChildren() {
    //  return this.root || this.service.groups.isGroup(this.mo) && (this.mo as IManagedObject).childAssets.references.length > 0;
    // }
    /**
     * Creates a new node which shows only groups.
     *
     * @param service The service to use.
     * @param config  The default configuration of the node.
     */
    constructor(service, config = {}) {
        super(service, config);
        this.service = service;
    }
}

class GroupNodeService extends AssetNodeService {
    constructor() {
        super(...arguments);
        this.PAGE_SIZE = 5;
    }
    createGroupNode(config) {
        return new GroupNode(this, config);
    }
    createChildNode(managedObject) {
        const config = { mo: managedObject };
        return this.createGroupNode(config);
    }
    subAssetsQueryFilter() {
        const rootQueryFilter = this.rootQueryFilter();
        const filter = this.queriesUtil.addOrFilter(rootQueryFilter, {
            type: GroupFragment.subGroupType
        });
        return this.queriesUtil.buildQuery(filter);
    }
    getGroupItems(moId) {
        return this.inventory.childAssetsList(moId, {
            query: this.subAssetsQueryFilter(),
            withChildren: false,
            pageSize: this.PAGE_SIZE,
            withTotalPages: true
        });
    }
}
GroupNodeService.decorators = [
    { type: Injectable }
];

/**
 * Displays a hierarchical tree selector for assets.
 */
class AssetSelectorComponent {
    /**
     * @ignore only DI
     */
    constructor(groupNodeService) {
        this.groupNodeService = groupNodeService;
        /**
         * An array of predefined nodes.
         */
        this.selected = [];
        /**
         * Emits if one item was selected (all currently selected nodes).
         */
        this.onChange = new EventEmitter();
    }
    /**
     * @ignore
     */
    ngOnInit() {
        this.rootNode = this.groupNodeService.createGroupNode({ root: true });
    }
    /**
     * Adds an managed object to the selected array and emits the change.
     * @param selectedMo The selected asset.
     */
    select(selectedMo) {
        const index = this.getIndexOfSelected(this.selected, selectedMo);
        if (index === -1) {
            this.selected.push(selectedMo);
        }
        this.onChange.emit(this.selected);
    }
    /**
     * Removes a managed object from the selected array and emits the change.
     * @param selectedMo The selected asset.
     */
    deselect(selectedMo) {
        const index = this.getIndexOfSelected(this.selected, selectedMo);
        if (index > -1) {
            this.selected.splice(index, 1);
        }
        this.onChange.emit(this.selected);
    }
    getIndexOfSelected(selected, selectedMo) {
        return selected.findIndex(mo => mo.id === selectedMo.id);
    }
}
AssetSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-asset-selector',
                template: "<c8y-asset-selector-node [node]=\"rootNode\" [preselected]=\"selected\"></c8y-asset-selector-node>\n"
            },] }
];
AssetSelectorComponent.ctorParameters = () => [
    { type: GroupNodeService }
];
AssetSelectorComponent.propDecorators = {
    selected: [{ type: Input }],
    onChange: [{ type: Output }]
};

class AssetSelectorNodeComponent {
    /**
     * @ignore only di
     */
    constructor(translateService, cd, parentNode) {
        this.translateService = translateService;
        this.cd = cd;
        this.parentNode = parentNode;
        /**
         * All preselected items
         */
        this.preselected = [];
        /**
         *  Should the path be shown
         */
        this.showPath = false;
        /**
         * @ignore
         */
        this.level = 0;
        /**
         * The selection status of the node
         */
        this.checked = false;
        /**
         * @ignore
         */
        this.unsubscribe$ = new Subject();
    }
    /**
     * @ignore
     */
    get expandTitle() {
        return !this.node.open ? gettext('Expand') : gettext('Collapse');
    }
    /**
     * @ignore
     */
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.breadcrumb = this.node.label;
            this.setupBreadcrumbsAndLevel(this.node);
            if (this.node instanceof GroupNode) {
                this.node.hookEvents();
            }
            // open on startup
            if (this.node.root) {
                this.click();
            }
            if (this.node.events) {
                this.node.events
                    .pipe(takeUntil(this.unsubscribe$), filter((a) => a === Action.LOADING_DONE))
                    .subscribe(() => {
                    this.cd.markForCheck();
                });
            }
            this.checked = this.isPreselected();
        });
    }
    /**
     * Opens a node.
     */
    click() {
        this.node.open = !this.node.open;
        this.node.click({ open: this.node.open });
    }
    /**
     * TODO: Only level used. Breadcrumbs needs to be implemented.
     */
    setupBreadcrumbsAndLevel(node) {
        if (node.parents && node.parents.length) {
            const parent = node.parents[0];
            this.breadcrumb = this.translateService.instant(parent.label) + ' > ' + this.breadcrumb;
            this.level++;
            this.setupBreadcrumbsAndLevel(parent);
        }
    }
    /**
     * Selects the node and emits a change on the parent component.
     * @param node The node to select.
     */
    selected(node) {
        this.checked = !this.checked;
        this.updateSelection(node.mo);
    }
    /**
     * @ignore
     */
    ngOnDestroy() {
        this.unsubscribe$.next(true);
        this.unsubscribe$.complete();
    }
    isPreselected() {
        if (this.node.root || !this.node.mo) {
            return false;
        }
        return this.parentNode.getIndexOfSelected(this.preselected, this.node.mo) > -1;
    }
    updateSelection(selectedMo) {
        if (this.checked) {
            this.parentNode.select(selectedMo);
            return;
        }
        this.parentNode.deselect(selectedMo);
    }
}
AssetSelectorNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-asset-selector-node',
                template: "<div\n  class=\"d-flex collapsible\"\n  [ngClass]=\"{ 'expanded separator-top': node.open }\"\n  title=\"{{ breadcrumb | translate }}\"\n  *ngIf=\"!node.root && !node.hidden\"\n>\n  <div\n    class=\"p-t-8 p-b-8 m-r-8\"\n    [ngStyle]=\"{ 'padding-left': level < 6 ? (level - 1) * 8 + 'px' : '24px' }\"\n    [style.visibility]=\"node.routerLinkExact ? 'hidden' : 'visible'\"\n  >\n    <label class=\"c8y-checkbox\">\n      <input type=\"checkbox\" (change)=\"selected(node)\" [checked]=\"checked\" />\n      <span></span>\n    </label>\n  </div>\n  <div\n    class=\"flex-grow flex-item-middle p-t-8 p-b-8 text-truncate p-r-8\"\n    [style.cursor]=\"node.routerLinkExact ? 'pointer' : 'normal'\"\n    (click)=\"node.routerLinkExact ? node.click() : ''\"\n  >\n    <i\n      [c8yIcon]=\"node.icon\"\n      *ngIf=\"node.icon === 'c8y-group-smart'\"\n      [title]=\"'Smart group' | translate\"\n      class=\"c8y-icon c8y-icon-duocolor m-r-4 text-16\"\n    ></i>\n    <i\n      [c8yIcon]=\"node.icon\"\n      *ngIf=\"node.icon !== 'c8y-group-smart'\"\n      [title]=\"'Group' | translate\"\n      class=\"c8y-icon c8y-icon-duocolor m-r-4 text-16\"\n    ></i>\n    <span title=\"{{ breadcrumb }}\">\n      {{ node.label | translate }}\n      <!-- use just for search results to display the path -->\n      <p *ngIf=\"showPath\" class=\"text-truncate\">\n        <small class=\"text-muted\" title=\"{{ breadcrumb }}\">\n          <em>{{ breadcrumb }}</em>\n        </small>\n      </p>\n      <!-- up to here -->\n    </span>\n  </div>\n  <div>\n    <button\n      [title]=\"expandTitle\"\n      class=\"collapse-btn btn\"\n      (click)=\"click()\"\n      [attr.aria-expanded]=\"!node.open\"\n    >\n      <i c8yIcon=\"angle-down\" [ngClass]=\"{ 'text-primary': node.open }\"></i>\n    </button>\n  </div>\n</div>\n<div class=\"collapse\" [ngClass]=\"{ 'separator-bottom': node.open }\" [collapse]=\"!node.open\">\n  <c8y-asset-selector-node\n    *ngFor=\"let childNode of node.children\"\n    [node]=\"childNode\"\n    [preselected]=\"preselected || []\"\n  ></c8y-asset-selector-node>\n</div>\n"
            },] }
];
AssetSelectorNodeComponent.ctorParameters = () => [
    { type: TranslateService },
    { type: ChangeDetectorRef },
    { type: AssetSelectorComponent }
];
AssetSelectorNodeComponent.propDecorators = {
    node: [{ type: Input }],
    preselected: [{ type: Input }],
    showPath: [{ type: Input }]
};

class AssetSelectorModule {
}
AssetSelectorModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, CollapseModule, BsDropdownModule],
                exports: [AssetSelectorNodeComponent, AssetSelectorComponent],
                providers: [GroupNodeService],
                declarations: [AssetSelectorNodeComponent, AssetSelectorComponent]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { ASSET_NAVIGATOR_CONFIG, Action, AssetNode, AssetNodeFactory, AssetNodeService, AssetSelectorComponent, AssetSelectorModule, AssetSelectorNodeComponent, AssetsNavigatorModule, DeviceGroupService, DynamicGroupNode, GroupFragment, GroupNode, GroupNodeService, LoadMoreNode };
//# sourceMappingURL=c8y-ngx-components-assets-navigator.js.map
