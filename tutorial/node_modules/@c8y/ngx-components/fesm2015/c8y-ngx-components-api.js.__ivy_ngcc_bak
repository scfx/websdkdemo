import { __awaiter } from 'tslib';
import * as i0 from '@angular/core';
import { Injectable, NgModule } from '@angular/core';
import { FetchClient, BasicAuth, CookieAuth, Realtime, EventBinaryService, EventService, InventoryService, MeasurementService, AlarmService, OperationBulkService, OperationService, ApplicationService, UserService, TenantService, SystemOptionsService, TenantOptionsService, TenantSecurityOptionsService, TenantLoginOptionsService, AuditService, InventoryRoleService, InventoryBinaryService, DeviceRegistrationService, DeviceRegistrationBulkService, UserRoleService, UserGroupService, IdentityService, TrustedCertificateService, SmartGroupsService, SmartRulesService } from '@c8y/client';
export { AlarmService, ApplicationService, AuditService, BasicAuth, CookieAuth, DeviceRegistrationBulkService, DeviceRegistrationService, EventBinaryService, EventService, FetchClient, IdentityService, InventoryBinaryService, InventoryRoleService, InventoryService, MeasurementService, OperationBulkService, OperationService, Realtime, SmartGroupsService, SmartRulesService, SystemOptionsService, TenantLoginOptionsService, TenantOptionsService, TenantSecurityOptionsService, TenantService, TrustedCertificateService, UserGroupService, UserRoleService, UserService } from '@c8y/client';
import { Subject } from 'rxjs';
import { filter } from 'rxjs/operators';
import * as i1 from '@c8y/client';

class ApiService {
    constructor(client) {
        this.client = client;
        this.callsSubject = new Subject();
        this.calls = this.callsSubject.asObservable();
        this.hookIntoClientFetch();
    }
    hookResponse(hookFilter) {
        return this.callsSubject.pipe(filter(({ phase }) => phase === 'finish'), filter(hookFilter));
    }
    hookRequest(hookFilter) {
        return this.callsSubject.pipe(filter(({ phase }) => phase === 'start'), filter(hookFilter));
    }
    onFinish(call) {
        return __awaiter(this, void 0, void 0, function* () {
            this.callsSubject.next(Object.assign({ phase: 'finish' }, call));
        });
    }
    onStart(call) {
        this.callsSubject.next(Object.assign({ phase: 'start' }, call));
    }
    resolveData(call) {
        return __awaiter(this, void 0, void 0, function* () {
            const { response, method } = call;
            if ('data' in response) {
                return Promise.resolve({ data: response.data, method });
            }
            else {
                const cb = (data) => ({ data, method });
                return response.clone().json().then(cb, cb);
            }
        });
    }
    hookIntoClientFetch() {
        const fetch = this.client.fetch.bind(this.client);
        this.client.fetch = (url, options = { method: 'GET' }) => __awaiter(this, void 0, void 0, function* () {
            const { method } = options;
            this.onStart({ options, method, url });
            let fetchPromise = fetch(url, options);
            if (typeof options.responseInterceptor === 'function') {
                fetchPromise = fetchPromise.then(options.responseInterceptor);
            }
            fetchPromise.then((response) => this.onFinish({ response, url, options, method }), (response) => this.onFinish({ response, url, options, method }));
            return fetchPromise;
        });
    }
}
ApiService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ApiService_Factory() { return new ApiService(i0.ɵɵinject(i1.FetchClient)); }, token: ApiService, providedIn: "root" });
ApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ApiService.ctorParameters = () => [
    { type: FetchClient }
];

var services = /*#__PURE__*/Object.freeze({
    __proto__: null,
    FetchClient: FetchClient,
    BasicAuth: BasicAuth,
    CookieAuth: CookieAuth,
    Realtime: Realtime,
    EventBinaryService: EventBinaryService,
    EventService: EventService,
    InventoryService: InventoryService,
    MeasurementService: MeasurementService,
    AlarmService: AlarmService,
    OperationBulkService: OperationBulkService,
    OperationService: OperationService,
    ApplicationService: ApplicationService,
    UserService: UserService,
    TenantService: TenantService,
    SystemOptionsService: SystemOptionsService,
    TenantOptionsService: TenantOptionsService,
    TenantSecurityOptionsService: TenantSecurityOptionsService,
    TenantLoginOptionsService: TenantLoginOptionsService,
    AuditService: AuditService,
    InventoryRoleService: InventoryRoleService,
    InventoryBinaryService: InventoryBinaryService,
    DeviceRegistrationService: DeviceRegistrationService,
    DeviceRegistrationBulkService: DeviceRegistrationBulkService,
    UserRoleService: UserRoleService,
    UserGroupService: UserGroupService,
    IdentityService: IdentityService,
    TrustedCertificateService: TrustedCertificateService,
    SmartGroupsService: SmartGroupsService,
    SmartRulesService: SmartRulesService
});

function toProvider(provide) {
    let deps = [FetchClient, Realtime];
    if (provide === FetchClient) {
        deps = [CookieAuth];
    }
    if (provide === BasicAuth || provide === CookieAuth) {
        deps = [];
    }
    if (provide === Realtime) {
        deps = [FetchClient];
    }
    return { provide, useClass: provide, deps };
}
const ɵ0 = (k) => toProvider(services[k]);
const providers = Object.keys(services).map(ɵ0)
    .concat([
    { provide: ApiService, useClass: ApiService, deps: [FetchClient] }
]);
// @dynamic
class DataModule {
    static providers() {
        return providers;
    }
    static forRoot() {
        return {
            ngModule: DataModule,
            providers
        };
    }
}
DataModule.decorators = [
    { type: NgModule, args: [{
                providers
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { ApiService, DataModule, ɵ0 };
//# sourceMappingURL=c8y-ngx-components-api.js.map
