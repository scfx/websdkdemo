"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CumulocityPlugin = exports.LEGACY_MANIFEST = exports.NG1_PACKAGE = void 0;
const _ = require("lodash");
const fg = require("fast-glob");
const HtmlWebpackPlugin = require("html-webpack-plugin");
const path = require("path");
const webpack = require("webpack");
const index_content_1 = require("./index-content");
const locales_1 = require("./locales");
const webpack_sources_1 = require("webpack-sources");
const fs_1 = require("fs");
const LocaleCompiler_1 = require("../../utils/LocaleCompiler");
const PLUGIN_NAME = 'CumulocityPlugin';
exports.NG1_PACKAGE = '@c8y/ng1-modules';
exports.LEGACY_MANIFEST = '@c8y-from-manifest/';
class CumulocityPlugin {
    constructor(options = {}) {
        this.options = options;
        this.localeCompiler = new LocaleCompiler_1.LocaleCompiler();
        this.internalApps = {
            administration: 'Administration',
            cockpit: 'Cockpit',
            devicemanagement: 'Device management'
        };
        this.app = Object.assign({}, options.app);
    }
    get groupedPos() {
        return this.localeCompiler.groupedPos;
    }
    getVersion(packageJsonName) {
        try {
            const { version } = require(packageJsonName);
            return version;
        }
        catch (ex) {
            return '--';
        }
    }
    apply(compiler) {
        this.applyOtherPlugins(compiler);
        compiler.c8yPluginInstance = this;
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, compilation => this.setCompilation(compilation));
    }
    setCompilation(compilation) {
        this.compilation = compilation;
        compilation.c8yPluginInstance = this;
        compilation.hooks.additionalAssets.tapAsync(PLUGIN_NAME, callback => {
            this.createTranslationAssets(compilation);
            this.createManifest(compilation);
            callback();
        });
        this.setHtmlHook(compilation);
    }
    setHtmlHook(compilation) {
        const { afterTemplateExecution } = HtmlWebpackPlugin.getHooks(compilation);
        if (afterTemplateExecution) {
            afterTemplateExecution.tapAsync(PLUGIN_NAME, (htmlPluginData, callback) => {
                const { chunks } = compilation;
                htmlPluginData.headTags.unshift({
                    voidTag: false,
                    tagName: 'title',
                    innerHTML: this.title(),
                    attributes: {},
                    meta: {}
                });
                if (this.csp()) {
                    htmlPluginData.headTags.push({
                        voidTag: true,
                        tagName: 'meta',
                        attributes: { 'http-equiv': 'Content-Security-Policy', content: this.csp() },
                        meta: {}
                    });
                }
                const preload = Array.from(chunks).reduce((links, { name, files }) => {
                    if (name && (name.match(/app$/) || name.match(/branding$/))) {
                        return links.concat(Array.from(files).map((href) => ({
                            tagName: 'link',
                            voidTag: true,
                            attributes: {
                                rel: 'preload',
                                href,
                                as: path.extname(href) === '.css' ? 'style' : 'script'
                            },
                            meta: {}
                        })));
                    }
                    return links;
                }, []);
                htmlPluginData.headTags.push(...preload);
                const bodyOptions = this.isUpgrade() ? this.indexDataLegacy() : this.indexData();
                // tslint:disable-next-line:max-line-length
                htmlPluginData.bodyTags = [
                    this.isUpgrade() ? this.rootElementLegacy() : this.rootElement(),
                    {
                        voidTag: false,
                        tagName: 'script',
                        attributes: {
                            type: 'data',
                            id: 'static-options'
                        },
                        innerHTML: JSON.stringify(bodyOptions),
                        meta: {}
                    }
                ].concat(htmlPluginData.bodyTags);
                callback(null, htmlPluginData);
            });
        }
    }
    isUpgrade() {
        return this.app.upgrade;
    }
    rootElement() {
        return {
            voidTag: false,
            tagName: 'c8y-bootstrap',
            meta: {},
            attributes: {}
        };
    }
    rootElementLegacy() {
        return {
            voidTag: false,
            tagName: 'c8y-ui-root',
            attributes: {
                class: 'ng-cloak',
                id: 'app'
            },
            meta: {}
        };
    }
    indexDataLegacy() {
        return Object.assign({
            modules: [],
            languages: this.languages(),
            core_path: 'assets/',
            data_path: 'c8ydata'
        }, this.app);
    }
    indexData() {
        return Object.assign(Object.assign({}, this.app), { languages: this.languages(this.app.languages) });
    }
    languagesKeys() {
        return Object.keys(this.groupedPos || {}).sort();
    }
    languages(appLanguages = {}) {
        const languages = this.languagesKeys().reduce((out, lang) => {
            const slicedLang = lang.slice(0, 2);
            const data = Object.assign(Object.assign({}, (locales_1.LOCALES[lang] || locales_1.LOCALES[slicedLang])), { url: `./${lang}.json` });
            if (data) {
                return Object.assign(out, { [lang]: data });
            }
            return out;
        }, {});
        Object.keys(appLanguages).forEach(key => {
            if (appLanguages[key]) {
                languages[key] = appLanguages[key];
            }
            else {
                delete languages[key];
            }
        });
        return languages;
    }
    title() {
        return this.internalApps[this.app.name] || this.app.name;
    }
    csp() {
        return this.app.contentSecurityPolicy;
    }
    createManifest(compilation) {
        const { assets } = compilation;
        const FILE = 'cumulocity.json';
        if (this.app && !assets[FILE]) {
            assets[FILE] = new webpack_sources_1.RawSource(JSON.stringify(_.omit(this.app, 'brandingEntry', 'entryModule'), null, 2));
        }
    }
    createTranslationAssets(compilation) {
        const { assets } = compilation;
        this.localeCompiler.compile().forEach(({ language, json }) => {
            assets[`${language}.json`] = new webpack_sources_1.RawSource(json);
        });
    }
    loadPo(content, modulePath) {
        this.localeCompiler.loadPo(content, modulePath);
        return '';
    }
    async copyDefinitionToImports(copy, context) {
        let importStatements = [];
        let cwd = context;
        if (typeof copy === 'string') {
            copy = { files: [copy] };
        }
        if (!copy.webpackIgnore) {
            cwd = this.copyProcessCwd(copy.cwd, context);
            const files = await fg(copy.files, { cwd, absolute: true });
            importStatements = _.flatMap(files, file => {
                let nameOut = path.relative(cwd, file);
                if (copy.output) {
                    nameOut = path.join(copy.output, nameOut);
                }
                const targetFilePath = `./${path.relative(context, file)}`;
                return [
                    `!file-loader?name=${nameOut}!${targetFilePath}`,
                    `!file-loader?name=${path.join(path.basename(context), nameOut)}!${targetFilePath}`
                ].map(str => str.replace(/\\/g, '/'));
            });
        }
        return importStatements;
    }
    copyProcessCwd(cwd, context) {
        let cwdOut = context;
        if (cwd) {
            if (path.isAbsolute(cwd)) {
                cwdOut = cwd;
            }
            else if (/node_modules/.test(cwd)) {
                cwdOut = this.app.rootNodeModulesPath
                    ? path
                        .resolve(this.app.rootNodeModulesPath, cwd)
                        .replace(`node_modules${path.sep}node_modules`, 'node_modules')
                    : path.resolve(process.cwd(), cwd);
            }
            else {
                cwdOut = path.resolve(context, cwd);
            }
        }
        return cwdOut;
    }
    transformAppManifest(_manifest) {
        const manifest = _.cloneDeep(_manifest);
        if (manifest.imports) {
            manifest.imports = manifest.imports.map(this.transformLegacyPluginPath);
        }
        return manifest;
    }
    transformLegacyPluginPath(request) {
        return `${exports.LEGACY_MANIFEST}${request}`;
    }
    isBrandingContext(context) {
        return /(branding|@c8y\/style)$/i.test(context);
    }
    isC8yBranding(context) {
        return path.basename(context) === 'c8yBranding' || /@c8y\/style$/.test(context);
    }
    indexContent() {
        return index_content_1.default;
    }
    async findModuleFiles(cwd, extraPatterns) {
        let patterns = [
            '{**/,}*.html',
            'locales/*.po',
            '(devicecommands|properties|devicetypes|trackers)/*.json'
        ];
        if (extraPatterns) {
            patterns = patterns.concat(extraPatterns);
        }
        return fg.async(patterns, { cwd });
    }
    applyOtherPlugins(compiler) {
        return [new HtmlWebpackPlugin(this.getHtmlWebpackConfig())]
            .concat(this.replacements())
            .forEach(p => p.apply(compiler));
    }
    getHtmlWebpackConfig() {
        const config = {
            minify: this.options.mode === 'production'
        };
        if (this.options.indexTemplate) {
            config.template = this.options.indexTemplate;
        }
        else {
            config.templateContent = index_content_1.default;
        }
        return config;
    }
    /**
     * Take some prisoners, and then kill 'em all.
     * @see https://www.urbandictionary.com/define.php?term=take%20no%20prisoners
     */
    replacements() {
        const rootNodeModulesDir = path.resolve(this.app.rootNodeModulesPath || 'node_modules');
        // maybe we can remove this
        const filePath = paths => {
            let _path = path.resolve(rootNodeModulesDir, ...paths);
            // not very happy about this
            try {
                fs_1.statSync(_path);
            }
            catch (e) {
                _path = path.resolve(rootNodeModulesDir, '@c8y/ng1-modules/node_modules', ...paths);
            }
            return _path;
        };
        return [
            { pattern: /^(angular$|angular\/)/, paths: ['angular', 'index.js'] },
            { pattern: /^objectpath$/, paths: ['objectpath', 'lib', 'ObjectPath.js'] },
            { pattern: /(^tv4\/?|tv4\/)/, paths: ['tv4', 'tv4.js'] },
            { pattern: /^leaflet$/, paths: ['leaflet', 'dist', 'leaflet-src.js'] }
        ].map(({ pattern, paths }) => new webpack.NormalModuleReplacementPlugin(pattern, filePath(paths)));
    }
    filterIfUpgrade(manifest) {
        const { ignoreIfUpgrade } = manifest;
        return f => (ignoreIfUpgrade && this.isUpgrade() ? ignoreIfUpgrade.indexOf(f) === -1 : true);
    }
    getBrandingEntry(branding) {
        return branding;
    }
}
exports.CumulocityPlugin = CumulocityPlugin;
//# sourceMappingURL=plugin.js.map