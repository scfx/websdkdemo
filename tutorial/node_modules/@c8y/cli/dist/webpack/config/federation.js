"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModuleFederationExports = void 0;
const federationUtils_1 = require("../../utils/federationUtils");
const path = require("path");
function getModuleFederationExports(env) {
    let mf;
    try {
        mf = require('webpack/lib/container/ModuleFederationPlugin');
    }
    catch (ex) {
        console.warn('Could not load ModuleFederationPlugin', ex);
        return;
    }
    const shared = federationUtils_1.getSharedDependencies(env);
    if (env.app.exports) {
        return new mf({
            name: env.app.contextPath,
            library: { type: 'var', name: camelCase(env.app.contextPath) },
            filename: 'remoteEntry.js',
            exposes: getExportedModules(env),
            shared
        });
    }
    return new mf({
        remoteType: 'var',
        shared
    });
}
exports.getModuleFederationExports = getModuleFederationExports;
function camelCase(str) {
    const capitalize = (capStr) => capStr.charAt(0).toUpperCase() + capStr.toLowerCase().slice(1);
    const newString = str
        .toLowerCase()
        .replace(/[^A-Za-z0-9]/g, ' ')
        .split(' ')
        .reduce((result, word) => result + capitalize(word.toLowerCase()));
    return newString.charAt(0).toLowerCase() + newString.slice(1);
}
function getExportedModules(env) {
    return env.app.exports.map(exp => mapExports(exp, env));
}
function mapExports(exp, env) {
    const relativeEntryPath = path.resolve(env.entry.replace(process.cwd(), ''));
    let pathToExport = path.resolve(relativeEntryPath, exp.path);
    try {
        pathToExport = require.resolve(exp.path + '/index.ts');
    }
    catch (ex) {
        try {
            pathToExport = require.resolve(exp.path);
        }
        catch (ex) {
            // intended empty
        }
    }
    return { [exp.module || exp.name]: pathToExport };
}
//# sourceMappingURL=federation.js.map