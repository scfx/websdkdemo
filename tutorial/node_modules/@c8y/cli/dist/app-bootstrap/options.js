var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { forEach, get, reduce, union } from 'lodash';
let staticOptionsCache;
let urlOptionsCache;
const remoteScriptSet = new Set();
export function loadOptions() {
    return __awaiter(this, void 0, void 0, function* () {
        const urlOptions = loadUrlOptions(); // used for debugging or preview
        const staticOptions = loadStaticOptions();
        const dynamicOptions = yield loadDynamicOptions();
        const localDynamicOptions = yield loadLocalDynamicOptions();
        const previewOptions = loadPreviewOptions();
        // languages are to be merged and not replaced
        const languages = Object.assign(Object.assign(Object.assign(Object.assign({}, (staticOptions.languages || {})), (localDynamicOptions.languages || {})), (dynamicOptions.languages || {})), (urlOptions.languages || {}));
        const options = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ versions: {
                ng1: __VERSION_NG1__,
                ngx: __VERSION_NGX__
            } }, staticOptions), localDynamicOptions), dynamicOptions), urlOptions), previewOptions), { remotes: getAllMFRemotes([
                staticOptions,
                localDynamicOptions,
                dynamicOptions,
                urlOptions,
                previewOptions
            ]), languages, remoteModules: [] });
        options.C8Y_INSTANCE_OPTIONS = Object.assign({}, options); // for compatability with c8yBase.getOptions in ng1-modules
        if (options.remotes) {
            for (const appName in options.remotes) {
                if (options.remotes.hasOwnProperty(appName)) {
                    const moduleNames = options.remotes[appName];
                    const url = `/apps/${appName}/remoteEntry.js`;
                    for (const moduleName of moduleNames) {
                        try {
                            options.remoteModules.push(yield loadRemoteModule(url, appName, moduleName));
                        }
                        catch (ex) {
                            console.warn(`Could not load remote module '${moduleName}' from url:`, url);
                        }
                    }
                }
            }
        }
        return options;
    });
}
export function getAllMFRemotes(mfRemotes) {
    return reduce(mfRemotes, (allRemotes, mfRemote) => {
        const { remotes } = mfRemote;
        forEach(remotes, (remoteModules, remoteContextPath) => {
            const currentRemotes = get(allRemotes, remoteContextPath, []);
            allRemotes[remoteContextPath] = union(currentRemotes, remoteModules);
        });
        return allRemotes;
    }, {});
}
function loadStaticOptions() {
    if (!staticOptionsCache) {
        staticOptionsCache =
            JSON.parse(document.querySelector('#static-options').innerText) || {};
    }
    return Object.assign(Object.assign({}, staticOptionsCache), loadUrlOptions());
}
export function loginOptions() {
    return __awaiter(this, void 0, void 0, function* () {
        const hostName = location.origin;
        return yield requestRemoteOptions(hostName + '/tenant/loginOptions');
    });
}
export function loadUrlOptions() {
    if (!urlOptionsCache) {
        const query = location.search.substr(1).split('&');
        urlOptionsCache = query.reduce((options, keyValuePair) => {
            if (keyValuePair) {
                if (keyValuePair.match(/=/)) {
                    const [key, value] = keyValuePair.split(/=/);
                    try {
                        options[key] = JSON.parse(decodeURIComponent(value));
                    }
                    catch (error) {
                        console.warn(`Failed to parse option ${key}: ${error}`);
                        options[key] = value;
                    }
                }
                else {
                    options[keyValuePair] = true;
                }
            }
            return options;
        }, {});
    }
    return urlOptionsCache;
}
export function clearUrlOptionsCache() {
    urlOptionsCache = undefined;
}
function loadLocalDynamicOptions() {
    return __awaiter(this, void 0, void 0, function* () {
        const remoteOptions = yield requestRemoteOptions(`cumulocity.json?nocache=${String(Math.random()).substr(2)}`);
        return remoteOptions;
    });
}
function loadDynamicOptions() {
    return __awaiter(this, void 0, void 0, function* () {
        let { dynamicOptionsUrl } = loadStaticOptions();
        let remoteOptions = {};
        if (dynamicOptionsUrl) {
            dynamicOptionsUrl = dynamicOptionsUrl.match(/\?/)
                ? dynamicOptionsUrl
                : `${dynamicOptionsUrl}?nocache=${String(Math.random()).substr(2)}`;
            remoteOptions = yield requestRemoteOptions(dynamicOptionsUrl);
        }
        return remoteOptions;
    });
}
function loadPreviewOptions() {
    if (window.C8Y_PREVIEW) {
        return window.C8Y_PREVIEW;
    }
    return {};
}
function requestRemoteOptions(url) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            let options = {};
            const onload = () => {
                if (request.status >= 200 && request.status < 400) {
                    try {
                        options = JSON.parse(request.responseText);
                    }
                    catch (e) {
                        // do nothing
                    }
                    Object.keys(options).forEach(key => {
                        const value = options[key];
                        if (typeof value === 'string') {
                            try {
                                const parsed = JSON.parse(value);
                                if (typeof parsed === 'object') {
                                    options[key] = parsed;
                                }
                            }
                            catch (e) {
                                // do nothing
                            }
                        }
                    });
                }
                resolve(options);
            };
            request.open('GET', url, true);
            request.setRequestHeader('UseXBasic', 'true');
            request.onload = onload;
            request.onerror = e => reject(e);
            request.send();
        });
    });
}
export function applyOptions(options) {
    const { c8yAppVarName = 'C8Y_APP' } = options;
    options = window.C8Y_APP = window[c8yAppVarName] = Object.assign({ modules: [] }, options);
    setVersion(options);
    updateTitle(options, document);
    updateFavicon(options, document);
    updateBrandingUrl(options, document);
    updateCss(options, document);
    updateTranslations(options);
    return options;
}
export function setVersion(options) {
    const { c8yVersionName = 'UI_VERSION' } = options;
    window[c8yVersionName] = options.versions.ng1 || options.versions.ngx;
}
export function updateTitle({ globalTitle }, document) {
    if (!globalTitle) {
        return;
    }
    const titleEl = document.querySelector('title');
    titleEl.innerText = `${globalTitle} - ${titleEl.innerText}`;
}
export function updateFavicon({ faviconUrl = 'favicon.ico' }, document) {
    const link = document.createElement('link');
    link.setAttribute('rel', 'icon');
    link.setAttribute('href', faviconUrl);
    document.querySelector('head').appendChild(link);
}
export function updateBrandingUrl({ brandingUrl }, document) {
    if (!brandingUrl) {
        if (__ENTRY_BRANDING__) {
            import(/* webpackChunkName: "branding" */ __ENTRY_BRANDING__);
        }
        else {
            throw new Error('Branding definition missing.');
        }
    }
    else {
        const link = document.createElement('link');
        link.setAttribute('rel', 'stylesheet');
        link.setAttribute('href', brandingUrl);
        document.querySelector('head').appendChild(link);
    }
}
export function updateCss({ brandingCssVars, extraCssUrls }, document) {
    if (Array.isArray(extraCssUrls)) {
        extraCssUrls.forEach(url => {
            const link = document.createElement('link');
            link.setAttribute('rel', 'stylesheet');
            link.setAttribute('href', url);
            document.querySelector('head').appendChild(link);
        });
    }
    if (brandingCssVars) {
        const vars = Object.keys(brandingCssVars).map(key => `--${key}: ${brandingCssVars[key]};`);
        const style = document.createElement('style');
        style.appendChild(document.createTextNode(`:root{\n${vars.join('\n')}\n}`));
        document.querySelector('head').appendChild(style);
    }
}
export function updateTranslations(options) {
    if (options.i18nExtra) {
        options.langsDetails = Object.assign(Object.assign({}, options.langsDetails), options.i18nExtra);
    }
}
function loadRemoteModule(remoteEntry, remoteName, exposedModule) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!remoteScriptSet.has(remoteEntry)) {
            remoteScriptSet.add(remoteEntry);
            yield loadRemoteEntry(remoteEntry);
        }
        const camelCase = str => {
            const newString = str
                .toLowerCase()
                .replace(/[^A-Za-z0-9]/g, ' ')
                .split(' ')
                .reduce((result, word) => result + capitalize(word.toLowerCase()));
            return newString.charAt(0).toLowerCase() + newString.slice(1);
        };
        const capitalize = str => str.charAt(0).toUpperCase() + str.toLowerCase().slice(1);
        return yield lookupExposedModule(camelCase(remoteName), exposedModule);
    });
}
function loadRemoteEntry(remoteEntry) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = remoteEntry;
        script.onerror = reject;
        script.onload = () => {
            resolve(); // window is the global namespace
        };
        document.body.append(script);
    });
}
function lookupExposedModule(remoteName, exposedModule) {
    return __awaiter(this, void 0, void 0, function* () {
        // Initializes the share scope. This fills it with known provided modules from this build and all remotes
        try {
            yield __webpack_init_sharing__('default');
        }
        catch (ex) {
            console.error(`Module ${exposedModule} could not be loaded. Module Federation is not enabled in this application.`, ex);
        }
        const container = window[remoteName];
        // Initialize the container, it may provide shared modules
        let factory;
        try {
            yield container.init(__webpack_share_scopes__.default);
            factory = (yield container.get(exposedModule))();
        }
        catch (ex) {
            console.error(`Module ${exposedModule} could not be loaded.`, ex);
        }
        return { name: exposedModule, factory };
    });
}
//# sourceMappingURL=options.js.map