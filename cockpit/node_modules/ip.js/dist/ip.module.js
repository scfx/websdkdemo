import JSBI from 'jsbi';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var isBigInt = function isBigInt(num) {
  return num instanceof JSBI;
};

function polyBigInt() {
  var useBigInt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return useBigInt ? {
    // BigInt numbers
    // constructor
    num: JSBI.BigInt,
    // converters
    toNum: JSBI.toNumber,
    toBigInt: function toBigInt(bi) {
      return bi;
    },
    toString: function toString(num, radix) {
      return num.toString(radix);
    },
    // arithmetic
    add: JSBI.add,
    sub: JSBI.subtract,
    mult: JSBI.multiply,
    div: JSBI.divide,
    rem: JSBI.remainder,
    exp: JSBI.exponentiate,
    neg: JSBI.unaryMinus,
    // inc / dec
    inc: function inc(num) {
      return JSBI.add(num, JSBI.BigInt(1));
    },
    dec: function dec(num) {
      return JSBI.subtract(num, JSBI.BigInt(1));
    },
    // bit operators
    bitNeg: JSBI.bitwiseNot,
    bitAnd: JSBI.bitwiseAnd,
    bitOr: JSBI.bitwiseOr,
    bitXor: JSBI.bitwiseXor,
    shiftLeft: JSBI.leftShift,
    shiftRight: JSBI.signedRightShift,
    // comparison
    eq: JSBI.equal,
    lt: JSBI.lessThan,
    leq: JSBI.lessThanOrEqual,
    gt: JSBI.greaterThan,
    geq: JSBI.greaterThanOrEqual
  } : {
    // regular numbers
    // constructor
    num: function num(_num) {
      return _num;
    },
    // converters
    toNum: Number,
    toBigInt: JSBI.BigInt,
    toString: function toString(num, radix) {
      return num.toString(radix);
    },
    // arithmetic
    add: function add(a, b) {
      return a + b;
    },
    sub: function sub(a, b) {
      return a - b;
    },
    mult: function mult(a, b) {
      return a * b;
    },
    div: function div(a, b) {
      return Math.floor(a / b);
    },
    rem: function rem(a, b) {
      return a % b;
    },
    exp: function exp(a, b) {
      return Math.pow(a, b);
    },
    neg: function neg(num) {
      return -num;
    },
    // inc / dec
    inc: function inc(num) {
      return num + 1;
    },
    dec: function dec(num) {
      return num - 1;
    },
    // bit operators
    bitNeg: function bitNeg(num) {
      return ~num;
    },
    bitAnd: function bitAnd(a, b) {
      return a & b;
    },
    bitOr: function bitOr(a, b) {
      return a | b;
    },
    bitXor: function bitXor(a, b) {
      return a ^ b;
    },
    shiftLeft: function shiftLeft(num, bits) {
      return num << bits;
    },
    shiftRight: function shiftRight(num, bits) {
      return num >> bits;
    },
    // comparison
    eq: function eq(a, b) {
      return a === b;
    },
    lt: function lt(a, b) {
      return a < b;
    },
    leq: function leq(a, b) {
      return a <= b;
    },
    gt: function gt(a, b) {
      return a > b;
    },
    geq: function geq(a, b) {
      return a >= b;
    }
  };
}

var numOp = polyBigInt(false);
var bigintOp = polyBigInt(true);

var Addr =
/*#__PURE__*/
function () {
  function Addr(ip, isV4) {
    var _this = this;

    _classCallCheck(this, Addr);

    _defineProperty(this, "version", function () {
      return _this.isV4 ? 4 : 6;
    });

    _defineProperty(this, "isIPv4", function () {
      return _this.isV4;
    });

    _defineProperty(this, "toNum", function () {
      return _this.num;
    });

    _defineProperty(this, "addIp", function (another) {
      return new Addr(_this.op.add(_this.toNum(), another.toNum()));
    });

    _defineProperty(this, "subIp", function (another) {
      return new Addr(_this.op.sub(_this.toNum(), another.toNum()));
    });

    var deriveFamily = isV4 === undefined;
    !deriveFamily && (this.isV4 = !!isV4);

    if (ip instanceof Addr) {
      deriveFamily && (this.isV4 = ip.isIPv4());
      this.num = ip.toNum();
    } else if (typeof ip === 'number') {
      deriveFamily && (this.isV4 = ip < Math.pow(2, 32));
      this.num = ip;
    } else if (isBigInt(ip)) {
      deriveFamily && (this.isV4 = bigintOp.lt(ip, Math.pow(2, 32)));
      this.num = ip;
    } else {
      // Parse as string
      var _isV = ip.indexOf(':') === -1;

      var op = _isV ? numOp : bigintOp; // use bigint to parse strings

      var num = op.num(0);
      var exp = _isV ? 32 - 8 : 128 - 16;
      var maxSegmentNum = Math.pow(2, _isV ? 8 : 16) - 1;
      var numFinalSegments = _isV ? 0 : (ip.split('::')[1] || '').split(':').length;
      var segments = ip.split(_isV ? '.' : ':');

      if (segments.length > (_isV ? 4 : 16)) {
        throw new Error("Failed to parse ".concat(ip, ": too many octets."));
      }

      segments.forEach(function (seg) {
        if (!seg.length) {
          return exp = (numFinalSegments - 1) * (_isV ? 4 : 16);
        }

        var segNum = parseInt(seg, _isV ? 10 : 16);

        if (isNaN(segNum)) {
          throw new Error("Unable to parse address portion \"".concat(seg, "\" from ").concat(ip));
        }

        if (segNum < 0 || segNum > maxSegmentNum) {
          throw new Error("Octet \"".concat(seg, "\" outside bounds in ").concat(ip));
        }

        num = op.add(num, op.mult(op.num(segNum), op.num(Math.pow(2, exp))));
        exp -= _isV ? 8 : 16;
      });
      deriveFamily && (this.isV4 = _isV);
      this.num = num;
    }

    this.op = this.isV4 ? numOp : bigintOp; // use big int operations for IPv6
    // ensure num is of same type as operations

    this.num = (isBigInt(this.num) ? bigintOp : numOp)[this.isV4 ? 'toNum' : 'toBigInt'](this.num);
  }

  _createClass(Addr, [{
    key: "toString",
    value: function toString() {
      var op = this.op;
      var segLen = op.num(Math.pow(2, this.isV4 ? 8 : 16));
      var num = this.num; // let str = (num%segLen).toString(this.isV4 ? 10 : 16);

      var str = op.toString(op.rem(num, segLen), this.isV4 ? 10 : 16);

      for (var i = 1; i < (this.isV4 ? 4 : 8); i++) {
        num = op.div(num, segLen);
        str = "".concat(op.toString(op.rem(num, segLen), this.isV4 ? 10 : 16)).concat(this.isV4 ? '.' : ':').concat(str);
      }

      return this.isV4 ? str : compressV6(str); //

      function compressV6(addrStr) {
        var chunks = addrStr.split(/:/);
        var out = '';

        for (var _i = 0; _i < chunks.length; _i++) {
          var chunk = chunks[_i].replace(/^0+/, '');

          if (!chunk) chunk = 0;
          out += "".concat(chunk, ":");
        }

        out = out.replace(/(:0)+/, ':');
        out = out.replace(/^0/, '');
        out = out.replace(/:0$/, ':');
        out = out.substr(0, out.length - 1);
        if (!out.match(/::/)) if (out.match(/:$/)) out += ':';
        return out;
      }
    }
  }, {
    key: "toBin",
    // Returns a string with the binary representation of the IP (v4: 32 bits long, v6: 128 bits long)
    value: function toBin() {
      var bin = this.op.toString(this.num, 2); // Pad with 0s

      while (bin.length < (this.isV4 ? 32 : 128)) {
        bin = "0".concat(bin);
      }

      return bin;
    }
  }, {
    key: "compare2Ip",
    // Return value: -1: this<that, 0: this=that, 1: this>that, null: different families
    value: function compare2Ip(that) {
      var op = this.op;
      if (this.version() !== that.version()) return null;
      return compareNums(this.toNum(), that.toNum());

      function compareNums(numa, numb) {
        return op.eq(numa, numb) ? 0 : op.lt(numa, numb) ? -1 : 1;
      }
    }
  }]);

  return Addr;
}();

var Prefix =
/*#__PURE__*/
function () {
  function Prefix(ipPrefix, cidr, isV4) {
    var _this = this;

    _classCallCheck(this, Prefix);

    _defineProperty(this, "isIPv4", function () {
      return _this.ip.isIPv4();
    });

    _defineProperty(this, "toString", function () {
      return "".concat(_this.ip.toString(), "/").concat(_this.cidr);
    });

    _defineProperty(this, "getCidr", function () {
      return _this.cidr;
    });

    _defineProperty(this, "firstIp", function () {
      return _this.ip;
    });

    _defineProperty(this, "lastIp", function () {
      return new Addr(_this.op.sub(_this.op.add(_this.ip.toNum(), _this.countIps()), _this.op.num(1)), _this.isIPv4());
    });

    _defineProperty(this, "toRange", function () {
      return new Range(_this.firstIp(), _this.lastIp(), _this.isIPv4());
    });

    if (cidr !== undefined) {
      this.ip = new Addr(ipPrefix, isV4);
      this.cidr = cidr;
    } else {
      // Parse as string
      var prefix = ipPrefix.split('/');
      this.ip = new Addr(prefix[0], isV4);
      this.cidr = prefix.length > 1 ? +prefix[1] : this.ip.isIPv4() ? 32 : 128; // auto-add single IP CIDR if not included
    }

    if (isNaN(this.cidr)) {
      throw new Error("Invalid numeric CIDR in prefix ".concat(ipPrefix));
    }

    if (this.cidr < 0 || this.cidr > (this.ip.isIPv4() ? 32 : 128)) {
      throw new Error("Cidr /".concat(this.cidr, " outside bounds in prefix ").concat(ipPrefix));
    }

    this.op = this.ip.op;
  }

  _createClass(Prefix, [{
    key: "countIps",
    value: function countIps() {
      var op = this.op;
      return op.exp(op.num(2), op.num((this.isIPv4() ? 32 : 128) - this.cidr));
    }
  }, {
    key: "correctBitBoundary",
    // Return a valid prefix by setting the correct start IP that fits this prefix length
    value: function correctBitBoundary() {
      var op = this.op;
      var mask = op.sub(op.exp(op.num(2), op.num((this.isIPv4() ? 32 : 128) - this.cidr)), op.num(1));
      var correctedNum = op.bitAnd(this.ip.toNum(), op.bitNeg(mask));
      return new Prefix(new Addr(correctedNum), this.cidr, this.isIPv4());
    } // Slice the prefix into an array of smaller prefixes of a specified CIDR size

  }, {
    key: "slice",
    value: function slice(cidr) {
      if (this.cidr >= cidr) return [this];
      var oneIP = new Addr(1, this.isIPv4());
      var slices = [];
      var runningIp = this.ip;

      for (var i = 0, len = Math.pow(2, cidr - this.cidr); i < len; i++) {
        var slice = new Prefix(runningIp, cidr, this.isIPv4());
        slices.push(slice);
        runningIp = slice.lastIp().addIp(oneIP);
      }

      return slices;
    }
  }]);

  return Prefix;
}(); // ********************* //


var Range =
/*#__PURE__*/
function () {
  function Range(firstIp, lastIp, isV4) {
    var _this2 = this;

    _classCallCheck(this, Range);

    _defineProperty(this, "isIPv4", function () {
      return _this2.start.isIPv4();
    });

    _defineProperty(this, "toString", function () {
      return "".concat(_this2.start.toString(), " - ").concat(_this2.end.toString());
    });

    _defineProperty(this, "countIps", function () {
      return _this2.op.add(_this2.op.sub(_this2.end.toNum(), _this2.start.toNum()), _this2.op.num(1));
    });

    _defineProperty(this, "firstIp", function () {
      return _this2.start;
    });

    _defineProperty(this, "lastIp", function () {
      return _this2.end;
    });

    this.start = new Addr(firstIp, isV4);
    this.end = new Addr(lastIp, isV4);
    if (this.start.version() !== this.end.version()) throw new Error("Range addresses have different families: ".concat(this.start.toString(), " - ").concat(this.end.toString()));
    this.op = this.start.op;
  }

  _createClass(Range, [{
    key: "cidrCount",
    value: function cidrCount() {
      return (this.isIPv4() ? 32 : 128) - Math.log(this.op.toNum(this.countIps())) / Math.log(2);
    }
  }, {
    key: "toPrefixes",
    value: function toPrefixes() {
      var endIp = this.end;
      var topCidr = Math.ceil(this.cidrCount());
      var zeroIP = new Addr(0, this.isIPv4());
      var oneIP = new Addr(1, this.isIPv4());
      var prefixes = [];
      var sweepIp = this.start;

      while (sweepIp.compare2Ip(endIp) <= 0) {
        var cidr = topCidr;
        var prefix = new Prefix(sweepIp, cidr, this.isIPv4());

        while (prefix.correctBitBoundary().firstIp().compare2Ip(sweepIp) !== 0 || prefix.lastIp().compare2Ip(endIp) > 0) {
          cidr++;
          prefix = new Prefix(sweepIp, cidr, this.isIPv4());
        }

        prefixes.push(prefix);
        sweepIp = prefix.lastIp().addIp(oneIP);
        if (sweepIp.compare2Ip(zeroIP) === 0) // Counter flipped back to start
          break;
      }

      return prefixes;
    }
  }, {
    key: "toEncompassingPrefix",
    value: function toEncompassingPrefix() {
      var startIp = this.start;
      var endIp = this.end;
      var cidr = Math.floor(this.cidrCount());
      var prefix = new Prefix(startIp, cidr, this.isIPv4()).correctBitBoundary();

      while (prefix.lastIp().compare2Ip(endIp) < 0) {
        cidr--;
        prefix = new Prefix(startIp, cidr, this.isIPv4()).correctBitBoundary();
      }

      return prefix;
    } // Returns the percentual value (0 to 1) of what is the relative position of ip within the specified range
    // Values of <0 or >1 are possible if IP is outside of the range
    // False indicates if the value should be calculated for right before the IP address(false) or right after(true)
    // Returns null if IP and range are not of the same family

  }, {
    key: "ipRelPosition",
    value: function ipRelPosition(ip, after) {
      var op = this.op;
      if (!after) after = false;
      if (ip.isIPv4() !== this.isIPv4()) return null; // Different IP families

      var ipnum = ip.toNum();
      var first = this.start.toNum();
      var last = this.end.toNum();
      return percentVal(op.add(ipnum, op.num(after ? 1 : 0)), first, last);

      function percentVal(pos, start, end) {
        return op.toNum(op.sub(pos, start)) / (op.toNum(op.sub(end, start)) + 1);
      }
    } // Returns the ip that is at the percentual position of the range

  }, {
    key: "ipAtPerc",
    value: function ipAtPerc(perc) {
      var op = this.op;
      return new Addr(numPercentValue(perc, this.start.toNum(), op.add(this.end.toNum(), op.num(1))), this.isIPv4());

      function numPercentValue(perc, start, end) {
        return op.add(start, op.num(Math.round(op.toNum(op.sub(end, start)) * (perc / 100))));
      }
    } // Returns the start and end percentage of overlap between this range and a child range
    // Values <0 or >100 are possible if the ranges only partially overlap or not overlap at all
    // Percentages are relative to the this range

  }, {
    key: "overlapPerc",
    value: function overlapPerc(childRange) {
      return [this.ipRelPosition(childRange.firstIp()) * 100, this.ipRelPosition(childRange.lastIp(), true) * 100];
    } // Returns the 5 CIDR neighbor prefixes: one CIDR up, two side siblings left and right, first and second half down

  }, {
    key: "getNeighborPrefixes",
    value: function getNeighborPrefixes() {
      var cidrSize = this.cidrCount(); // Spot the boundaries

      var top = Math.ceil(cidrSize) === 0;
      var bottom = Math.floor(cidrSize) === (this.isIPv4() ? 32 : 128);
      var leftmost = this.firstIp().toBin().indexOf('1') === -1;
      var rightmost = this.lastIp().toBin().indexOf('0') === -1;
      var neighbors = {
        up: null,
        left: null,
        right: null,
        downleft: null,
        downright: null
      };

      if (!top) {
        var upCidr = Math.ceil(cidrSize) - 1;
        neighbors.up = new Prefix(this.firstIp(), upCidr, this.isIPv4()).correctBitBoundary();
      }

      var sideCidr = Math.ceil(cidrSize);
      var oneIp = new Addr(1, this.isIPv4());
      if (!leftmost) neighbors.left = new Prefix(this.firstIp().subIp(oneIp), sideCidr, this.isIPv4()).correctBitBoundary();
      if (!rightmost) neighbors.right = new Prefix(this.lastIp().addIp(oneIp), sideCidr, this.isIPv4()).correctBitBoundary();

      if (!bottom) {
        var downCidr = Math.min(this.isIPv4() ? 32 : 128, Math.floor(cidrSize) + 1);
        neighbors.downleft = new Prefix(this.firstIp(), downCidr, this.isIPv4()).correctBitBoundary();
        neighbors.downright = new Prefix(this.lastIp(), downCidr, this.isIPv4()).correctBitBoundary();
      }

      return neighbors;
    }
  }]);

  return Range;
}();

export { Addr, Prefix, Range };
