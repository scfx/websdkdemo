import { Injectable, InjectionToken, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { BehaviorSubject, Subject } from 'rxjs';
import { map, shareReplay } from 'rxjs/operators';
import { fromTriggerOnce, sortByPriority, stateToFactory } from '../common/extension-hooks';
import { StateService } from '../common/state-service.abstract';
import { NavigatorNodeRoot } from './navigator-node-root';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
/**
 * A hook to use for Multi Provider extension.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/router';
export const HOOK_NAVIGATOR_NODES = new InjectionToken('NavigatorNodesFactory');
/**
 * A service which defines the navigator.
 */
export class NavigatorService extends StateService {
    constructor(injector, router) {
        super();
        this.injector = injector;
        this.router = router;
        /**
         * Refresh the extension factories subject.
         * @readonly
         */
        this.refreshTrigger = new Subject();
        /**
         * @ignore
         */
        this.state$ = new BehaviorSubject(new Set());
        /**
         * Indicates whether the menu entry associated with the given URL should be expanded.
         */
        this.firstUrl = true;
        /**
         * Additional factories that can be added by plugins.
         */
        this.factories = [];
        const rootNode = new NavigatorNodeRoot();
        this.items$ = fromTriggerOnce(router, this.refreshTrigger, [
            () => this.injector.get(HOOK_NAVIGATOR_NODES, []),
            () => this.factories,
            stateToFactory(this.state$)
        ]).pipe(map((nodes) => {
            const noParent = nodes.filter(node => !node.parent);
            const withParent = nodes.filter(node => node.parent);
            // Based on the sortedNodes array, the nodes are sequentially created.
            // Nodes sorting is done in two steps to have the top-level nodes first.
            // This way, by the time we are adding a child node, the parent node is already present.
            const sortedNodes = sortByPriority(noParent).concat(sortByPriority(withParent));
            rootNode.empty();
            sortedNodes.forEach(node => rootNode.addRoot(node));
            return rootNode.children;
        }), shareReplay(1));
    }
    /**
     * Checks whenever a navigator entry associated with the given URL should be expanded.
     * @param {NavigatorNode} node Navigator node.
     */
    openOnFirstUrl(node) {
        if (this.firstUrl && !!node.path) {
            return (this.router.isActive(node.path, node.routerLinkExact) || node.openOnStart(this.router.url));
        }
        return false;
    }
    /**
     * Returns the current state.
     * @readonly
     * @returns The current set of actions.
     */
    get state() {
        return this.state$.value;
    }
    /**
     * Refresh the extension factories.
     */
    refresh() {
        this.refreshTrigger.next(1);
    }
    /**
     * Adds a new node to the navigator.
     * @param {NavigatorNode} node Navigator node to add.
     */
    add(node) {
        this.state.add(node);
        this.emitNewState();
    }
    /**
     * Removes a node from the navigator.
     * @param {NavigatorNode} node Navigator node to remove.
     */
    remove(node) {
        this.state.delete(node);
        this.emitNewState();
    }
}
NavigatorService.ɵfac = function NavigatorService_Factory(t) { return new (t || NavigatorService)(ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(ɵngcc1.Router)); };
NavigatorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function NavigatorService_Factory() { return new NavigatorService(i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.Router)); }, token: NavigatorService, providedIn: "root" });
NavigatorService.ctorParameters = () => [
    { type: Injector },
    { type: Router }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc0.Injector }, { type: ɵngcc1.Router }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdG9yLnNlcnZpY2UuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvbmF2aWdhdG9yL25hdmlnYXRvci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekMsT0FBTyxFQUFFLGVBQWUsRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDNUQsT0FBTyxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRCxPQUFPLEVBR0wsZUFBZSxFQUNmLGNBQWMsRUFDZCxjQUFjLEVBQ2YsTUFBTSwyQkFBMkIsQ0FBQztBQUNuQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFHaEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDMUQ7QUFFZ0M7QUFtQmhDO0FBQ0E7QUFDQSxHQUFHOzs7QUFDSCxNQUFNLENBQUMsTUFBTSxvQkFBb0IsR0FBRyxJQUFJLGNBQWMsQ0FDcEQsdUJBQXVCLENBQ3hCLENBQUM7QUFFRjtBQUNBO0FBQ0EsR0FBRztBQUlILE1BQU0sT0FBTyxnQkFBaUIsU0FBUSxZQUFZO0FBQUcsSUEyQm5ELFlBQW9CLFFBQWtCLEVBQVUsTUFBYztBQUNoRSxRQUFJLEtBQUssRUFBRSxDQUFDO0FBQ1osUUFGc0IsYUFBUSxHQUFSLFFBQVEsQ0FBVTtBQUFDLFFBQVMsV0FBTSxHQUFOLE1BQU0sQ0FBUTtBQUFDLFFBckIvRDtBQUNGO0FBQ007QUFFQSxXQUREO0FBQ0wsUUFBVyxtQkFBYyxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7QUFDMUMsUUFDRTtBQUNGO0FBRUEsV0FESztBQUNMLFFBQVcsV0FBTSxHQUFHLElBQUksZUFBZSxDQUFxQixJQUFJ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QUUsTUFBTSxDQUFDLElBQW1CO0FBQzVCLFFBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDNUIsUUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7QUFDeEIsSUFBRSxDQUFDO0FBQ0g7dUtBQUM7QUFDRCxpT0FsR0s7QUFBQztFQUhMLFVBQVUsU0FBQyxyQkFHb0MsWUFqRFgsUUFBUTtlQStDM0MsZkEvQytDLFlBQ3hDLE1BQU07QUFBRztDQThDTixFQUFFLE1BQU0sY0FDbkI7Ozs7O2tHQS9DbUI7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCBzaGFyZVJlcGxheSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7XG4gIEV4dGVuc2lvbkZhY3RvcnksXG4gIEV4dGVuc2lvblBvaW50LFxuICBmcm9tVHJpZ2dlck9uY2UsXG4gIHNvcnRCeVByaW9yaXR5LFxuICBzdGF0ZVRvRmFjdG9yeVxufSBmcm9tICcuLi9jb21tb24vZXh0ZW5zaW9uLWhvb2tzJztcbmltcG9ydCB7IFN0YXRlU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9zdGF0ZS1zZXJ2aWNlLmFic3RyYWN0JztcbmltcG9ydCB7IE5hdmlnYXRvck5vZGUgfSBmcm9tICcuL25hdmlnYXRvci1ub2RlJztcbmltcG9ydCB7IE5hdmlnYXRvck5vZGVEYXRhIH0gZnJvbSAnLi9uYXZpZ2F0b3Itbm9kZS1kYXRhJztcbmltcG9ydCB7IE5hdmlnYXRvck5vZGVSb290IH0gZnJvbSAnLi9uYXZpZ2F0b3Itbm9kZS1yb290JztcblxuLyoqXG4gKiBBbiBleHRlbnNpb24gSE9PSyBjYW4gdXNlIGVpdGhlciBhIHB1cmUgdmFsdWU6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgeyBwcm92aWRlOiBIT09LX1gsIHVzZVZhbHVlOiB7IC4uLmhvb2tWYWx1ZSB9LCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqXG4gKiBPciBhbiBhcnJheSB0byBkaXJlY3RseSByZWdpc3RlciBtdWx0aXBsZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICB7IHByb3ZpZGU6IEhPT0tfWCwgdXNlVmFsdWU6IFt7IC4uLmhvb2tWYWx1ZXMgfV0sIG11bHRpOiB0cnVlIH1cbiAqIGBgYFxuICpcbiAqIE9yIGFuIEV4dGVuc2lvbkZhY3Rvcnkgd2hpY2ggYWxsb3dzIHRvIGRlZmluZSBhIGdldCgpIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBnZXRzIGNhbGxlZCBvbiBlYWNoIG5hdmlnYXRpb24gd2l0aCB0aGUgY3VycmVudCByb3V0ZSBhbmQgY2FuIHJldHVybiB2YWx1ZXNcbiAqIGFzeW5jIChvYnNlcnZhYmxlIG9yIHByb21pc2UpLlxuICogYGBgdHlwZXNjcmlwdFxuICogIHsgcHJvdmlkZTogSE9PS19YLCB1c2VGYWN0b3J5OiB7IGdldDogKHJvdXRlKSA9PiBkb1NvbWV0aGluZ0FzeW5jKHJvdXRlKSB9LCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqL1xudHlwZSBOYXZpZ2F0b3JFeHRlbnNpb24gPSBOYXZpZ2F0b3JOb2RlIHwgTmF2aWdhdG9yTm9kZVtdIHwgRXh0ZW5zaW9uRmFjdG9yeTxOYXZpZ2F0b3JOb2RlPjtcblxuLyoqXG4gKiBBIGhvb2sgdG8gdXNlIGZvciBNdWx0aSBQcm92aWRlciBleHRlbnNpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBIT09LX05BVklHQVRPUl9OT0RFUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxOYXZpZ2F0b3JFeHRlbnNpb25bXT4oXG4gICdOYXZpZ2F0b3JOb2Rlc0ZhY3RvcnknXG4pO1xuXG4vKipcbiAqIEEgc2VydmljZSB3aGljaCBkZWZpbmVzIHRoZSBuYXZpZ2F0b3IuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRvclNlcnZpY2UgZXh0ZW5kcyBTdGF0ZVNlcnZpY2UgaW1wbGVtZW50cyBFeHRlbnNpb25Qb2ludDxOYXZpZ2F0b3JFeHRlbnNpb24+IHtcbiAgLyoqXG4gICAqIE5hdmlnYXRvciBtZW51IGl0ZW1zIG9ic2VydmFibGUuIEl0IGVtaXRzIHRoZSBjdXJyZW50IGxpc3Qgb2Ygbm9kZXMgaW4gdGhlIG5hdmlnYXRvci5cbiAgICovXG4gIGl0ZW1zJDogT2JzZXJ2YWJsZTxOYXZpZ2F0b3JOb2RlW10+O1xuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSBleHRlbnNpb24gZmFjdG9yaWVzIHN1YmplY3QuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgcmVhZG9ubHkgcmVmcmVzaFRyaWdnZXIgPSBuZXcgU3ViamVjdCgpO1xuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICByZWFkb25seSBzdGF0ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFNldDxOYXZpZ2F0b3JOb2RlPj4obmV3IFNldDxOYXZpZ2F0b3JOb2RlPigpKTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1lbnUgZW50cnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBVUkwgc2hvdWxkIGJlIGV4cGFuZGVkLlxuICAgKi9cbiAgZmlyc3RVcmwgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIGZhY3RvcmllcyB0aGF0IGNhbiBiZSBhZGRlZCBieSBwbHVnaW5zLlxuICAgKi9cbiAgZmFjdG9yaWVzOiBOYXZpZ2F0b3JFeHRlbnNpb25bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLCBwcml2YXRlIHJvdXRlcjogUm91dGVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCByb290Tm9kZSA9IG5ldyBOYXZpZ2F0b3JOb2RlUm9vdCgpO1xuICAgIHRoaXMuaXRlbXMkID0gZnJvbVRyaWdnZXJPbmNlKHJvdXRlciwgdGhpcy5yZWZyZXNoVHJpZ2dlciwgW1xuICAgICAgKCkgPT4gdGhpcy5pbmplY3Rvci5nZXQoSE9PS19OQVZJR0FUT1JfTk9ERVMsIFtdKSxcbiAgICAgICgpID0+IHRoaXMuZmFjdG9yaWVzLFxuICAgICAgc3RhdGVUb0ZhY3RvcnkodGhpcy5zdGF0ZSQpXG4gICAgXSkucGlwZShcbiAgICAgIG1hcCgobm9kZXM6IFBhcnRpYWw8TmF2aWdhdG9yTm9kZURhdGFbXT4pID0+IHtcbiAgICAgICAgY29uc3Qgbm9QYXJlbnQgPSBub2Rlcy5maWx0ZXIobm9kZSA9PiAhbm9kZS5wYXJlbnQpO1xuICAgICAgICBjb25zdCB3aXRoUGFyZW50ID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5wYXJlbnQpO1xuXG4gICAgICAgIC8vIEJhc2VkIG9uIHRoZSBzb3J0ZWROb2RlcyBhcnJheSwgdGhlIG5vZGVzIGFyZSBzZXF1ZW50aWFsbHkgY3JlYXRlZC5cbiAgICAgICAgLy8gTm9kZXMgc29ydGluZyBpcyBkb25lIGluIHR3byBzdGVwcyB0byBoYXZlIHRoZSB0b3AtbGV2ZWwgbm9kZXMgZmlyc3QuXG4gICAgICAgIC8vIFRoaXMgd2F5LCBieSB0aGUgdGltZSB3ZSBhcmUgYWRkaW5nIGEgY2hpbGQgbm9kZSwgdGhlIHBhcmVudCBub2RlIGlzIGFscmVhZHkgcHJlc2VudC5cbiAgICAgICAgY29uc3Qgc29ydGVkTm9kZXMgPSBzb3J0QnlQcmlvcml0eShub1BhcmVudCkuY29uY2F0KHNvcnRCeVByaW9yaXR5KHdpdGhQYXJlbnQpKTtcbiAgICAgICAgcm9vdE5vZGUuZW1wdHkoKTtcbiAgICAgICAgc29ydGVkTm9kZXMuZm9yRWFjaChub2RlID0+IHJvb3ROb2RlLmFkZFJvb3Qobm9kZSkpO1xuICAgICAgICByZXR1cm4gcm9vdE5vZGUuY2hpbGRyZW47XG4gICAgICB9KSxcbiAgICAgIHNoYXJlUmVwbGF5KDEpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hlbmV2ZXIgYSBuYXZpZ2F0b3IgZW50cnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBVUkwgc2hvdWxkIGJlIGV4cGFuZGVkLlxuICAgKiBAcGFyYW0ge05hdmlnYXRvck5vZGV9IG5vZGUgTmF2aWdhdG9yIG5vZGUuXG4gICAqL1xuICBvcGVuT25GaXJzdFVybChub2RlOiBOYXZpZ2F0b3JOb2RlKSB7XG4gICAgaWYgKHRoaXMuZmlyc3RVcmwgJiYgISFub2RlLnBhdGgpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMucm91dGVyLmlzQWN0aXZlKG5vZGUucGF0aCwgbm9kZS5yb3V0ZXJMaW5rRXhhY3QpIHx8IG5vZGUub3Blbk9uU3RhcnQodGhpcy5yb3V0ZXIudXJsKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqIEByZWFkb25seVxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzZXQgb2YgYWN0aW9ucy5cbiAgICovXG4gIGdldCBzdGF0ZSgpOiBTZXQ8TmF2aWdhdG9yTm9kZT4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlJC52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSBleHRlbnNpb24gZmFjdG9yaWVzLlxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLnJlZnJlc2hUcmlnZ2VyLm5leHQoMSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBub2RlIHRvIHRoZSBuYXZpZ2F0b3IuXG4gICAqIEBwYXJhbSB7TmF2aWdhdG9yTm9kZX0gbm9kZSBOYXZpZ2F0b3Igbm9kZSB0byBhZGQuXG4gICAqL1xuICBhZGQobm9kZTogTmF2aWdhdG9yTm9kZSkge1xuICAgIHRoaXMuc3RhdGUuYWRkKG5vZGUpO1xuICAgIHRoaXMuZW1pdE5ld1N0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGUgbmF2aWdhdG9yLlxuICAgKiBAcGFyYW0ge05hdmlnYXRvck5vZGV9IG5vZGUgTmF2aWdhdG9yIG5vZGUgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlKG5vZGU6IE5hdmlnYXRvck5vZGUpIHtcbiAgICB0aGlzLnN0YXRlLmRlbGV0ZShub2RlKTtcbiAgICB0aGlzLmVtaXROZXdTdGF0ZSgpO1xuICB9XG59XG4iXX0=