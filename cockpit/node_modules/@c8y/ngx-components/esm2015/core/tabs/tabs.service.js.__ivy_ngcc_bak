import { Injectable, InjectionToken, Injector, ViewContainerRef } from '@angular/core';
import { Router } from '@angular/router';
import { TranslateService } from '@ngx-translate/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { distinctUntilChanged, filter, first, map, shareReplay } from 'rxjs/operators';
import { fromTrigger, stateToFactory } from '../common/extension-hooks';
import { StateService } from '../common/state-service.abstract';
import { OptionsService } from '../common/options.service';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "@ngx-translate/core";
import * as i3 from "../common/options.service";
/**
 * A hook to use for Multi Provider extension.
 */
export const HOOK_TABS = new InjectionToken('TabsFactory');
/**
 * A service which defines the used tabs.
 */
export class TabsService extends StateService {
    constructor(injector, router, translateService, options) {
        super();
        this.injector = injector;
        this.translateService = translateService;
        this.options = options;
        this.refreshTrigger = new Subject();
        this.state$ = new BehaviorSubject(new Set());
        /**
         * Additional factories that can be added by plugins.
         */
        this.factories = [];
        this.items$ = fromTrigger(router, this.refreshTrigger, [
            () => this.injector.get(HOOK_TABS, []),
            () => this.factories,
            stateToFactory(this.state$)
        ]).pipe(map(tabs => this.prepareTabs(tabs)), shareReplay(1), distinctUntilChanged());
        this.orientation$ = this.items$.pipe(map((tabs) => {
            const firstTabWithDefinedOrientation = tabs.find(tab => tab.orientation);
            if (firstTabWithDefinedOrientation) {
                return firstTabWithDefinedOrientation.orientation;
            }
            return this.options.tabsHorizontal ? 'horizontal' : 'vertical';
        }), distinctUntilChanged());
    }
    prepareTabs(tabs) {
        return this.sortTabs(tabs
            .map(tab => (Object.assign(Object.assign({}, tab), { template: tab.template instanceof ViewContainerRef ? tab.template : undefined })))
            .filter((tab, index, self) => index === self.findIndex(t => t.path === tab.path)));
    }
    sortTabs(tabs) {
        return tabs.sort((a, b) => {
            const priorityOrder = (b.priority || 0) - (a.priority || 0);
            const aTranslatedLabel = this.translateService.instant(a.label);
            const bTranslatedLabel = this.translateService.instant(b.label);
            const translatedLabelOrder = aTranslatedLabel.localeCompare(bTranslatedLabel);
            return priorityOrder || translatedLabelOrder;
        });
    }
    /**
     * Refresh the extension factories
     */
    refresh() {
        this.refreshTrigger.next(1);
    }
    /**
     * Returns the current state.
     * @readonly
     * @returns The current set of actions.
     */
    get state() {
        return this.state$.value;
    }
    /**
     * Adds a new item to tabs and emits state change
     * @param item The item to add.
     */
    add(item) {
        this.state.add(item);
        this.emitNewState();
    }
    /**
     * Removes a tab and emits a state change.
     * @param item The item to remove.
     */
    remove(item) {
        this.state.delete(item);
        this.emitNewState();
    }
    get firstTab$() {
        return this.items$.pipe(map(tabs => tabs[0]), filter(Boolean), first());
    }
}
TabsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TabsService_Factory() { return new TabsService(i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.TranslateService), i0.ɵɵinject(i3.OptionsService)); }, token: TabsService, providedIn: "root" });
TabsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
TabsService.ctorParameters = () => [
    { type: Injector },
    { type: Router },
    { type: TranslateService },
    { type: OptionsService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS90YWJzL3RhYnMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdkYsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxlQUFlLEVBQWMsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzVELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN2RixPQUFPLEVBR0wsV0FBVyxFQUNYLGNBQWMsRUFDZixNQUFNLDJCQUEyQixDQUFDO0FBQ25DLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUVoRSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7Ozs7O0FBc0IzRDs7R0FFRztBQUNILE1BQU0sQ0FBQyxNQUFNLFNBQVMsR0FBRyxJQUFJLGNBQWMsQ0FBaUIsYUFBYSxDQUFDLENBQUM7QUFFM0U7O0dBRUc7QUFJSCxNQUFNLE9BQU8sV0FBWSxTQUFRLFlBQVk7SUFXM0MsWUFDVSxRQUFrQixFQUMxQixNQUFjLEVBQ04sZ0JBQWtDLEVBQ2xDLE9BQXVCO1FBRS9CLEtBQUssRUFBRSxDQUFDO1FBTEEsYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUVsQixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ2xDLFlBQU8sR0FBUCxPQUFPLENBQWdCO1FBWnhCLG1CQUFjLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUMvQixXQUFNLEdBQUcsSUFBSSxl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LENBQUM7SUFFRDs7O09BR0c7SUFDSCxHQUFHLENBQUMsSUFBUztRQUNYLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxDQUFDLElBQVM7UUFDZCxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVELElBQUksU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQ3JCLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUNwQixNQUFNLENBQUMsT0FBTyxDQUFDLEVBQ2YsS0FBSyxFQUFFLENBQ1IsQ0FBQztJQUNKLENBQUM7Ozs7WUExR0YsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUE3Q29DLFFBQVE7WUFDcEMsTUFBTTtZQUNOLGdCQUFnQjtZQVdoQixjQUFjIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdG9yLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCBmaXJzdCwgbWFwLCBzaGFyZVJlcGxheSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7XG4gIEV4dGVuc2lvbkZhY3RvcnksXG4gIEV4dGVuc2lvblBvaW50LFxuICBmcm9tVHJpZ2dlcixcbiAgc3RhdGVUb0ZhY3Rvcnlcbn0gZnJvbSAnLi4vY29tbW9uL2V4dGVuc2lvbi1ob29rcyc7XG5pbXBvcnQgeyBTdGF0ZVNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vc3RhdGUtc2VydmljZS5hYnN0cmFjdCc7XG5pbXBvcnQgeyBUYWIgfSBmcm9tICcuL3RhYi5tb2RlbCc7XG5pbXBvcnQgeyBPcHRpb25zU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9vcHRpb25zLnNlcnZpY2UnO1xuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiBIT09LIGNhbiB1c2UgZWl0aGVyIGEgcHVyZSB2YWx1ZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICB7IHByb3ZpZGU6IEhPT0tfWCwgdXNlVmFsdWU6IHsgLi4uaG9va1ZhbHVlIH0sIG11bHRpOiB0cnVlIH1cbiAqIGBgYFxuICpcbiAqIE9yIGFuIGFycmF5IHRvIGRpcmVjdGx5IHJlZ2lzdGVyIG11bHRpcGxlOlxuICogYGBgdHlwZXNjcmlwdFxuICogIHsgcHJvdmlkZTogSE9PS19YLCB1c2VWYWx1ZTogW3sgLi4uaG9va1ZhbHVlcyB9XSwgbXVsdGk6IHRydWUgfVxuICogYGBgXG4gKlxuICogT3IgYW4gRXh0ZW5zaW9uRmFjdG9yeSB3aGljaCBhbGxvd3MgdG8gZGVmaW5lIGEgZ2V0KCkgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb25cbiAqIGdldHMgY2FsbGVkIG9uIGVhY2ggbmF2aWdhdGlvbiB3aXRoIHRoZSBjdXJyZW50IHJvdXRlIGFuZCBjYW4gcmV0dXJuIHZhbHVlc1xuICogYXN5bmMgKG9ic2VydmFibGUgb3IgcHJvbWlzZSkuXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgeyBwcm92aWRlOiBIT09LX1gsIHVzZUZhY3Rvcnk6IHsgZ2V0OiAocm91dGUpID0+IGRvU29tZXRoaW5nQXN5bmMocm91dGUpIH0sIG11bHRpOiB0cnVlIH1cbiAqIGBgYFxuICovXG5leHBvcnQgdHlwZSBUYWJFeHRlbnNpb24gPSBUYWIgfCBUYWJbXSB8IEV4dGVuc2lvbkZhY3Rvcnk8VGFiPjtcblxuLyoqXG4gKiBBIGhvb2sgdG8gdXNlIGZvciBNdWx0aSBQcm92aWRlciBleHRlbnNpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBIT09LX1RBQlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48VGFiRXh0ZW5zaW9uW10+KCdUYWJzRmFjdG9yeScpO1xuXG4vKipcbiAqIEEgc2VydmljZSB3aGljaCBkZWZpbmVzIHRoZSB1c2VkIHRhYnMuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFRhYnNTZXJ2aWNlIGV4dGVuZHMgU3RhdGVTZXJ2aWNlIGltcGxlbWVudHMgRXh0ZW5zaW9uUG9pbnQ8VGFiRXh0ZW5zaW9uPiB7XG4gIGl0ZW1zJDogT2JzZXJ2YWJsZTxUYWJbXT47XG4gIG9yaWVudGF0aW9uJDogT2JzZXJ2YWJsZTxzdHJpbmc+O1xuICByZWFkb25seSByZWZyZXNoVHJpZ2dlciA9IG5ldyBTdWJqZWN0KCk7XG4gIHJlYWRvbmx5IHN0YXRlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8U2V0PFRhYj4+KG5ldyBTZXQ8VGFiPigpKTtcblxuICAvKipcbiAgICogQWRkaXRpb25hbCBmYWN0b3JpZXMgdGhhdCBjYW4gYmUgYWRkZWQgYnkgcGx1Z2lucy5cbiAgICovXG4gIGZhY3RvcmllczogVGFiRXh0ZW5zaW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGluamVjdG9yOiBJbmplY3RvcixcbiAgICByb3V0ZXI6IFJvdXRlcixcbiAgICBwcml2YXRlIHRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0ZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSBvcHRpb25zOiBPcHRpb25zU2VydmljZVxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaXRlbXMkID0gZnJvbVRyaWdnZXIocm91dGVyLCB0aGlzLnJlZnJlc2hUcmlnZ2VyLCBbXG4gICAgICAoKSA9PiB0aGlzLmluamVjdG9yLmdldChIT09LX1RBQlMsIFtdKSxcbiAgICAgICgpID0+IHRoaXMuZmFjdG9yaWVzLFxuICAgICAgc3RhdGVUb0ZhY3RvcnkodGhpcy5zdGF0ZSQpXG4gICAgXSkucGlwZShcbiAgICAgIG1hcCh0YWJzID0+IHRoaXMucHJlcGFyZVRhYnModGFicykpLFxuICAgICAgc2hhcmVSZXBsYXkoMSksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgKTtcblxuICAgIHRoaXMub3JpZW50YXRpb24kID0gdGhpcy5pdGVtcyQucGlwZShcbiAgICAgIG1hcCgodGFiczogVGFiW10pID0+IHtcbiAgICAgICAgY29uc3QgZmlyc3RUYWJXaXRoRGVmaW5lZE9yaWVudGF0aW9uID0gdGFicy5maW5kKHRhYiA9PiB0YWIub3JpZW50YXRpb24pO1xuICAgICAgICBpZiAoZmlyc3RUYWJXaXRoRGVmaW5lZE9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZpcnN0VGFiV2l0aERlZmluZWRPcmllbnRhdGlvbi5vcmllbnRhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRhYnNIb3Jpem9udGFsID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcbiAgICAgIH0pLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICk7XG4gIH1cblxuICBwcmVwYXJlVGFicyh0YWJzKSB7XG4gICAgcmV0dXJuIHRoaXMuc29ydFRhYnMoXG4gICAgICB0YWJzXG4gICAgICAgIC5tYXAodGFiID0+ICh7XG4gICAgICAgICAgLi4udGFiLFxuICAgICAgICAgIHRlbXBsYXRlOiB0YWIudGVtcGxhdGUgaW5zdGFuY2VvZiBWaWV3Q29udGFpbmVyUmVmID8gdGFiLnRlbXBsYXRlIDogdW5kZWZpbmVkXG4gICAgICAgIH0pKVxuICAgICAgICAuZmlsdGVyKCh0YWIsIGluZGV4LCBzZWxmKSA9PiBpbmRleCA9PT0gc2VsZi5maW5kSW5kZXgodCA9PiB0LnBhdGggPT09IHRhYi5wYXRoKSlcbiAgICApO1xuICB9XG5cbiAgc29ydFRhYnModGFicykge1xuICAgIHJldHVybiB0YWJzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IHByaW9yaXR5T3JkZXIgPSAoYi5wcmlvcml0eSB8fCAwKSAtIChhLnByaW9yaXR5IHx8IDApO1xuXG4gICAgICBjb25zdCBhVHJhbnNsYXRlZExhYmVsID0gdGhpcy50cmFuc2xhdGVTZXJ2aWNlLmluc3RhbnQoYS5sYWJlbCk7XG4gICAgICBjb25zdCBiVHJhbnNsYXRlZExhYmVsID0gdGhpcy50cmFuc2xhdGVTZXJ2aWNlLmluc3RhbnQoYi5sYWJlbCk7XG4gICAgICBjb25zdCB0cmFuc2xhdGVkTGFiZWxPcmRlciA9IGFUcmFuc2xhdGVkTGFiZWwubG9jYWxlQ29tcGFyZShiVHJhbnNsYXRlZExhYmVsKTtcblxuICAgICAgcmV0dXJuIHByaW9yaXR5T3JkZXIgfHwgdHJhbnNsYXRlZExhYmVsT3JkZXI7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgZXh0ZW5zaW9uIGZhY3Rvcmllc1xuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLnJlZnJlc2hUcmlnZ2VyLm5leHQoMSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHNldCBvZiBhY3Rpb25zLlxuICAgKi9cbiAgZ2V0IHN0YXRlKCk6IFNldDxUYWI+IHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSQudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBpdGVtIHRvIHRhYnMgYW5kIGVtaXRzIHN0YXRlIGNoYW5nZVxuICAgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbSB0byBhZGQuXG4gICAqL1xuICBhZGQoaXRlbTogVGFiKSB7XG4gICAgdGhpcy5zdGF0ZS5hZGQoaXRlbSk7XG4gICAgdGhpcy5lbWl0TmV3U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgdGFiIGFuZCBlbWl0cyBhIHN0YXRlIGNoYW5nZS5cbiAgICogQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlKGl0ZW06IFRhYikge1xuICAgIHRoaXMuc3RhdGUuZGVsZXRlKGl0ZW0pO1xuICAgIHRoaXMuZW1pdE5ld1N0YXRlKCk7XG4gIH1cblxuICBnZXQgZmlyc3RUYWIkKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zJC5waXBlKFxuICAgICAgbWFwKHRhYnMgPT4gdGFic1swXSksXG4gICAgICBmaWx0ZXIoQm9vbGVhbiksXG4gICAgICBmaXJzdCgpXG4gICAgKTtcbiAgfVxufVxuIl19