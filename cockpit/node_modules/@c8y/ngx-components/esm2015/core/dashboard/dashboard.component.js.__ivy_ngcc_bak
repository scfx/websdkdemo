import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, HostBinding, HostListener, Input, Output } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
/**
 * Displays a CSS grid which is customizable by the customer. You can set
 * `c8y-dashboard-child`-components on it or position any element on it by
 * setting the grid CSS properties. On change (resize, or rearrange) the
 * component emits an change event.
 *
 * ## Example:
 *
 * ```html
 * <c8y-title>Hello from outlet</c8y-title>
 *
 * <c8y-action-bar-item [placement]="'right'">
 *   <button class="btn btn-link" (click)="addRandom()"><i c8yIcon="plus-circle"></i> Add random</button>
 * </c8y-action-bar-item>
 * <c8y-action-bar-item [placement]="'right'">
 *   <button class="btn btn-link" (click)="isFrozen = !isFrozen">
 *     <i [c8yIcon]="isFrozen ? 'lock' : 'unlock'"></i> Toggle freeze
 *   </button>
 * </c8y-action-bar-item>
 *
 * <c8y-dashboard (dashboardChange)="dashboardChange($event)">
 *   <c8y-dashboard-child
 *     [isFrozen]="isFrozen"
 *     title="dynamic"
 *     *ngFor="let widget of widgets"
 *     #current
 *   >
 *     x: {{ current.x }}<br />
 *     y: {{ current.y }}<br />
 *     width: {{ current.width }}<br />
 *     height: {{ current.height }}<br />
 *   </c8y-dashboard-child>
 *   <c8y-dashboard-child
 *     #cpWidget
 *     [isFrozen]="isFrozen"
 *     [x]="0"
 *     [y]="1"
 *     [width]="3"
 *     [height]="2"
 *     [data]="widget"
 *     [class]="'card card-dashboard panel-title-regular panel-content-branded panel-title-overlay'"
 *   >
 *     <c8y-dashboard-child-title>
 *       <span>World!</span>
 *     </c8y-dashboard-child-title>
 *     x: {{ cpWidget.x }}<br />
 *     y: {{ cpWidget.y }}<br />
 *     width: {{ cpWidget.width }}<br />
 *     height: {{ cpWidget.height }}<br />
 *   </c8y-dashboard-child>
 *   <c8y-dashboard-child
 *     #cpWidget2
 *     [isFrozen]="isFrozen"
 *     [x]="8"
 *     [y]="1"
 *     [width]="4"
 *     [height]="4"
 *     [class]="'card card-dashboard panel-content-dark'"
 *   >
 *     <c8y-dashboard-child-title>
 *       <span>Hello!</span>
 *     </c8y-dashboard-child-title>
 *     <c8y-dashboard-child-action>
 *       <a href="" (click)="cpWidget2.isFrozen = !cpWidget2.isFrozen; (false)">
 *         <i [c8yIcon]="cpWidget2.isFrozen ? 'lock' : 'unlock'"></i> Toggle freeze
 *       </a>
 *     </c8y-dashboard-child-action>
 *     x: {{ cpWidget2.x }}<br />
 *     y: {{ cpWidget2.y }}<br />
 *     width: {{ cpWidget2.width }}<br />
 *     height: {{ cpWidget2.height }}<br />
 *   </c8y-dashboard-child>
 *
 *   <c8y-dashboard-child
 *     #cpWidget3
 *     [isFrozen]="isFrozen"
 *     [x]="0"
 *     [y]="3"
 *     [width]="4"
 *     [height]="4"
 *     [class]="'card-dashboard panel-content-transparent'"
 *   >
 *     <c8y-dashboard-child-title *ngIf="showTitle">
 *       <span>Transparent!</span>
 *     </c8y-dashboard-child-title>
 *     <c8y-dashboard-child-action>
 *       <a href="" (click)="showTitle = !showTitle; (false)">
 *         <i [c8yIcon]="'heading'"></i> Hide/show title
 *       </a>
 *     </c8y-dashboard-child-action>
 *     <c8y-dashboard-child-action>
 *       <a href="" (click)="cpWidget3.isFrozen = !cpWidget3.isFrozen; (false)">
 *         <i [c8yIcon]="cpWidget3.isFrozen ? 'lock' : 'unlock'"></i> Toggle freeze
 *       </a>
 *     </c8y-dashboard-child-action>
 *     x: {{ cpWidget3.x }}<br />
 *     y: {{ cpWidget3.y }}<br />
 *     width: {{ cpWidget3.width }}<br />
 *     height: {{ cpWidget3.height }}<br />
 *   </c8y-dashboard-child>
 * </c8y-dashboard>
 * ```
 */
export class DashboardComponent {
    constructor(element, sanitizer) {
        this.element = element;
        this.sanitizer = sanitizer;
        /**
         * All children in that dashboard.
         */
        this.children = [];
        /**
         * The amount of columns on that dashboard.
         */
        this.columns = 12;
        /**
         * The spacing between each children in pixel.
         */
        this.gap = 12;
        /**
         * The amount of rows to dusplay. Set to auto to
         * auto extend the rows.
         */
        this.rows = 'auto';
        /**
         * An event fired if the dashboard was changed.
         */
        this.dashboardChange = new EventEmitter();
        this.lastRow = 1;
        this.DEFAULT_ROW_SIZE = 68;
    }
    /**
     * The current column size.
     */
    get columnSize() {
        return this.dashboardRect.width / this.columns;
    }
    /**
     * The current row size.
     */
    get rowSize() {
        return this.rows === 'auto' ? this.DEFAULT_ROW_SIZE : this.calculateRowSize();
    }
    /**
     * Returns all positioning styles. Nasty workaround for that issue:
     * https://github.com/angular/angular/issues/9343
     */
    get inlineStyle() {
        return this.sanitizer.bypassSecurityTrustStyle(`
        -ms-grid-columns: (1fr)[${this.columns}];
        grid-template-columns: repeat(${this.columns}, 1fr);
        ${this.rows !== 'auto' ? `grid-template-rows: repeat(${this.rows}, 1fr);` : ''}
        grid-auto-rows: ${this.rowSize + this.gap}px;
        -ms-grid-rows: (${this.rowSize + this.gap}px)[${this.rows === 'auto' ? this.lastRow : this.rows}];
        margin: -${this.gap}px -${this.gap}px 0;
      `);
    }
    ngAfterContentInit() {
        this.onResize();
    }
    onResize() {
        this.updateRectSize();
    }
    /**
     * Updates the current rect size of the dashboard.
     */
    updateRectSize() {
        const ele = this.element.nativeElement;
        this.dashboardRect = ele.getBoundingClientRect();
    }
    emitChange(widget) {
        this.dashboardChange.emit({ source: widget, children: this.children });
    }
    calculateRowSize() {
        return this.dashboardRect.height / this.rows;
    }
}
DashboardComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-dashboard',
                template: "<ng-content></ng-content>\n",
                host: {
                    class: 'c8y-grid-dashboard dashboard-grid'
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
DashboardComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: DomSanitizer }
];
DashboardComponent.propDecorators = {
    columns: [{ type: Input }],
    gap: [{ type: Input }],
    rows: [{ type: Input }],
    dashboardChange: [{ type: Output }],
    inlineStyle: [{ type: HostBinding, args: ['attr.style',] }],
    onResize: [{ type: HostListener, args: ['window:resize',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGFzaGJvYXJkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvZGFzaGJvYXJkL2Rhc2hib2FyZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixXQUFXLEVBQ1gsWUFBWSxFQUNaLEtBQUssRUFDTCxNQUFNLEVBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBSXpEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzR0c7QUFTSCxNQUFNLE9BQU8sa0JBQWtCO0lBaUU3QixZQUFvQixPQUFtQixFQUFVLFNBQXVCO1FBQXBELFlBQU8sR0FBUCxPQUFPLENBQVk7UUFBVSxjQUFTLEdBQVQsU0FBUyxDQUFjO1FBaEV4RTs7V0FFRztRQUNILGFBQVEsR0FBOEIsRUFBRSxDQUFDO1FBRXpDOztXQUVHO1FBQ00sWUFBTyxHQUFHLEVBQUUsQ0FBQztRQUV0Qjs7V0FFRztRQUNNLFFBQUcsR0FBRyxFQUFFLENBQUM7UUFFbEI7OztXQUdHO1FBQ00sU0FBSSxHQUFvQixNQUFNLENBQUM7UUFFeEM7O1dBRUc7UUFDTyxvQkFBZSxHQUFHLElBQUksWUFBWSxFQUFtQixDQUFDO1FBR3hELFlBQU8sR0FBRyxDQUFDLENBQUM7UUFDSCxxQkFBZ0IsR0FBRyxFQUFFLENBQUM7SUFvQ29DLENBQUM7SUFsQzVFOztPQUVHO0lBQ0gsSUFBSSxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ2pELENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksT0FBTztRQUNULE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7SUFDaEYsQ0FBQztJQUVEOzs7T0FHRztJQUNILElBQ0ksV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyx3QkFBd0IsQ0FDNUM7a0NBQzRCLElBQUksQ0FBQyxPQUFPO3dDQUNOLElBQUksQ0FBQyxPQUFPO1VBQzFDLElBQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyw4QkFBOEIsSUFBSSxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFOzBCQUM1RCxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHOzBCQUN2QixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLE9BQ3pDLElBQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFDN0M7bUJBQ2EsSUFBSSxDQUFDLEdBQUcsT0FBTyxJQUFJLENBQUMsR0FBRztPQUNuQyxDQUNGLENBQUM7SUFDSixDQUFDO0lBSUQsa0JBQWtCO1FBQ2hCLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNsQixDQUFDO0lBR0QsUUFBUTtRQUNOLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxjQUFjO1FBQ1osTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUE0QixDQUFDO1FBQ3RELElBQUksQ0FBQyxhQUFhLEdBQUcsR0FBRyxDQUFDLHFCQUFxQixFQUFFLENBQUM7SUFDbkQsQ0FBQztJQUVELFVBQVUsQ0FBQyxNQUErQjtRQUN4QyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFTyxnQkFBZ0I7UUFDdEIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sR0FBSSxJQUFJLENBQUMsSUFBZSxDQUFDO0lBQzNELENBQUM7OztZQWxHRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGVBQWU7Z0JBQ3pCLHVDQUF5QztnQkFDekMsSUFBSSxFQUFFO29CQUNKLEtBQUssRUFBRSxtQ0FBbUM7aUJBQzNDO2dCQUNELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2FBQ2hEOzs7WUF6SEMsVUFBVTtZQU9ILFlBQVk7OztzQkE0SGxCLEtBQUs7a0JBS0wsS0FBSzttQkFNTCxLQUFLOzhCQUtMLE1BQU07MEJBd0JOLFdBQVcsU0FBQyxZQUFZO3VCQXNCeEIsWUFBWSxTQUFDLGVBQWUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RCaW5kaW5nLFxuICBIb3N0TGlzdGVuZXIsXG4gIElucHV0LFxuICBPdXRwdXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEb21TYW5pdGl6ZXIgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IERhc2hib2FyZENoaWxkQ29tcG9uZW50IH0gZnJvbSAnLi9kYXNoYm9hcmQtY2hpbGQuY29tcG9uZW50JztcbmltcG9ydCB7IERhc2hib2FyZENoYW5nZSB9IGZyb20gJy4vZGFzaGJvYXJkLm1vZGVsJztcblxuLyoqXG4gKiBEaXNwbGF5cyBhIENTUyBncmlkIHdoaWNoIGlzIGN1c3RvbWl6YWJsZSBieSB0aGUgY3VzdG9tZXIuIFlvdSBjYW4gc2V0XG4gKiBgYzh5LWRhc2hib2FyZC1jaGlsZGAtY29tcG9uZW50cyBvbiBpdCBvciBwb3NpdGlvbiBhbnkgZWxlbWVudCBvbiBpdCBieVxuICogc2V0dGluZyB0aGUgZ3JpZCBDU1MgcHJvcGVydGllcy4gT24gY2hhbmdlIChyZXNpemUsIG9yIHJlYXJyYW5nZSkgdGhlXG4gKiBjb21wb25lbnQgZW1pdHMgYW4gY2hhbmdlIGV2ZW50LlxuICpcbiAqICMjIEV4YW1wbGU6XG4gKlxuICogYGBgaHRtbFxuICogPGM4eS10aXRsZT5IZWxsbyBmcm9tIG91dGxldDwvYzh5LXRpdGxlPlxuICpcbiAqIDxjOHktYWN0aW9uLWJhci1pdGVtIFtwbGFjZW1lbnRdPVwiJ3JpZ2h0J1wiPlxuICogICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1saW5rXCIgKGNsaWNrKT1cImFkZFJhbmRvbSgpXCI+PGkgYzh5SWNvbj1cInBsdXMtY2lyY2xlXCI+PC9pPiBBZGQgcmFuZG9tPC9idXR0b24+XG4gKiA8L2M4eS1hY3Rpb24tYmFyLWl0ZW0+XG4gKiA8Yzh5LWFjdGlvbi1iYXItaXRlbSBbcGxhY2VtZW50XT1cIidyaWdodCdcIj5cbiAqICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tbGlua1wiIChjbGljayk9XCJpc0Zyb3plbiA9ICFpc0Zyb3plblwiPlxuICogICAgIDxpIFtjOHlJY29uXT1cImlzRnJvemVuID8gJ2xvY2snIDogJ3VubG9jaydcIj48L2k+IFRvZ2dsZSBmcmVlemVcbiAqICAgPC9idXR0b24+XG4gKiA8L2M4eS1hY3Rpb24tYmFyLWl0ZW0+XG4gKlxuICogPGM4eS1kYXNoYm9hcmQgKGRhc2hib2FyZENoYW5nZSk9XCJkYXNoYm9hcmRDaGFuZ2UoJGV2ZW50KVwiPlxuICogICA8Yzh5LWRhc2hib2FyZC1jaGlsZFxuICogICAgIFtpc0Zyb3plbl09XCJpc0Zyb3plblwiXG4gKiAgICAgdGl0bGU9XCJkeW5hbWljXCJcbiAqICAgICAqbmdGb3I9XCJsZXQgd2lkZ2V0IG9mIHdpZGdldHNcIlxuICogICAgICNjdXJyZW50XG4gKiAgID5cbiAqICAgICB4OiB7eyBjdXJyZW50LnggfX08YnIgLz5cbiAqICAgICB5OiB7eyBjdXJyZW50LnkgfX08YnIgLz5cbiAqICAgICB3aWR0aDoge3sgY3VycmVudC53aWR0aCB9fTxiciAvPlxuICogICAgIGhlaWdodDoge3sgY3VycmVudC5oZWlnaHQgfX08YnIgLz5cbiAqICAgPC9jOHktZGFzaGJvYXJkLWNoaWxkPlxuICogICA8Yzh5LWRhc2hib2FyZC1jaGlsZFxuICogICAgICNjcFdpZGdldFxuICogICAgIFtpc0Zyb3plbl09XCJpc0Zyb3plblwiXG4gKiAgICAgW3hdPVwiMFwiXG4gKiAgICAgW3ldPVwiMVwiXG4gKiAgICAgW3dpZHRoXT1cIjNcIlxuICogICAgIFtoZWlnaHRdPVwiMlwiXG4gKiAgICAgW2RhdGFdPVwid2lkZ2V0XCJcbiAqICAgICBbY2xhc3NdPVwiJ2NhcmQgY2FyZC1kYXNoYm9hcmQgcGFuZWwtdGl0bGUtcmVndWxhciBwYW5lbC1jb250ZW50LWJyYW5kZWQgcGFuZWwtdGl0bGUtb3ZlcmxheSdcIlxuICogICA+XG4gKiAgICAgPGM4eS1kYXNoYm9hcmQtY2hpbGQtdGl0bGU+XG4gKiAgICAgICA8c3Bhbj5Xb3JsZCE8L3NwYW4+XG4gKiAgICAgPC9jOHktZGFzaGJvYXJkLWNoaWxkLXRpdGxlPlxuICogICAgIHg6IHt7IGNwV2lkZ2V0LnggfX08YnIgLz5cbiAqICAgICB5OiB7eyBjcFdpZGdldC55IH19PGJyIC8+XG4gKiAgICAgd2lkdGg6IHt7IGNwV2lkZ2V0LndpZHRoIH19PGJyIC8+XG4gKiAgICAgaGVpZ2h0OiB7eyBjcFdpZGdldC5oZWlnaHQgfX08YnIgLz5cbiAqICAgPC9jOHktZGFzaGJvYXJkLWNoaWxkPlxuICogICA8Yzh5LWRhc2hib2FyZC1jaGlsZFxuICogICAgICNjcFdpZGdldDJcbiAqICAgICBbaXNGcm96ZW5dPVwiaXNGcm96ZW5cIlxuICogICAgIFt4XT1cIjhcIlxuICogICAgIFt5XT1cIjFcIlxuICogICAgIFt3aWR0aF09XCI0XCJcbiAqICAgICBbaGVpZ2h0XT1cIjRcIlxuICogICAgIFtjbGFzc109XCInY2FyZCBjYXJkLWRhc2hib2FyZCBwYW5lbC1jb250ZW50LWRhcmsnXCJcbiAqICAgPlxuICogICAgIDxjOHktZGFzaGJvYXJkLWNoaWxkLXRpdGxlPlxuICogICAgICAgPHNwYW4+SGVsbG8hPC9zcGFuPlxuICogICAgIDwvYzh5LWRhc2hib2FyZC1jaGlsZC10aXRsZT5cbiAqICAgICA8Yzh5LWRhc2hib2FyZC1jaGlsZC1hY3Rpb24+XG4gKiAgICAgICA8YSBocmVmPVwiXCIgKGNsaWNrKT1cImNwV2lkZ2V0Mi5pc0Zyb3plbiA9ICFjcFdpZGdldDIuaXNGcm96ZW47IChmYWxzZSlcIj5cbiAqICAgICAgICAgPGkgW2M4eUljb25dPVwiY3BXaWRnZXQyLmlzRnJvemVuID8gJ2xvY2snIDogJ3VubG9jaydcIj48L2k+IFRvZ2dsZSBmcmVlemVcbiAqICAgICAgIDwvYT5cbiAqICAgICA8L2M4eS1kYXNoYm9hcmQtY2hpbGQtYWN0aW9uPlxuICogICAgIHg6IHt7IGNwV2lkZ2V0Mi54IH19PGJyIC8+XG4gKiAgICAgeToge3sgY3BXaWRnZXQyLnkgfX08YnIgLz5cbiAqICAgICB3aWR0aDoge3sgY3BXaWRnZXQyLndpZHRoIH19PGJyIC8+XG4gKiAgICAgaGVpZ2h0OiB7eyBjcFdpZGdldDIuaGVpZ2h0IH19PGJyIC8+XG4gKiAgIDwvYzh5LWRhc2hib2FyZC1jaGlsZD5cbiAqXG4gKiAgIDxjOHktZGFzaGJvYXJkLWNoaWxkXG4gKiAgICAgI2NwV2lkZ2V0M1xuICogICAgIFtpc0Zyb3plbl09XCJpc0Zyb3plblwiXG4gKiAgICAgW3hdPVwiMFwiXG4gKiAgICAgW3ldPVwiM1wiXG4gKiAgICAgW3dpZHRoXT1cIjRcIlxuICogICAgIFtoZWlnaHRdPVwiNFwiXG4gKiAgICAgW2NsYXNzXT1cIidjYXJkLWRhc2hib2FyZCBwYW5lbC1jb250ZW50LXRyYW5zcGFyZW50J1wiXG4gKiAgID5cbiAqICAgICA8Yzh5LWRhc2hib2FyZC1jaGlsZC10aXRsZSAqbmdJZj1cInNob3dUaXRsZVwiPlxuICogICAgICAgPHNwYW4+VHJhbnNwYXJlbnQhPC9zcGFuPlxuICogICAgIDwvYzh5LWRhc2hib2FyZC1jaGlsZC10aXRsZT5cbiAqICAgICA8Yzh5LWRhc2hib2FyZC1jaGlsZC1hY3Rpb24+XG4gKiAgICAgICA8YSBocmVmPVwiXCIgKGNsaWNrKT1cInNob3dUaXRsZSA9ICFzaG93VGl0bGU7IChmYWxzZSlcIj5cbiAqICAgICAgICAgPGkgW2M4eUljb25dPVwiJ2hlYWRpbmcnXCI+PC9pPiBIaWRlL3Nob3cgdGl0bGVcbiAqICAgICAgIDwvYT5cbiAqICAgICA8L2M4eS1kYXNoYm9hcmQtY2hpbGQtYWN0aW9uPlxuICogICAgIDxjOHktZGFzaGJvYXJkLWNoaWxkLWFjdGlvbj5cbiAqICAgICAgIDxhIGhyZWY9XCJcIiAoY2xpY2spPVwiY3BXaWRnZXQzLmlzRnJvemVuID0gIWNwV2lkZ2V0My5pc0Zyb3plbjsgKGZhbHNlKVwiPlxuICogICAgICAgICA8aSBbYzh5SWNvbl09XCJjcFdpZGdldDMuaXNGcm96ZW4gPyAnbG9jaycgOiAndW5sb2NrJ1wiPjwvaT4gVG9nZ2xlIGZyZWV6ZVxuICogICAgICAgPC9hPlxuICogICAgIDwvYzh5LWRhc2hib2FyZC1jaGlsZC1hY3Rpb24+XG4gKiAgICAgeDoge3sgY3BXaWRnZXQzLnggfX08YnIgLz5cbiAqICAgICB5OiB7eyBjcFdpZGdldDMueSB9fTxiciAvPlxuICogICAgIHdpZHRoOiB7eyBjcFdpZGdldDMud2lkdGggfX08YnIgLz5cbiAqICAgICBoZWlnaHQ6IHt7IGNwV2lkZ2V0My5oZWlnaHQgfX08YnIgLz5cbiAqICAgPC9jOHktZGFzaGJvYXJkLWNoaWxkPlxuICogPC9jOHktZGFzaGJvYXJkPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2M4eS1kYXNoYm9hcmQnLFxuICB0ZW1wbGF0ZVVybDogJy4vZGFzaGJvYXJkLmNvbXBvbmVudC5odG1sJyxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnYzh5LWdyaWQtZGFzaGJvYXJkIGRhc2hib2FyZC1ncmlkJ1xuICB9LFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBEYXNoYm9hcmRDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgLyoqXG4gICAqIEFsbCBjaGlsZHJlbiBpbiB0aGF0IGRhc2hib2FyZC5cbiAgICovXG4gIGNoaWxkcmVuOiBEYXNoYm9hcmRDaGlsZENvbXBvbmVudFtdID0gW107XG5cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgY29sdW1ucyBvbiB0aGF0IGRhc2hib2FyZC5cbiAgICovXG4gIEBJbnB1dCgpIGNvbHVtbnMgPSAxMjtcblxuICAvKipcbiAgICogVGhlIHNwYWNpbmcgYmV0d2VlbiBlYWNoIGNoaWxkcmVuIGluIHBpeGVsLlxuICAgKi9cbiAgQElucHV0KCkgZ2FwID0gMTI7XG5cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2Ygcm93cyB0byBkdXNwbGF5LiBTZXQgdG8gYXV0byB0b1xuICAgKiBhdXRvIGV4dGVuZCB0aGUgcm93cy5cbiAgICovXG4gIEBJbnB1dCgpIHJvd3M6IG51bWJlciB8ICdhdXRvJyA9ICdhdXRvJztcblxuICAvKipcbiAgICogQW4gZXZlbnQgZmlyZWQgaWYgdGhlIGRhc2hib2FyZCB3YXMgY2hhbmdlZC5cbiAgICovXG4gIEBPdXRwdXQoKSBkYXNoYm9hcmRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERhc2hib2FyZENoYW5nZT4oKTtcblxuICBkYXNoYm9hcmRSZWN0O1xuICBwcml2YXRlIGxhc3RSb3cgPSAxO1xuICBwcml2YXRlIHJlYWRvbmx5IERFRkFVTFRfUk9XX1NJWkUgPSA2ODtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgY29sdW1uIHNpemUuXG4gICAqL1xuICBnZXQgY29sdW1uU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXNoYm9hcmRSZWN0LndpZHRoIC8gdGhpcy5jb2x1bW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHJvdyBzaXplLlxuICAgKi9cbiAgZ2V0IHJvd1NpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucm93cyA9PT0gJ2F1dG8nID8gdGhpcy5ERUZBVUxUX1JPV19TSVpFIDogdGhpcy5jYWxjdWxhdGVSb3dTaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgcG9zaXRpb25pbmcgc3R5bGVzLiBOYXN0eSB3b3JrYXJvdW5kIGZvciB0aGF0IGlzc3VlOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy85MzQzXG4gICAqL1xuICBASG9zdEJpbmRpbmcoJ2F0dHIuc3R5bGUnKVxuICBnZXQgaW5saW5lU3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FuaXRpemVyLmJ5cGFzc1NlY3VyaXR5VHJ1c3RTdHlsZShcbiAgICAgIGBcbiAgICAgICAgLW1zLWdyaWQtY29sdW1uczogKDFmcilbJHt0aGlzLmNvbHVtbnN9XTtcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoJHt0aGlzLmNvbHVtbnN9LCAxZnIpO1xuICAgICAgICAke3RoaXMucm93cyAhPT0gJ2F1dG8nID8gYGdyaWQtdGVtcGxhdGUtcm93czogcmVwZWF0KCR7dGhpcy5yb3dzfSwgMWZyKTtgIDogJyd9XG4gICAgICAgIGdyaWQtYXV0by1yb3dzOiAke3RoaXMucm93U2l6ZSArIHRoaXMuZ2FwfXB4O1xuICAgICAgICAtbXMtZ3JpZC1yb3dzOiAoJHt0aGlzLnJvd1NpemUgKyB0aGlzLmdhcH1weClbJHtcbiAgICAgICAgdGhpcy5yb3dzID09PSAnYXV0bycgPyB0aGlzLmxhc3RSb3cgOiB0aGlzLnJvd3NcbiAgICAgIH1dO1xuICAgICAgICBtYXJnaW46IC0ke3RoaXMuZ2FwfXB4IC0ke3RoaXMuZ2FwfXB4IDA7XG4gICAgICBgXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZiwgcHJpdmF0ZSBzYW5pdGl6ZXI6IERvbVNhbml0aXplcikge31cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignd2luZG93OnJlc2l6ZScpXG4gIG9uUmVzaXplKCkge1xuICAgIHRoaXMudXBkYXRlUmVjdFNpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IHJlY3Qgc2l6ZSBvZiB0aGUgZGFzaGJvYXJkLlxuICAgKi9cbiAgdXBkYXRlUmVjdFNpemUoKSB7XG4gICAgY29uc3QgZWxlID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgdGhpcy5kYXNoYm9hcmRSZWN0ID0gZWxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG5cbiAgZW1pdENoYW5nZSh3aWRnZXQ6IERhc2hib2FyZENoaWxkQ29tcG9uZW50KSB7XG4gICAgdGhpcy5kYXNoYm9hcmRDaGFuZ2UuZW1pdCh7IHNvdXJjZTogd2lkZ2V0LCBjaGlsZHJlbjogdGhpcy5jaGlsZHJlbiB9KTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlUm93U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXNoYm9hcmRSZWN0LmhlaWdodCAvICh0aGlzLnJvd3MgYXMgbnVtYmVyKTtcbiAgfVxufVxuIl19