import { Component, ContentChild } from '@angular/core';
import { RangeDirective } from './range.directive';
/**
 * An component which renders a range slider in Cumulocity layout. You need
 * to wrap the default range input in this component.
 *
 * Example:
 * ```
 * <c8y-range>
 *   <input id="range" type="range" min="0" max="100000" value="0" step="1">
 * </c8y-range>
 * ```
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["c8yRangeValue"];
function RangeComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.value);
} }
function RangeComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c1 = ["*"];
export class RangeComponent {
    constructor() {
        this.changeEventListener = () => this.setValue();
    }
    ngAfterContentInit() {
        this.setValue();
        this.range.elementRef.nativeElement.addEventListener('input', this.changeEventListener);
    }
    ngOnDestroy() {
        this.range.elementRef.nativeElement.removeEventListener('input', this.changeEventListener);
    }
    setValue() {
        const range = this.range.elementRef.nativeElement;
        const newValue = Number(((range.value - range.min) * 100) / (range.max - range.min));
        const newPosition = 12 - newValue * 0.24;
        this.value = range.value;
        this.left = `calc(${newValue}% + (${newPosition}px))`;
    }
}
RangeComponent.ɵfac = function RangeComponent_Factory(t) { return new (t || RangeComponent)(); };
RangeComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: RangeComponent, selectors: [["c8y-range"]], contentQueries: function RangeComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, RangeDirective, 7);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c0, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.range = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rangeValue = _t.first);
    } }, ngContentSelectors: _c1, decls: 5, vars: 7, consts: [[1, "range-wrap"], [1, "range-value"], [4, "ngIf"], [4, "ngTemplateOutlet"]], template: function RangeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, RangeComponent_span_2_Template, 2, 1, "span", 2);
        ɵngcc0.ɵɵtemplate(3, RangeComponent_ng_container_3_Template, 1, 0, "ng-container", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleMapInterpolate1("--track-width: ", ctx.left, "");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("left", ctx.left);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.rangeValue);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.rangeValue);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
RangeComponent.propDecorators = {
    range: [{ type: ContentChild, args: [RangeDirective, { static: true },] }],
    rangeValue: [{ type: ContentChild, args: ['c8yRangeValue', { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RangeComponent, [{
        type: Component,
        args: [{
                selector: 'c8y-range',
                template: "<div class=\"range-wrap\" style=\"--track-width: {{left}}\">\n  <div class=\"range-value\" [style.left]=\"left\">\n    <span *ngIf=\"!rangeValue\">{{ value }}</span>\n    <ng-container *ngTemplateOutlet=\"rangeValue\"></ng-container>\n  </div>\n  <ng-content></ng-content>\n</div>\n"
            }]
    }], function () { return []; }, { range: [{
            type: ContentChild,
            args: [RangeDirective, { static: true }]
        }], rangeValue: [{
            type: ContentChild,
            args: ['c8yRangeValue', { static: true }]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UuY29tcG9uZW50LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL2Zvcm1zL3JhbmdlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBMEIsTUFBTSxlQUFlLENBQUM7QUFDaEYsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0gsTUFBTSxPQUFPLGNBQWM7QUFBRyxJQUo5QjtBQUNHLFFBWUQsd0JBQW1CLEdBQWtCLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUM3RCxJQWlCQSxDQUFDO0FBQ0QsSUFqQkUsa0JBQWtCO0FBQUssUUFDckIsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQ3BCLFFBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUM1RixJQUFFLENBQUM7QUFDSCxJQUNFLFdBQVc7QUFBSyxRQUNkLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFDL0YsSUFBRSxDQUFDO0FBQ0gsSUFDRSxRQUFRO0FBQ1YsUUFBSSxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7QUFDdEQsUUFBSSxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUN6RixRQUFJLE1BQU0sV0FBVyxHQUFHLEVBQUUsR0FBRyxRQUFRLEdBQUcsSUFBSSxDQUFDO0FBQzdDLFFBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO0FBQzdCLFFBQUksSUFBSSxDQUFDLElBQUksR0FBRyxRQUFRLFFBQVEsUUFBUSxXQUFXLE1BQU0sQ0FBQztBQUMxRCxJQUFFLENBQUM7QUFDSDswQ0EvQkMsU0FBUyxTQUFDLGtCQUNULFFBQVEsRUFBRTtDQUFXLGtCQUNyQjs7O0NBQXFDLGNBQ3RDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUZBQ0k7QUFBQztBQUFrQyxvQkFDckMsWUFBWSxTQUFDLGNBQWMsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7QUFDM0MseUJBRUYsWUFBWSxTQUFDLGVBQWUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7QUFDN0M7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBPbkRlc3Ryb3ksIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSYW5nZURpcmVjdGl2ZSB9IGZyb20gJy4vcmFuZ2UuZGlyZWN0aXZlJztcblxuLyoqXG4gKiBBbiBjb21wb25lbnQgd2hpY2ggcmVuZGVycyBhIHJhbmdlIHNsaWRlciBpbiBDdW11bG9jaXR5IGxheW91dC4gWW91IG5lZWRcbiAqIHRvIHdyYXAgdGhlIGRlZmF1bHQgcmFuZ2UgaW5wdXQgaW4gdGhpcyBjb21wb25lbnQuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYFxuICogPGM4eS1yYW5nZT5cbiAqICAgPGlucHV0IGlkPVwicmFuZ2VcIiB0eXBlPVwicmFuZ2VcIiBtaW49XCIwXCIgbWF4PVwiMTAwMDAwXCIgdmFsdWU9XCIwXCIgc3RlcD1cIjFcIj5cbiAqIDwvYzh5LXJhbmdlPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2M4eS1yYW5nZScsXG4gIHRlbXBsYXRlVXJsOiAnLi9yYW5nZS5jb21wb25lbnQuaHRtbCcsXG59KVxuZXhwb3J0IGNsYXNzIFJhbmdlQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgQENvbnRlbnRDaGlsZChSYW5nZURpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSlcbiAgcmFuZ2U6IFJhbmdlRGlyZWN0aXZlO1xuXG4gIEBDb250ZW50Q2hpbGQoJ2M4eVJhbmdlVmFsdWUnLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICByYW5nZVZhbHVlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIGxlZnQ6IHN0cmluZztcbiAgdmFsdWU6IHN0cmluZztcbiAgY2hhbmdlRXZlbnRMaXN0ZW5lcjogRXZlbnRMaXN0ZW5lciA9ICgpID0+IHRoaXMuc2V0VmFsdWUoKTtcblxuICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5zZXRWYWx1ZSgpO1xuICAgIHRoaXMucmFuZ2UuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5jaGFuZ2VFdmVudExpc3RlbmVyKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMucmFuZ2UuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5jaGFuZ2VFdmVudExpc3RlbmVyKTtcbiAgfVxuXG4gIHNldFZhbHVlKCkge1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5yYW5nZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBOdW1iZXIoKChyYW5nZS52YWx1ZSAtIHJhbmdlLm1pbikgKiAxMDApIC8gKHJhbmdlLm1heCAtIHJhbmdlLm1pbikpO1xuICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gMTIgLSBuZXdWYWx1ZSAqIDAuMjQ7XG4gICAgdGhpcy52YWx1ZSA9IHJhbmdlLnZhbHVlO1xuICAgIHRoaXMubGVmdCA9IGBjYWxjKCR7bmV3VmFsdWV9JSArICgke25ld1Bvc2l0aW9ufXB4KSlgO1xuICB9XG59XG4iXX0=