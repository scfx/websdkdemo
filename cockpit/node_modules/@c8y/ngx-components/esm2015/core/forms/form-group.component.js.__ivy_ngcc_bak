import { Component, ContentChild, HostBinding, Input } from '@angular/core';
import { NgModel } from '@angular/forms';
import { timer, merge } from 'rxjs';
import { debounce, filter } from 'rxjs/operators';
import { MessagesComponent } from './messages.component';
/**
 * A form group helps to validate an input of a form element.
 *
 * ## Example:
 *
 * ```html
 *  <c8y-form-group [hasWarning]="user.email.length === 0">
 *   <label translate for="userEmail">Email</label>
 *   <input
 *     id="userEmail"
 *     class="form-control"
 *     type="email"
 *     name="email"
 *     [maxlength]="254"
 *     autocomplete="off"
 *     placeholder="{{'e.g. joe.doe@example.com' | translate}}"
 *     [(ngModel)]="user.email"
 *     email
 *     required
 *   >
 *   <c8y-messages>
 *     <c8y-message *ngIf="user.email.length === 0" translate></c8y-message>
 *     <c8y-message name="required" text="The E-Mail is SUPER required"></c8y-message>
 *   </c8y-messages>
 *  </c8y-form-group>
 * ```
 *
 * @param status The current status could be error, warning or success.
 * @param hasError Set this to true to display a error.
 * @param hasWarning Set this to true to display a warning.
 * @param hasSuccess Set this to true to display a success.
 * @param novalidation Set this to true to disable automatic validation by this component.
 */
export class FormGroupComponent {
    constructor() {
        this.hasError = false;
        this.hasWarning = false;
        this.hasSuccess = false;
        this.novalidation = false;
        this.VALIDATION_DEBOUNCE_MS = 1000;
    }
    get error() {
        return this.status === 'error' || this.hasError;
    }
    get warning() {
        return this.status === 'warning' || this.hasWarning;
    }
    get success() {
        return this.status === 'success' || this.hasSuccess;
    }
    ngAfterContentInit() {
        this.initNgModel();
    }
    initNgModel() {
        if (this.model) {
            this.model.valueAccessor.registerOnTouched(() => {
                if (this.model.control && !this.model.control.dirty) {
                    this.model.control.markAsDirty();
                    this.model.control.updateValueAndValidity({ onlySelf: true });
                }
            });
            this.subscription = merge(this.model.valueChanges, this.model.statusChanges)
                .pipe(filter(() => this.model.dirty && !this.novalidation), debounce(() => (this.hasError ? timer(10) : timer(this.VALIDATION_DEBOUNCE_MS))))
                .subscribe(() => this.update());
        }
    }
    update() {
        this.hasError = this.model.status === 'INVALID';
        if (this.customErrorMessage) {
            this.customErrorMessage.changVisibility(this.model.errors);
        }
        else {
            this.errors = this.model.errors;
        }
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
FormGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-form-group',
                template: "<ng-content></ng-content>\n<c8y-messages *ngIf=\"!customErrorMessage\" [show]=\"errors\"></c8y-messages>\n",
                host: {
                    class: 'form-group'
                }
            },] }
];
FormGroupComponent.propDecorators = {
    hasError: [{ type: Input }],
    hasWarning: [{ type: Input }],
    hasSuccess: [{ type: Input }],
    novalidation: [{ type: Input }],
    status: [{ type: Input }],
    error: [{ type: HostBinding, args: ['class.has-error',] }],
    warning: [{ type: HostBinding, args: ['class.has-warning',] }],
    success: [{ type: HostBinding, args: ['class.has-success',] }],
    customErrorMessage: [{ type: ContentChild, args: [MessagesComponent, { static: false },] }],
    model: [{ type: ContentChild, args: [NgModel, { static: true },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybS1ncm91cC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL2Zvcm1zL2Zvcm0tZ3JvdXAuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDNUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3pDLE9BQU8sRUFBZ0IsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNsRCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3pEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWdDRztBQVFILE1BQU0sT0FBTyxrQkFBa0I7SUFQL0I7UUFRVyxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ2pCLGVBQVUsR0FBRyxLQUFLLENBQUM7UUFDbkIsZUFBVSxHQUFHLEtBQUssQ0FBQztRQUNuQixpQkFBWSxHQUFHLEtBQUssQ0FBQztRQWdCYiwyQkFBc0IsR0FBRyxJQUFJLENBQUM7SUFxQ2pELENBQUM7SUFuREMsSUFBb0MsS0FBSztRQUN2QyxPQUFPLElBQUksQ0FBQyxNQUFNLEtBQUssT0FBTyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDbEQsQ0FBQztJQUNELElBQXNDLE9BQU87UUFDM0MsT0FBTyxJQUFJLENBQUMsTUFBTSxLQUFLLFNBQVMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQ3RELENBQUM7SUFDRCxJQUFzQyxPQUFPO1FBQzNDLE9BQU8sSUFBSSxDQUFDLE1BQU0sS0FBSyxTQUFTLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUN0RCxDQUFDO0lBUUQsa0JBQWtCO1FBQ2hCLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNyQixDQUFDO0lBRUQsV0FBVztRQUNULElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNkLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtnQkFDOUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRTtvQkFDbkQsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUM7b0JBQ2pDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLHNCQUFzQixDQUFDLEVBQUMsUUFBUSxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7aUJBQzdEO1lBQ0gsQ0FBQyxDQUFDLENBQUM7WUFDSCxJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQztpQkFDekUsSUFBSSxDQUNILE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsRUFDcEQsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxDQUNqRjtpQkFDQSxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7U0FDbkM7SUFDSCxDQUFDO0lBRUQsTUFBTTtRQUNKLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssU0FBUyxDQUFDO1FBQ2hELElBQUksSUFBSSxDQUFDLGtCQUFrQixFQUFFO1lBQzNCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUM1RDthQUFNO1lBQ0wsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztTQUNqQztJQUNILENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3JCLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDakM7SUFDSCxDQUFDOzs7WUEvREYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxnQkFBZ0I7Z0JBQzFCLHNIQUEwQztnQkFDMUMsSUFBSSxFQUFFO29CQUNKLEtBQUssRUFBRSxZQUFZO2lCQUNwQjthQUNGOzs7dUJBRUUsS0FBSzt5QkFDTCxLQUFLO3lCQUNMLEtBQUs7MkJBQ0wsS0FBSztxQkFDTCxLQUFLO29CQUNMLFdBQVcsU0FBQyxpQkFBaUI7c0JBRzdCLFdBQVcsU0FBQyxtQkFBbUI7c0JBRy9CLFdBQVcsU0FBQyxtQkFBbUI7aUNBRy9CLFlBQVksU0FBQyxpQkFBaUIsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7b0JBQ2pELFlBQVksU0FBQyxPQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEhvc3RCaW5kaW5nLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdNb2RlbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgdGltZXIsIG1lcmdlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZSwgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgTWVzc2FnZXNDb21wb25lbnQgfSBmcm9tICcuL21lc3NhZ2VzLmNvbXBvbmVudCc7XG4vKipcbiAqIEEgZm9ybSBncm91cCBoZWxwcyB0byB2YWxpZGF0ZSBhbiBpbnB1dCBvZiBhIGZvcm0gZWxlbWVudC5cbiAqXG4gKiAjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGh0bWxcbiAqICA8Yzh5LWZvcm0tZ3JvdXAgW2hhc1dhcm5pbmddPVwidXNlci5lbWFpbC5sZW5ndGggPT09IDBcIj5cbiAqICAgPGxhYmVsIHRyYW5zbGF0ZSBmb3I9XCJ1c2VyRW1haWxcIj5FbWFpbDwvbGFiZWw+XG4gKiAgIDxpbnB1dFxuICogICAgIGlkPVwidXNlckVtYWlsXCJcbiAqICAgICBjbGFzcz1cImZvcm0tY29udHJvbFwiXG4gKiAgICAgdHlwZT1cImVtYWlsXCJcbiAqICAgICBuYW1lPVwiZW1haWxcIlxuICogICAgIFttYXhsZW5ndGhdPVwiMjU0XCJcbiAqICAgICBhdXRvY29tcGxldGU9XCJvZmZcIlxuICogICAgIHBsYWNlaG9sZGVyPVwie3snZS5nLiBqb2UuZG9lQGV4YW1wbGUuY29tJyB8IHRyYW5zbGF0ZX19XCJcbiAqICAgICBbKG5nTW9kZWwpXT1cInVzZXIuZW1haWxcIlxuICogICAgIGVtYWlsXG4gKiAgICAgcmVxdWlyZWRcbiAqICAgPlxuICogICA8Yzh5LW1lc3NhZ2VzPlxuICogICAgIDxjOHktbWVzc2FnZSAqbmdJZj1cInVzZXIuZW1haWwubGVuZ3RoID09PSAwXCIgdHJhbnNsYXRlPjwvYzh5LW1lc3NhZ2U+XG4gKiAgICAgPGM4eS1tZXNzYWdlIG5hbWU9XCJyZXF1aXJlZFwiIHRleHQ9XCJUaGUgRS1NYWlsIGlzIFNVUEVSIHJlcXVpcmVkXCI+PC9jOHktbWVzc2FnZT5cbiAqICAgPC9jOHktbWVzc2FnZXM+XG4gKiAgPC9jOHktZm9ybS1ncm91cD5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzdGF0dXMgVGhlIGN1cnJlbnQgc3RhdHVzIGNvdWxkIGJlIGVycm9yLCB3YXJuaW5nIG9yIHN1Y2Nlc3MuXG4gKiBAcGFyYW0gaGFzRXJyb3IgU2V0IHRoaXMgdG8gdHJ1ZSB0byBkaXNwbGF5IGEgZXJyb3IuXG4gKiBAcGFyYW0gaGFzV2FybmluZyBTZXQgdGhpcyB0byB0cnVlIHRvIGRpc3BsYXkgYSB3YXJuaW5nLlxuICogQHBhcmFtIGhhc1N1Y2Nlc3MgU2V0IHRoaXMgdG8gdHJ1ZSB0byBkaXNwbGF5IGEgc3VjY2Vzcy5cbiAqIEBwYXJhbSBub3ZhbGlkYXRpb24gU2V0IHRoaXMgdG8gdHJ1ZSB0byBkaXNhYmxlIGF1dG9tYXRpYyB2YWxpZGF0aW9uIGJ5IHRoaXMgY29tcG9uZW50LlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjOHktZm9ybS1ncm91cCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9mb3JtLWdyb3VwLmNvbXBvbmVudC5odG1sJyxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnZm9ybS1ncm91cCdcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBGb3JtR3JvdXBDb21wb25lbnQge1xuICBASW5wdXQoKSBoYXNFcnJvciA9IGZhbHNlO1xuICBASW5wdXQoKSBoYXNXYXJuaW5nID0gZmFsc2U7XG4gIEBJbnB1dCgpIGhhc1N1Y2Nlc3MgPSBmYWxzZTtcbiAgQElucHV0KCkgbm92YWxpZGF0aW9uID0gZmFsc2U7XG4gIEBJbnB1dCgpIHN0YXR1czogc3RyaW5nO1xuICBASG9zdEJpbmRpbmcoJ2NsYXNzLmhhcy1lcnJvcicpIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdlcnJvcicgfHwgdGhpcy5oYXNFcnJvcjtcbiAgfVxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLmhhcy13YXJuaW5nJykgZ2V0IHdhcm5pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnd2FybmluZycgfHwgdGhpcy5oYXNXYXJuaW5nO1xuICB9XG4gIEBIb3N0QmluZGluZygnY2xhc3MuaGFzLXN1Y2Nlc3MnKSBnZXQgc3VjY2VzcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJyB8fCB0aGlzLmhhc1N1Y2Nlc3M7XG4gIH1cbiAgQENvbnRlbnRDaGlsZChNZXNzYWdlc0NvbXBvbmVudCwgeyBzdGF0aWM6IGZhbHNlIH0pIGN1c3RvbUVycm9yTWVzc2FnZTogTWVzc2FnZXNDb21wb25lbnQ7XG4gIEBDb250ZW50Q2hpbGQoTmdNb2RlbCwgeyBzdGF0aWM6IHRydWUgfSkgbW9kZWw6IE5nTW9kZWw7XG5cbiAgZXJyb3JzOiB7fTtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSByZWFkb25seSBWQUxJREFUSU9OX0RFQk9VTkNFX01TID0gMTAwMDtcblxuICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5pbml0TmdNb2RlbCgpO1xuICB9XG5cbiAgaW5pdE5nTW9kZWwoKSB7XG4gICAgaWYgKHRoaXMubW9kZWwpIHtcbiAgICAgIHRoaXMubW9kZWwudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uVG91Y2hlZCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmNvbnRyb2wgJiYgIXRoaXMubW9kZWwuY29udHJvbC5kaXJ0eSkge1xuICAgICAgICAgIHRoaXMubW9kZWwuY29udHJvbC5tYXJrQXNEaXJ0eSgpO1xuICAgICAgICAgIHRoaXMubW9kZWwuY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHtvbmx5U2VsZjogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbWVyZ2UodGhpcy5tb2RlbC52YWx1ZUNoYW5nZXMsIHRoaXMubW9kZWwuc3RhdHVzQ2hhbmdlcylcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMubW9kZWwuZGlydHkgJiYgIXRoaXMubm92YWxpZGF0aW9uKSxcbiAgICAgICAgICBkZWJvdW5jZSgoKSA9PiAodGhpcy5oYXNFcnJvciA/IHRpbWVyKDEwKSA6IHRpbWVyKHRoaXMuVkFMSURBVElPTl9ERUJPVU5DRV9NUykpKVxuICAgICAgICApXG4gICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGUoKSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuaGFzRXJyb3IgPSB0aGlzLm1vZGVsLnN0YXR1cyA9PT0gJ0lOVkFMSUQnO1xuICAgIGlmICh0aGlzLmN1c3RvbUVycm9yTWVzc2FnZSkge1xuICAgICAgdGhpcy5jdXN0b21FcnJvck1lc3NhZ2UuY2hhbmdWaXNpYmlsaXR5KHRoaXMubW9kZWwuZXJyb3JzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lcnJvcnMgPSB0aGlzLm1vZGVsLmVycm9ycztcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG59XG4iXX0=