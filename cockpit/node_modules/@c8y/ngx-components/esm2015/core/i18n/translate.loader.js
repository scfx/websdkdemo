import { HttpClient } from '@angular/common/http';
import { of } from 'rxjs';
import { map, catchError, tap } from 'rxjs/operators';
import { Inject, Injectable } from '@angular/core';
import { LOCALE_PATH } from './locale.path';
import { LANGUAGES } from './languages';
import { OptionsService } from '../common/options.service';
import { mapKeys } from 'lodash-es';
import { CachedLocaleDictionaryService } from './cached-locale-dictionary.service';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common/http';
import * as ɵngcc2 from '../common/options.service';
import * as ɵngcc3 from './cached-locale-dictionary.service';
export class TranslateCustomLoader {
    constructor(http, optionsService, cachedLocaleDictionaryService, path = null, languages = null) {
        this.http = http;
        this.optionsService = optionsService;
        this.cachedLocaleDictionaryService = cachedLocaleDictionaryService;
        this.path = path;
        this.languages = languages;
    }
    getTranslation(lang) {
        const path = this.path || '';
        let url = `${path}${lang}.json`;
        if (this.languages && this.languages[lang] && this.languages[lang].url) {
            url = this.languages[lang].url;
        }
        return this.http.get(url).pipe(map(d => {
            if (this.optionsService.langsDetails && this.optionsService.langsDetails[lang]) {
                return Object.assign(Object.assign({}, d[lang]), this.optionsService.langsDetails[lang]);
            }
            return d[lang];
        }), tap(dictionary => {
            this.cachedLocaleDictionaryService.cachedDictionary[lang] = dictionary;
        }), map(dictionary => this.getDictionaryWithTrimmedKeys(dictionary)), catchError(() => of({})));
    }
    /**
     * We want to have translation keys unified, so they don't contain unnecessary spaces and line breaks.
     * This way we can dynamically build keys from HTML, and match them to extracted string, that might be HTML as well.
     */
    getDictionaryWithTrimmedKeys(dictionary) {
        return mapKeys(dictionary, (value, key) => trimTranslationKey(key));
    }
}
TranslateCustomLoader.ɵfac = function TranslateCustomLoader_Factory(t) { return new (t || TranslateCustomLoader)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(ɵngcc2.OptionsService), ɵngcc0.ɵɵinject(ɵngcc3.CachedLocaleDictionaryService), ɵngcc0.ɵɵinject(LOCALE_PATH), ɵngcc0.ɵɵinject(LANGUAGES)); };
TranslateCustomLoader.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: TranslateCustomLoader, factory: TranslateCustomLoader.ɵfac });
TranslateCustomLoader.ctorParameters = () => [
    { type: HttpClient },
    { type: OptionsService },
    { type: CachedLocaleDictionaryService },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_PATH,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [LANGUAGES,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TranslateCustomLoader, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: ɵngcc2.OptionsService }, { type: ɵngcc3.CachedLocaleDictionaryService }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_PATH]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [LANGUAGES]
            }] }]; }, null); })();
export function trimTranslationKey(key) {
    return key.replace(/(\r\n|\n|\r)/gm, '').replace(/\s{2,}/g, ' ').trim();
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRlLmxvYWRlci5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9pMThuL3RyYW5zbGF0ZS5sb2FkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRWxELE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDdEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM1QyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3BDLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLG9DQUFvQyxDQUFDOzs7OztBQUduRixNQUFNLE9BQU8scUJBQXFCO0FBQUcsSUFDbkMsWUFDVSxJQUFnQixFQUNoQixjQUE4QixFQUM5Qiw2QkFBNEQsRUFDdkMsT0FBZSxJQUFJLEVBQ3JCLFlBQWlCLElBQUk7QUFDakQsUUFMUyxTQUFJLEdBQUosSUFBSSxDQUFZO0FBQUMsUUFDakIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO0FBQUMsUUFDL0Isa0NBQTZCLEdBQTdCLDZCQUE2QixDQUErQjtBQUFDLFFBQ3hDLFNBQUksR0FBSixJQUFJLENBQWU7QUFBQyxRQUN0QixjQUFTLEdBQVQsU0FBUyxDQUFZO0FBQ3BELElBQUssQ0FBQztBQUNOLElBQ0UsY0FBYyxDQUFDLElBQVk7QUFBSSxRQUM3QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztBQUNqQyxRQUFJLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLElBQUksT0FBTyxDQUFDO0FBQ3BDLFFBQUksSUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUU7QUFDNUUsWUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDckMsU0FBSztBQUNMLFFBQ0ksT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQzVCLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUNkLFlBQVEsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUN4RixnQkFBVSx1Q0FBWSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUssSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUc7QUFDM0UsYUFBUztBQUNULFlBQVEsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDdkIsUUFBTSxDQUFDLENBQUMsRUFDRixHQUFHLENBQUMsVUFBVSxDQUFDLEVBQUU7QUFDdkIsWUFBUSxJQUFJLENBQUMsNkJBQTZCLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFDO0FBQy9FLFFBQU0sQ0FBQyxDQUFDLEVBQ0YsR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLDRCQUE0QixDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQ2hFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FDekIsQ0FBQztBQUNOLElBQUUsQ0FBQztBQUNILElBQ0U7QUFDRjtBQUNFO0FBQ0UsT0FBQztBQUNMLElBQUUsNEJBQTRCLENBQUMsVUFBa0I7QUFDakQsUUFBSSxPQUFPLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FDeEMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQ3hCLENBQUM7QUFDTixJQUFFLENBQUM7QUFDSDtpREF6Q0MsVUFBVTs2SUFDVDtBQUFDO0FBQStDLFlBWnpDLFVBQVU7QUFBSSxZQU9kLGNBQWM7QUFBSSxZQUVsQiw2QkFBNkI7QUFBSSx5Q0FRckMsTUFBTSxTQUFDLFdBQVc7QUFBUyw0Q0FDM0IsTUFBTSxTQUFDLFNBQVM7QUFBUTs7Ozs7Ozs7O2tDQUFFO0FBcUMvQixNQUFNLFVBQVUsa0JBQWtCLENBQUMsR0FBRztBQUN0QyxJQUFFLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0FBQzFFLENBQUM7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBUcmFuc2xhdGVMb2FkZXIgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAsIGNhdGNoRXJyb3IsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTE9DQUxFX1BBVEggfSBmcm9tICcuL2xvY2FsZS5wYXRoJztcbmltcG9ydCB7IExBTkdVQUdFUyB9IGZyb20gJy4vbGFuZ3VhZ2VzJztcbmltcG9ydCB7IE9wdGlvbnNTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL29wdGlvbnMuc2VydmljZSc7XG5pbXBvcnQgeyBtYXBLZXlzIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IENhY2hlZExvY2FsZURpY3Rpb25hcnlTZXJ2aWNlIH0gZnJvbSAnLi9jYWNoZWQtbG9jYWxlLWRpY3Rpb25hcnkuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUcmFuc2xhdGVDdXN0b21Mb2FkZXIgaW1wbGVtZW50cyBUcmFuc2xhdGVMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGh0dHA6IEh0dHBDbGllbnQsXG4gICAgcHJpdmF0ZSBvcHRpb25zU2VydmljZTogT3B0aW9uc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBjYWNoZWRMb2NhbGVEaWN0aW9uYXJ5U2VydmljZTogQ2FjaGVkTG9jYWxlRGljdGlvbmFyeVNlcnZpY2UsXG4gICAgQEluamVjdChMT0NBTEVfUEFUSCkgcHJpdmF0ZSBwYXRoOiBzdHJpbmcgPSBudWxsLFxuICAgIEBJbmplY3QoTEFOR1VBR0VTKSBwcml2YXRlIGxhbmd1YWdlczogYW55ID0gbnVsbFxuICApIHt9XG5cbiAgZ2V0VHJhbnNsYXRpb24obGFuZzogc3RyaW5nKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5wYXRoIHx8ICcnO1xuICAgIGxldCB1cmwgPSBgJHtwYXRofSR7bGFuZ30uanNvbmA7XG4gICAgaWYgKHRoaXMubGFuZ3VhZ2VzICYmIHRoaXMubGFuZ3VhZ2VzW2xhbmddICYmIHRoaXMubGFuZ3VhZ2VzW2xhbmddLnVybCkge1xuICAgICAgdXJsID0gdGhpcy5sYW5ndWFnZXNbbGFuZ10udXJsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmh0dHAuZ2V0KHVybCkucGlwZShcbiAgICAgIG1hcChkID0+IHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1NlcnZpY2UubGFuZ3NEZXRhaWxzICYmIHRoaXMub3B0aW9uc1NlcnZpY2UubGFuZ3NEZXRhaWxzW2xhbmddKSB7XG4gICAgICAgICAgcmV0dXJuIHsgLi4uZFtsYW5nXSwgLi4udGhpcy5vcHRpb25zU2VydmljZS5sYW5nc0RldGFpbHNbbGFuZ10gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZFtsYW5nXTtcbiAgICAgIH0pLFxuICAgICAgdGFwKGRpY3Rpb25hcnkgPT4ge1xuICAgICAgICB0aGlzLmNhY2hlZExvY2FsZURpY3Rpb25hcnlTZXJ2aWNlLmNhY2hlZERpY3Rpb25hcnlbbGFuZ10gPSBkaWN0aW9uYXJ5O1xuICAgICAgfSksXG4gICAgICBtYXAoZGljdGlvbmFyeSA9PiB0aGlzLmdldERpY3Rpb25hcnlXaXRoVHJpbW1lZEtleXMoZGljdGlvbmFyeSkpLFxuICAgICAgY2F0Y2hFcnJvcigoKSA9PiBvZih7fSkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSB3YW50IHRvIGhhdmUgdHJhbnNsYXRpb24ga2V5cyB1bmlmaWVkLCBzbyB0aGV5IGRvbid0IGNvbnRhaW4gdW5uZWNlc3Nhcnkgc3BhY2VzIGFuZCBsaW5lIGJyZWFrcy5cbiAgICogVGhpcyB3YXkgd2UgY2FuIGR5bmFtaWNhbGx5IGJ1aWxkIGtleXMgZnJvbSBIVE1MLCBhbmQgbWF0Y2ggdGhlbSB0byBleHRyYWN0ZWQgc3RyaW5nLCB0aGF0IG1pZ2h0IGJlIEhUTUwgYXMgd2VsbC5cbiAgICovXG4gIGdldERpY3Rpb25hcnlXaXRoVHJpbW1lZEtleXMoZGljdGlvbmFyeTogb2JqZWN0KSB7XG4gICAgcmV0dXJuIG1hcEtleXMoZGljdGlvbmFyeSwgKHZhbHVlLCBrZXkpID0+XG4gICAgICB0cmltVHJhbnNsYXRpb25LZXkoa2V5KVxuICAgICk7XG4gIH1cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJpbVRyYW5zbGF0aW9uS2V5KGtleSkge1xuICByZXR1cm4ga2V5LnJlcGxhY2UoLyhcXHJcXG58XFxufFxccikvZ20sICcnKS5yZXBsYWNlKC9cXHN7Mix9L2csICcgJykudHJpbSgpO1xufVxuIl19