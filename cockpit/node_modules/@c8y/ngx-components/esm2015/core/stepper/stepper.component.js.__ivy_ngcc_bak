import { Component, Input, Output, ContentChildren, EventEmitter, ChangeDetectorRef, ElementRef } from '@angular/core';
import { CdkStepper, STEP_STATE } from '@angular/cdk/stepper';
import { C8yStepperIcon } from './stepper-icon.directive';
import { Subject } from 'rxjs';
import { Directionality } from '@angular/cdk/bidi';
/**
 * C8yStepper extends the CdkStepper. You can use cdk based functionality and inputs.
 * Additional to that you are able to modify the behavior and also the look and feel when
 * using the C8yStepper.
 *
 * The C8yStepper is used to present any step-based process to the user.
 * A stepper, C8yStepper and/or CdkStepper is the parent of cdk-steps.
 * Each cdk-step represents one step in the whole process that you want to provide to the user.
 *
 * The C8yStepper will create, based on the given cdk-steps, a kind of stepper-progress which looks like this:
 * (1)---(2)---(3)---(n)
 * The stepper will handle the state of each step and provides styles for active steps, done-steps or in edit-mode.
 * You are able to override icons for each step in the stepper-progress with a template. You are also able to activate
 * default-icons for states like 'edit' and 'done'.
 *
 * To force users through every provided step, set the stepper to 'linear'.
 * This will disable the possibility to move for example from step one to step three.
 *
 * Whenever it comes to validation try to use formGroups. It is possible to
 * assign a formGroup to a cdk-step input called [stepControl], which automatically respects the
 * validation-rules that you created for this formGroup. If fields are required but not filled or
 * any other validation, like a pattern, is not matched the formGroup will be invalid. In this case
 * stepping in a linear stepper to the next step gets impossible.
 *
 * If there is the need to execute asynchronous code you have at least two possibilities.
 * First: As you learned, a cdk-step works with formGroups and Validators, so you are able to use
 * asyncValidators as well.
 * Second: The C8yStepper provides an event-emitter onStepChange which is called whenever a step-button (1)--(2)--(n)
 * in the stepper-progress is clicked. The event of this emitter holds the index of the step as number. You can
 * use this EventEmitter to call for example a custom navigate-method which performs first any async-call and then moves
 * on to the given step.
 *
 * @example
 * ```
 * <c8y-stepper
 * (onStepChange)="navigate($event)"
 * [disableDefaultIcons]="{ edit: true, done: false }"
 * [customClasses]="['m-l-40', 'm-r-40', 'm-t-32']"
 * linear
 * >
 * <!-- override icons -->
 * <ng-template c8yStepperIcon="final">
 *   <span [c8yIcon]="'hand-peace-o'"></span>
 * </ng-template>
 *
 * <cdk-step [stepControl]="formGroupStepOne" label="Name of the hero">
 *   <div class="m-l-40 m-r-40 m-t-32">
 *     <h4 class="p-b-8" translate>What is the name of your hero?</h4>
 *     <c8y-form-group>
 *      <div [formGroup]="formGroupStepOne">
 *       <input
 *         class="form-control"
 *         type="text"
 *         formControlName="name"
 *         placeholder="Mister X"
 *         #nameRef
 *         required
 *       />
 *       <c8y-messages>
 *         <c8y-message *ngIf="!formGroupStepOne.untouched && !nameRef.value" translate
 *           >Enter the name of the Superhero</c8y-message
 *         >
 *       </c8y-messages>
 *      </div>
 *     </c8y-form-group>
 *   </div>
 *   <c8y-stepper-buttons></c8y-stepper-buttons>
 * </cdk-step>
 * <cdk-step>
 *  ...
 * </cdk-step state="final">
 * </c8y-stepper>
 * ```
 */
export class C8yStepper extends CdkStepper {
    constructor(dir, changeDetectorRef, elementRef) {
        super(dir, changeDetectorRef, elementRef, document);
        this.dir = dir;
        this.changeDetectorRef = changeDetectorRef;
        this.elementRef = elementRef;
        /**
         * Optional
         * Indicator if icons for edit and done state should be shown in step-header buttons
         */
        this.disableDefaultIcons = { edit: true, done: true };
        /**
         * Will emit the step index number whenever a step-header button was clicked
         * It listens to the stepIndex Subject.
         */
        this.onStepChange = new EventEmitter();
        /** Consumer-specified template-refs to be used to override the header icons. */
        this._iconOverrides = {};
        this._stepIndex = new Subject();
    }
    ngAfterContentInit() {
        super.ngAfterContentInit();
        this._icons.forEach(({ name, templateRef }) => (this._iconOverrides[name] = templateRef));
        this._stepIndexSubscription = this._stepIndex.subscribe(index => this.onStepChange.emit(index));
    }
    ngOnDestroy() {
        if (this._stepIndexSubscription && !this._stepIndexSubscription.closed) {
            this._stepIndexSubscription.unsubscribe();
        }
    }
    /**
     * Manipulates the state based on the disabledDefaultIcons Input()
     * Changing edit or done to false will change the icons within step-header buttons
     * @param index step index
     * @param state step state, like 'done', 'edit', 'error'
     */
    getIndicatorType(index, state) {
        const stepState = this._getIndicatorType(index, state);
        let _state = state;
        switch (stepState) {
            case STEP_STATE.EDIT:
                if (!this.disableDefaultIcons.edit) {
                    _state = STEP_STATE.EDIT;
                }
                break;
            case STEP_STATE.DONE:
                if (!this.disableDefaultIcons.done) {
                    _state = STEP_STATE.DONE;
                }
                else {
                    _state = '_done';
                }
                break;
        }
        return _state;
    }
    /**
     * Pushs the step index to the subject
     * @param index step index
     */
    setIndex(index) {
        this._stepIndex.next(index);
    }
}
C8yStepper.decorators = [
    { type: Component, args: [{
                selector: 'c8y-stepper',
                template: "<ul class=\"c8y-stepper\" [ngClass]=\"customClasses\">\n  <li *ngFor=\"let step of steps; let i = index\">\n    <c8y-stepper-progress\n      [iconOverrides]=\"_iconOverrides\"\n      [state]=\"getIndicatorType(i, step.state)\"\n      [index]=\"i\"\n      [selected]=\"selectedIndex === i\"\n      (onStepClicked)=\"setIndex($event)\"\n      title=\"{{ step.label | translate }}\"\n      [ngClass]=\"{'active': selectedIndex === i}\"\n    >\n    </c8y-stepper-progress>\n    <div class=\"c8y-step__label\"  title=\"{{ step.label | translate }}\">\n      {{ step.label | translate }}\n    </div>\n  </li>\n</ul>\n<ng-container [ngTemplateOutlet]=\"selected.content\"></ng-container>\n",
                providers: [{ provide: CdkStepper, useExisting: C8yStepper }]
            },] }
];
C8yStepper.ctorParameters = () => [
    { type: Directionality },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
C8yStepper.propDecorators = {
    disableDefaultIcons: [{ type: Input }],
    customClasses: [{ type: Input }],
    onStepChange: [{ type: Output }],
    _icons: [{ type: ContentChildren, args: [C8yStepperIcon, { descendants: true },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL3N0ZXBwZXIvc3RlcHBlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFFVCxLQUFLLEVBQ0wsTUFBTSxFQUNOLGVBQWUsRUFJZixZQUFZLEVBQ1osaUJBQWlCLEVBQ2pCLFVBQVUsRUFDWCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsVUFBVSxFQUFhLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsT0FBTyxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUM3QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFbkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F5RUc7QUFNSCxNQUFNLE9BQU8sVUFBVyxTQUFRLFVBQVU7SUFtRHhDLFlBQ1UsR0FBbUIsRUFDbkIsaUJBQW9DLEVBQ3BDLFVBQW9DO1FBRTlDLEtBQUssQ0FBQyxHQUFHLEVBQUUsaUJBQWlCLEVBQUUsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBSjFDLFFBQUcsR0FBSCxHQUFHLENBQWdCO1FBQ25CLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUFDcEMsZUFBVSxHQUFWLFVBQVUsQ0FBMEI7UUFyRDlDOzs7V0FHRztRQUNNLHdCQUFtQixHQUFzQyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDO1FBTTdGOzs7V0FHRztRQUNPLGlCQUFZLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQThCcEQsZ0ZBQWdGO1FBQ2hGLG1CQUFjLEdBQXdDLEVBQUUsQ0FBQztRQUVqRCxlQUFVLEdBQW9CLElBQUksT0FBTyxFQUFFLENBQUM7SUFTcEQsQ0FBQztJQUVELGtCQUFrQjtRQUNoQixLQUFLLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUMzQixJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQztRQUMxRixJQUFJLENBQUMsc0JBQXNCLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2xHLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUMsc0JBQXNCLElBQUksQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsTUFBTSxFQUFFO1lBQ3RFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUMzQztJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGdCQUFnQixDQUFDLEtBQWEsRUFBRSxLQUFnQjtRQUM5QyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3ZELElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNuQixRQUFRLFNBQVMsRUFBRTtZQUNqQixLQUFLLFVBQVUsQ0FBQyxJQUFJO2dCQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRTtvQkFDbEMsTUFBTSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUM7aUJBQzFCO2dCQUNELE1BQU07WUFFUixLQUFLLFVBQVUsQ0FBQyxJQUFJO2dCQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRTtvQkFDbEMsTUFBTSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUM7aUJBQzFCO3FCQUFNO29CQUNMLE1BQU0sR0FBRyxPQUFPLENBQUM7aUJBQ2xCO2dCQUNELE1BQU07U0FDVDtRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRLENBQUMsS0FBYTtRQUNwQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM5QixDQUFDOzs7WUE3R0YsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxhQUFhO2dCQUN2QixzckJBQXVDO2dCQUN2QyxTQUFTLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxDQUFDO2FBQzlEOzs7WUFoRlEsY0FBYztZQU5yQixpQkFBaUI7WUFDakIsVUFBVTs7O2tDQTJGVCxLQUFLOzRCQUtMLEtBQUs7MkJBS0wsTUFBTTtxQkE0Qk4sZUFBZSxTQUFDLGNBQWMsRUFBRSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIFRlbXBsYXRlUmVmLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIFF1ZXJ5TGlzdCxcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgT25EZXN0cm95LFxuICBFdmVudEVtaXR0ZXIsXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBFbGVtZW50UmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2RrU3RlcHBlciwgU3RlcFN0YXRlLCBTVEVQX1NUQVRFIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3N0ZXBwZXInO1xuaW1wb3J0IHsgQzh5U3RlcHBlckljb24gfSBmcm9tICcuL3N0ZXBwZXItaWNvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcblxuLyoqXG4gKiBDOHlTdGVwcGVyIGV4dGVuZHMgdGhlIENka1N0ZXBwZXIuIFlvdSBjYW4gdXNlIGNkayBiYXNlZCBmdW5jdGlvbmFsaXR5IGFuZCBpbnB1dHMuXG4gKiBBZGRpdGlvbmFsIHRvIHRoYXQgeW91IGFyZSBhYmxlIHRvIG1vZGlmeSB0aGUgYmVoYXZpb3IgYW5kIGFsc28gdGhlIGxvb2sgYW5kIGZlZWwgd2hlblxuICogdXNpbmcgdGhlIEM4eVN0ZXBwZXIuXG4gKlxuICogVGhlIEM4eVN0ZXBwZXIgaXMgdXNlZCB0byBwcmVzZW50IGFueSBzdGVwLWJhc2VkIHByb2Nlc3MgdG8gdGhlIHVzZXIuXG4gKiBBIHN0ZXBwZXIsIEM4eVN0ZXBwZXIgYW5kL29yIENka1N0ZXBwZXIgaXMgdGhlIHBhcmVudCBvZiBjZGstc3RlcHMuXG4gKiBFYWNoIGNkay1zdGVwIHJlcHJlc2VudHMgb25lIHN0ZXAgaW4gdGhlIHdob2xlIHByb2Nlc3MgdGhhdCB5b3Ugd2FudCB0byBwcm92aWRlIHRvIHRoZSB1c2VyLlxuICpcbiAqIFRoZSBDOHlTdGVwcGVyIHdpbGwgY3JlYXRlLCBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2RrLXN0ZXBzLCBhIGtpbmQgb2Ygc3RlcHBlci1wcm9ncmVzcyB3aGljaCBsb29rcyBsaWtlIHRoaXM6XG4gKiAoMSktLS0oMiktLS0oMyktLS0obilcbiAqIFRoZSBzdGVwcGVyIHdpbGwgaGFuZGxlIHRoZSBzdGF0ZSBvZiBlYWNoIHN0ZXAgYW5kIHByb3ZpZGVzIHN0eWxlcyBmb3IgYWN0aXZlIHN0ZXBzLCBkb25lLXN0ZXBzIG9yIGluIGVkaXQtbW9kZS5cbiAqIFlvdSBhcmUgYWJsZSB0byBvdmVycmlkZSBpY29ucyBmb3IgZWFjaCBzdGVwIGluIHRoZSBzdGVwcGVyLXByb2dyZXNzIHdpdGggYSB0ZW1wbGF0ZS4gWW91IGFyZSBhbHNvIGFibGUgdG8gYWN0aXZhdGVcbiAqIGRlZmF1bHQtaWNvbnMgZm9yIHN0YXRlcyBsaWtlICdlZGl0JyBhbmQgJ2RvbmUnLlxuICpcbiAqIFRvIGZvcmNlIHVzZXJzIHRocm91Z2ggZXZlcnkgcHJvdmlkZWQgc3RlcCwgc2V0IHRoZSBzdGVwcGVyIHRvICdsaW5lYXInLlxuICogVGhpcyB3aWxsIGRpc2FibGUgdGhlIHBvc3NpYmlsaXR5IHRvIG1vdmUgZm9yIGV4YW1wbGUgZnJvbSBzdGVwIG9uZSB0byBzdGVwIHRocmVlLlxuICpcbiAqIFdoZW5ldmVyIGl0IGNvbWVzIHRvIHZhbGlkYXRpb24gdHJ5IHRvIHVzZSBmb3JtR3JvdXBzLiBJdCBpcyBwb3NzaWJsZSB0b1xuICogYXNzaWduIGEgZm9ybUdyb3VwIHRvIGEgY2RrLXN0ZXAgaW5wdXQgY2FsbGVkIFtzdGVwQ29udHJvbF0sIHdoaWNoIGF1dG9tYXRpY2FsbHkgcmVzcGVjdHMgdGhlXG4gKiB2YWxpZGF0aW9uLXJ1bGVzIHRoYXQgeW91IGNyZWF0ZWQgZm9yIHRoaXMgZm9ybUdyb3VwLiBJZiBmaWVsZHMgYXJlIHJlcXVpcmVkIGJ1dCBub3QgZmlsbGVkIG9yXG4gKiBhbnkgb3RoZXIgdmFsaWRhdGlvbiwgbGlrZSBhIHBhdHRlcm4sIGlzIG5vdCBtYXRjaGVkIHRoZSBmb3JtR3JvdXAgd2lsbCBiZSBpbnZhbGlkLiBJbiB0aGlzIGNhc2VcbiAqIHN0ZXBwaW5nIGluIGEgbGluZWFyIHN0ZXBwZXIgdG8gdGhlIG5leHQgc3RlcCBnZXRzIGltcG9zc2libGUuXG4gKlxuICogSWYgdGhlcmUgaXMgdGhlIG5lZWQgdG8gZXhlY3V0ZSBhc3luY2hyb25vdXMgY29kZSB5b3UgaGF2ZSBhdCBsZWFzdCB0d28gcG9zc2liaWxpdGllcy5cbiAqIEZpcnN0OiBBcyB5b3UgbGVhcm5lZCwgYSBjZGstc3RlcCB3b3JrcyB3aXRoIGZvcm1Hcm91cHMgYW5kIFZhbGlkYXRvcnMsIHNvIHlvdSBhcmUgYWJsZSB0byB1c2VcbiAqIGFzeW5jVmFsaWRhdG9ycyBhcyB3ZWxsLlxuICogU2Vjb25kOiBUaGUgQzh5U3RlcHBlciBwcm92aWRlcyBhbiBldmVudC1lbWl0dGVyIG9uU3RlcENoYW5nZSB3aGljaCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBzdGVwLWJ1dHRvbiAoMSktLSgyKS0tKG4pXG4gKiBpbiB0aGUgc3RlcHBlci1wcm9ncmVzcyBpcyBjbGlja2VkLiBUaGUgZXZlbnQgb2YgdGhpcyBlbWl0dGVyIGhvbGRzIHRoZSBpbmRleCBvZiB0aGUgc3RlcCBhcyBudW1iZXIuIFlvdSBjYW5cbiAqIHVzZSB0aGlzIEV2ZW50RW1pdHRlciB0byBjYWxsIGZvciBleGFtcGxlIGEgY3VzdG9tIG5hdmlnYXRlLW1ldGhvZCB3aGljaCBwZXJmb3JtcyBmaXJzdCBhbnkgYXN5bmMtY2FsbCBhbmQgdGhlbiBtb3Zlc1xuICogb24gdG8gdGhlIGdpdmVuIHN0ZXAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogPGM4eS1zdGVwcGVyXG4gKiAob25TdGVwQ2hhbmdlKT1cIm5hdmlnYXRlKCRldmVudClcIlxuICogW2Rpc2FibGVEZWZhdWx0SWNvbnNdPVwieyBlZGl0OiB0cnVlLCBkb25lOiBmYWxzZSB9XCJcbiAqIFtjdXN0b21DbGFzc2VzXT1cIlsnbS1sLTQwJywgJ20tci00MCcsICdtLXQtMzInXVwiXG4gKiBsaW5lYXJcbiAqID5cbiAqIDwhLS0gb3ZlcnJpZGUgaWNvbnMgLS0+XG4gKiA8bmctdGVtcGxhdGUgYzh5U3RlcHBlckljb249XCJmaW5hbFwiPlxuICogICA8c3BhbiBbYzh5SWNvbl09XCInaGFuZC1wZWFjZS1vJ1wiPjwvc3Bhbj5cbiAqIDwvbmctdGVtcGxhdGU+XG4gKlxuICogPGNkay1zdGVwIFtzdGVwQ29udHJvbF09XCJmb3JtR3JvdXBTdGVwT25lXCIgbGFiZWw9XCJOYW1lIG9mIHRoZSBoZXJvXCI+XG4gKiAgIDxkaXYgY2xhc3M9XCJtLWwtNDAgbS1yLTQwIG0tdC0zMlwiPlxuICogICAgIDxoNCBjbGFzcz1cInAtYi04XCIgdHJhbnNsYXRlPldoYXQgaXMgdGhlIG5hbWUgb2YgeW91ciBoZXJvPzwvaDQ+XG4gKiAgICAgPGM4eS1mb3JtLWdyb3VwPlxuICogICAgICA8ZGl2IFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwU3RlcE9uZVwiPlxuICogICAgICAgPGlucHV0XG4gKiAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAqICAgICAgICAgdHlwZT1cInRleHRcIlxuICogICAgICAgICBmb3JtQ29udHJvbE5hbWU9XCJuYW1lXCJcbiAqICAgICAgICAgcGxhY2Vob2xkZXI9XCJNaXN0ZXIgWFwiXG4gKiAgICAgICAgICNuYW1lUmVmXG4gKiAgICAgICAgIHJlcXVpcmVkXG4gKiAgICAgICAvPlxuICogICAgICAgPGM4eS1tZXNzYWdlcz5cbiAqICAgICAgICAgPGM4eS1tZXNzYWdlICpuZ0lmPVwiIWZvcm1Hcm91cFN0ZXBPbmUudW50b3VjaGVkICYmICFuYW1lUmVmLnZhbHVlXCIgdHJhbnNsYXRlXG4gKiAgICAgICAgICAgPkVudGVyIHRoZSBuYW1lIG9mIHRoZSBTdXBlcmhlcm88L2M4eS1tZXNzYWdlXG4gKiAgICAgICAgID5cbiAqICAgICAgIDwvYzh5LW1lc3NhZ2VzPlxuICogICAgICA8L2Rpdj5cbiAqICAgICA8L2M4eS1mb3JtLWdyb3VwPlxuICogICA8L2Rpdj5cbiAqICAgPGM4eS1zdGVwcGVyLWJ1dHRvbnM+PC9jOHktc3RlcHBlci1idXR0b25zPlxuICogPC9jZGstc3RlcD5cbiAqIDxjZGstc3RlcD5cbiAqICAuLi5cbiAqIDwvY2RrLXN0ZXAgc3RhdGU9XCJmaW5hbFwiPlxuICogPC9jOHktc3RlcHBlcj5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjOHktc3RlcHBlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9zdGVwcGVyLmNvbXBvbmVudC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtTdGVwcGVyLCB1c2VFeGlzdGluZzogQzh5U3RlcHBlciB9XVxufSlcbmV4cG9ydCBjbGFzcyBDOHlTdGVwcGVyIGV4dGVuZHMgQ2RrU3RlcHBlciBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIC8qKlxuICAgKiBPcHRpb25hbFxuICAgKiBJbmRpY2F0b3IgaWYgaWNvbnMgZm9yIGVkaXQgYW5kIGRvbmUgc3RhdGUgc2hvdWxkIGJlIHNob3duIGluIHN0ZXAtaGVhZGVyIGJ1dHRvbnNcbiAgICovXG4gIEBJbnB1dCgpIGRpc2FibGVEZWZhdWx0SWNvbnM/OiB7IGVkaXQ6IGJvb2xlYW47IGRvbmU6IGJvb2xlYW4gfSA9IHsgZWRpdDogdHJ1ZSwgZG9uZTogdHJ1ZSB9O1xuICAvKipcbiAgICogT3B0aW9uYWxcbiAgICogUG9zc2liaWxpdHkgdG8gYWRkIGFueSBraW5kIG9mIGN1c3RvbSBjc3MgY2xhc3NlcyB0byB0aGUgc3RlcC1oZWFkZXJcbiAgICovXG4gIEBJbnB1dCgpIGN1c3RvbUNsYXNzZXM/OiBbc3RyaW5nXTtcbiAgLyoqXG4gICAqIFdpbGwgZW1pdCB0aGUgc3RlcCBpbmRleCBudW1iZXIgd2hlbmV2ZXIgYSBzdGVwLWhlYWRlciBidXR0b24gd2FzIGNsaWNrZWRcbiAgICogSXQgbGlzdGVucyB0byB0aGUgc3RlcEluZGV4IFN1YmplY3QuXG4gICAqL1xuICBAT3V0cHV0KCkgb25TdGVwQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgLyoqXG4gICAqIEhvbGRpbmcgYSBRdWVyeUxpc3Qgb2YgQzh5U3RlcHBlckljb25zXG4gICAqIFRoZXNlIGFyZSB0ZW1wbGF0ZVJlZnMgd2hpY2ggb3ZlcnJpZGVzIGFueSBzdGVwLWhlYWRlciBidXR0b24gaWNvbiB3aXRoIG1hdGNoaW5nIHN0YXRlIG9mIGNkay1zdGVwXG4gICAqXG4gICAqIEBleGFtcGxlOlxuICAgKiBgYGBcbiAgICogPCEtLSBvdmVycmlkZSBpY29ucyAtLT5cbiAgICogIDxuZy10ZW1wbGF0ZSBjOHlTdGVwcGVySWNvbj1cImZpbmFsXCI+XG4gICAqICAgPHNwYW4gW2M4eUljb25dPVwiJ2hhbmQtcGVhY2UtbydcIj48L3NwYW4+XG4gICAqICA8L25nLXRlbXBsYXRlPlxuICAgKlxuICAgKiA8Y2RrLXN0ZXAgc3RhdGU9XCJmaW5hbFwiIGxhYmVsPVwiSm9iIGRvbmUhXCI+XG4gICAqICA8ZGl2IGNsYXNzPVwibS1sLTQwIG0tci00MCBtLXQtMzJcIj5cbiAgICogICAgPGg0IGNsYXNzPVwicC1iLTMyXCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXI7XCIgdHJhbnNsYXRlPlxuICAgKiAgICAgWW91ciBTdXBlcmhlcm8gaXMgbm93IHJlYWR5IHRvIHNhdmUgdGhlIHdvcmxkIVxuICAgKiAgIDwvaDQ+XG4gICAqICA8L2Rpdj5cbiAgICogIDxjOHktc3RlcHBlci1idXR0b25zXG4gICAqICAgIFtoaWRkZW5dPVwiIWlzTW9kYWxcIlxuICAgKiAgICAob25CYWNrKT1cImNsb3NlKClcIlxuICAgKiAgICBbbGFiZWxzXT1cInsgYmFjazogJ0dvdCBpdCEnIH1cIlxuICAgKiAgPjwvYzh5LXN0ZXBwZXItYnV0dG9ucz5cbiAgICogIDxjOHktc3RlcHBlci1idXR0b25zIFtoaWRkZW5dPVwiaXNNb2RhbFwiPjwvYzh5LXN0ZXBwZXItYnV0dG9ucz5cbiAgICogPC9jZGstc3RlcD5cbiAgICogYGBgXG4gICAqL1xuICBAQ29udGVudENoaWxkcmVuKEM4eVN0ZXBwZXJJY29uLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pIF9pY29uczogUXVlcnlMaXN0PEM4eVN0ZXBwZXJJY29uPjtcblxuICAvKiogQ29uc3VtZXItc3BlY2lmaWVkIHRlbXBsYXRlLXJlZnMgdG8gYmUgdXNlZCB0byBvdmVycmlkZSB0aGUgaGVhZGVyIGljb25zLiAqL1xuICBfaWNvbk92ZXJyaWRlczogeyBba2V5OiBzdHJpbmddOiBUZW1wbGF0ZVJlZjxhbnk+IH0gPSB7fTtcblxuICBwcml2YXRlIF9zdGVwSW5kZXg6IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0KCk7XG4gIHByaXZhdGUgX3N0ZXBJbmRleFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZGlyOiBEaXJlY3Rpb25hbGl0eSxcbiAgICBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY/OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgKSB7XG4gIHN1cGVyKGRpciwgY2hhbmdlRGV0ZWN0b3JSZWYsIGVsZW1lbnRSZWYsIGRvY3VtZW50KTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBzdXBlci5uZ0FmdGVyQ29udGVudEluaXQoKTtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKCh7IG5hbWUsIHRlbXBsYXRlUmVmIH0pID0+ICh0aGlzLl9pY29uT3ZlcnJpZGVzW25hbWVdID0gdGVtcGxhdGVSZWYpKTtcbiAgICB0aGlzLl9zdGVwSW5kZXhTdWJzY3JpcHRpb24gPSB0aGlzLl9zdGVwSW5kZXguc3Vic2NyaWJlKGluZGV4ID0+IHRoaXMub25TdGVwQ2hhbmdlLmVtaXQoaW5kZXgpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9zdGVwSW5kZXhTdWJzY3JpcHRpb24gJiYgIXRoaXMuX3N0ZXBJbmRleFN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgIHRoaXMuX3N0ZXBJbmRleFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYW5pcHVsYXRlcyB0aGUgc3RhdGUgYmFzZWQgb24gdGhlIGRpc2FibGVkRGVmYXVsdEljb25zIElucHV0KClcbiAgICogQ2hhbmdpbmcgZWRpdCBvciBkb25lIHRvIGZhbHNlIHdpbGwgY2hhbmdlIHRoZSBpY29ucyB3aXRoaW4gc3RlcC1oZWFkZXIgYnV0dG9uc1xuICAgKiBAcGFyYW0gaW5kZXggc3RlcCBpbmRleFxuICAgKiBAcGFyYW0gc3RhdGUgc3RlcCBzdGF0ZSwgbGlrZSAnZG9uZScsICdlZGl0JywgJ2Vycm9yJ1xuICAgKi9cbiAgZ2V0SW5kaWNhdG9yVHlwZShpbmRleDogbnVtYmVyLCBzdGF0ZTogU3RlcFN0YXRlKSB7XG4gICAgY29uc3Qgc3RlcFN0YXRlID0gdGhpcy5fZ2V0SW5kaWNhdG9yVHlwZShpbmRleCwgc3RhdGUpO1xuICAgIGxldCBfc3RhdGUgPSBzdGF0ZTtcbiAgICBzd2l0Y2ggKHN0ZXBTdGF0ZSkge1xuICAgICAgY2FzZSBTVEVQX1NUQVRFLkVESVQ6XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlRGVmYXVsdEljb25zLmVkaXQpIHtcbiAgICAgICAgICBfc3RhdGUgPSBTVEVQX1NUQVRFLkVESVQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU1RFUF9TVEFURS5ET05FOlxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZURlZmF1bHRJY29ucy5kb25lKSB7XG4gICAgICAgICAgX3N0YXRlID0gU1RFUF9TVEFURS5ET05FO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9zdGF0ZSA9ICdfZG9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBfc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogUHVzaHMgdGhlIHN0ZXAgaW5kZXggdG8gdGhlIHN1YmplY3RcbiAgICogQHBhcmFtIGluZGV4IHN0ZXAgaW5kZXhcbiAgICovXG4gIHNldEluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLl9zdGVwSW5kZXgubmV4dChpbmRleCk7XG4gIH1cbn1cbiJdfQ==