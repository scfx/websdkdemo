(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/router'), require('@c8y/ngx-components'), require('@c8y/ngx-components/operations/single-operation-details'), require('ngx-bootstrap/dropdown'), require('ngx-bootstrap/popover'), require('ngx-bootstrap/tabs'), require('ngx-bootstrap/tooltip'), require('@c8y/client'), require('rxjs/operators'), require('file-saver'), require('ngx-bootstrap/modal'), require('lodash-es'), require('rxjs'), require('@ngx-translate/core'), require('@c8y/ngx-components/device-grid')) :
    typeof define === 'function' && define.amd ? define('@c8y/ngx-components/repository', ['exports', '@angular/core', '@angular/router', '@c8y/ngx-components', '@c8y/ngx-components/operations/single-operation-details', 'ngx-bootstrap/dropdown', 'ngx-bootstrap/popover', 'ngx-bootstrap/tabs', 'ngx-bootstrap/tooltip', '@c8y/client', 'rxjs/operators', 'file-saver', 'ngx-bootstrap/modal', 'lodash-es', 'rxjs', '@ngx-translate/core', '@c8y/ngx-components/device-grid'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.c8y = global.c8y || {}, global.c8y["ngx-components"] = global.c8y["ngx-components"] || {}, global.c8y["ngx-components"].repository = {}), global.ng.core, global.ng.router, global.c8y["ngx-components"], global.c8y["ngx-components"].operations["single-operation-details"], global.dropdown, global.popover, global.tabs, global.tooltip, global.client, global.rxjs.operators, global.fileSaver, global.modal, global.lodashEs, global.rxjs, global.core$1, global.c8y["ngx-components"]["device-grid"]));
})(this, (function (exports, core, router, ngxComponents, singleOperationDetails, dropdown, popover, tabs, tooltip, client, operators, fileSaver, modal, lodashEs, rxjs, core$1, deviceGrid) { 'use strict';

    var ConfigurationFilterPipe = /** @class */ (function () {
        function ConfigurationFilterPipe() {
        }
        ConfigurationFilterPipe.prototype.transform = function (items, filterTerm) {
            var _this = this;
            return filterTerm.trim().length === 0
                ? items
                : items.filter(function (item) { return _this.filterContainString(item.name, filterTerm) ||
                    _this.filterContainString(item.deviceType, filterTerm); });
        };
        ConfigurationFilterPipe.prototype.filterContainString = function (name, filterTerm) {
            var term = filterTerm.toLowerCase().trim();
            return name && name.toLowerCase().indexOf(term) > -1;
        };
        return ConfigurationFilterPipe;
    }());
    ConfigurationFilterPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'configurationFilterPipe'
                },] }
    ];

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var _a;
    exports.RepositoryType = void 0;
    (function (RepositoryType) {
        RepositoryType["FIRMWARE"] = "c8y_Firmware";
        RepositoryType["SOFTWARE"] = "c8y_Software";
        RepositoryType["CONFIGURATION"] = "c8y_ConfigurationDump";
    })(exports.RepositoryType || (exports.RepositoryType = {}));
    var REPOSITORY_BINARY_TYPES = (_a = {},
        _a[exports.RepositoryType.SOFTWARE] = 'c8y_SoftwareBinary',
        _a[exports.RepositoryType.FIRMWARE] = 'c8y_FirmwareBinary',
        _a[exports.RepositoryType.CONFIGURATION] = 'c8y_ConfigurationDumpBinary',
        _a);
    exports.DeviceConfigurationOperation = void 0;
    (function (DeviceConfigurationOperation) {
        DeviceConfigurationOperation["UPLOAD_CONFIG"] = "c8y_UploadConfigFile";
        DeviceConfigurationOperation["DOWNLOAD_CONFIG"] = "c8y_DownloadConfigFile";
        DeviceConfigurationOperation["CONFIG"] = "c8y_Configuration";
        DeviceConfigurationOperation["SEND_CONFIG"] = "c8y_SendConfiguration";
    })(exports.DeviceConfigurationOperation || (exports.DeviceConfigurationOperation = {}));

    var DeviceConfigurationService = /** @class */ (function () {
        function DeviceConfigurationService() {
            this.configurationsUpdated = new core.EventEmitter();
        }
        DeviceConfigurationService.prototype.updateConfigurations = function (repositorySnapsOnly) {
            this.configurationsUpdated.emit(repositorySnapsOnly);
        };
        DeviceConfigurationService.prototype.hasAnySupportedOperation = function (mo, operation) {
            var supported = mo.c8y_SupportedOperations;
            if (!supported) {
                return false;
            }
            if (!Array.isArray(operation)) {
                operation = [operation];
            }
            return supported.some(function (supportedOperation) { return operation.includes(supportedOperation); });
        };
        return DeviceConfigurationService;
    }());
    DeviceConfigurationService.decorators = [
        { type: core.Injectable }
    ];

    var RepositoryService = /** @class */ (function () {
        function RepositoryService(inventory, inventoryBinary, operation, alert, event, operationRealtime, eventBinary) {
            this.inventory = inventory;
            this.inventoryBinary = inventoryBinary;
            this.operation = operation;
            this.alert = alert;
            this.event = event;
            this.operationRealtime = operationRealtime;
            this.eventBinary = eventBinary;
            this.dateFrom = new Date(0);
            this.dateTo = new Date(Date.now() + 86400000); // 1 day in the future
            this.queriesUtil = new client.QueriesUtil();
        }
        /**
         * Lists repository entries of given type.
         * @param type The type of repository entries to list.
         * @param options Extra listing options.
         */
        RepositoryService.prototype.listRepositoryEntries = function (type, options) {
            var defaultOrder = [{ name: 1 }];
            var defaultFilters = { type: type };
            var legacyFilters = { __has: "url" };
            var filters = {};
            var fullQuery = (options && options.query) || {};
            if (!options || (options && !options.skipDefaultOrder)) {
                fullQuery = this.queriesUtil.addOrderbys(fullQuery, defaultOrder, 'prepend');
            }
            fullQuery = this.queriesUtil.addAndFilter(fullQuery, defaultFilters);
            if (options && options.partialTextFilter) {
                var _b = options.partialTextFilter, partialText_1 = _b.partialText, properties = _b.properties;
                var orFilter = { __or: properties.map(function (property) {
                        var _b;
                        return (_b = {}, _b[property] = "*" + partialText_1 + "*", _b);
                    }) };
                fullQuery = this.queriesUtil.addAndFilter(fullQuery, orFilter);
            }
            if (options && options.partialName) {
                // backwards compatibility if
                fullQuery = this.queriesUtil.addAndFilter(fullQuery, { name: "*" + options.partialName + "*" });
            }
            if (options && options.skipLegacy) {
                fullQuery = this.queriesUtil.addAndFilter(fullQuery, { __not: legacyFilters });
            }
            filters = Object.assign({ query: this.queriesUtil.buildQuery(fullQuery), pageSize: 50, withTotalPages: true }, ((options && options.params) || {}));
            return this.inventory.list(filters);
        };
        // TODO: merge with create()
        RepositoryService.prototype.save = function (data, type, mo) {
            if (mo === void 0) { mo = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var existingUrl, response;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            switch (type) {
                                case exports.RepositoryType.CONFIGURATION: {
                                    Object.assign(mo, {
                                        type: exports.RepositoryType.CONFIGURATION,
                                        configurationType: data.selected ? data.selected.configurationType : undefined,
                                        name: data.version,
                                        description: data.description,
                                        deviceType: data.deviceType,
                                        c8y_Global: {}
                                    });
                                    if (!data.deviceType && mo.id) {
                                        mo.deviceType = null;
                                    }
                                    if (!data.selected && mo.id) {
                                        mo.configurationType = null;
                                    }
                                    break;
                                }
                            }
                            existingUrl = mo.url;
                            if (!data.binary.url) return [3 /*break*/, 1];
                            mo.url = data.binary.url;
                            return [3 /*break*/, 3];
                        case 1:
                            if (!data.binary.file) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.inventoryBinary.create(data.binary.file, {
                                    c8y_Global: {}
                                })];
                        case 2:
                            response = _b.sent();
                            mo.url = response.data.self;
                            _b.label = 3;
                        case 3:
                            if (mo.id) {
                                return [2 /*return*/, this.updateEntry(mo, existingUrl)];
                            }
                            return [2 /*return*/, this.createEntry(mo)];
                    }
                });
            });
        };
        RepositoryService.prototype.create = function (modal, type) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_b) {
                    switch (type) {
                        case exports.RepositoryType.FIRMWARE:
                        case exports.RepositoryType.SOFTWARE:
                            return [2 /*return*/, this.createFirmwareOrSoftware(modal, type)];
                    }
                    return [2 /*return*/];
                });
            });
        };
        RepositoryService.prototype.createFirmwareOrSoftware = function (modal, type) {
            return __awaiter(this, void 0, void 0, function () {
                var binary, binaryURL, repositoryEntry, repositoryBinary, mos, selectedId, _b, file, url, error_1;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            mos = [];
                            selectedId = modal.selected.id, _b = modal.binary, file = _b.file, url = _b.url;
                            _c.label = 1;
                        case 1:
                            _c.trys.push([1, 9, , 10]);
                            if (!file) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.saveBinary(file)];
                        case 2:
                            (binary = (_c.sent()).data);
                            (binaryURL = binary.self);
                            mos.push(binary);
                            return [3 /*break*/, 4];
                        case 3:
                            binaryURL = url;
                            _c.label = 4;
                        case 4: return [4 /*yield*/, this.createOrUpdateRepositoryEntry(modal, type)];
                        case 5:
                            (repositoryEntry = (_c.sent()).data);
                            if (lodashEs.isNil(selectedId)) {
                                mos.push(repositoryEntry);
                            }
                            return [4 /*yield*/, this.createRepositoryBinary(modal, binaryURL, type, repositoryEntry)];
                        case 6:
                            (repositoryBinary = (_c.sent()).data);
                            mos.push(repositoryBinary);
                            if (!file) return [3 /*break*/, 8];
                            return [4 /*yield*/, this.linkBinary(repositoryBinary, binary)];
                        case 7:
                            _c.sent();
                            _c.label = 8;
                        case 8: return [2 /*return*/, repositoryEntry];
                        case 9:
                            error_1 = _c.sent();
                            this.cleanUp(mos);
                            this.errorMsg();
                            // Propagate error
                            throw error_1;
                        case 10: return [2 /*return*/];
                    }
                });
            });
        };
        RepositoryService.prototype.saveBinary = function (file) {
            return this.inventoryBinary.create(file, { c8y_Global: {} });
        };
        RepositoryService.prototype.createOrUpdateRepositoryEntry = function (modal, type) {
            var _b = modal.selected, id = _b.id, name = _b.name, description = modal.description, deviceType = modal.deviceType;
            var mo = {
                id: id,
                name: id ? undefined : name,
                description: description,
                type: id ? undefined : type,
                c8y_Global: {}
            };
            if (deviceType) {
                lodashEs.set(mo, 'c8y_Filter.type', deviceType);
            }
            if (modal.softwareType) {
                lodashEs.set(mo, 'softwareType', modal.softwareType.softwareType);
            }
            return id
                ? this.inventory.update(mo)
                : this.inventory.create(mo);
        };
        RepositoryService.prototype.createRepositoryBinary = function (modal, binaryURL, type, parent) {
            var mo = this.prepareRepositoryBinaryMO(modal, binaryURL, type);
            return this.inventory.childAdditionsCreate(mo, parent);
        };
        RepositoryService.prototype.prepareRepositoryBinaryMO = function (modal, binaryURL, type) {
            var _b;
            var version = modal.version, patchVersion = modal.patchVersion, dependency = modal.dependency;
            var result = (_b = {
                    type: REPOSITORY_BINARY_TYPES[type]
                },
                _b[type] = {
                    url: binaryURL
                },
                _b.c8y_Global = {},
                _b);
            if (dependency) {
                lodashEs.set(result, [type, 'version'], patchVersion);
                lodashEs.assign(result, {
                    c8y_Patch: {
                        dependency: dependency.c8y_Firmware.version
                    }
                });
            }
            else {
                lodashEs.set(result, [type, 'version'], version);
            }
            return result;
        };
        RepositoryService.prototype.linkBinary = function (repositoryBinary, binary) {
            return __awaiter(this, void 0, void 0, function () {
                var repositoryBinaryId, binaryId;
                return __generator(this, function (_b) {
                    repositoryBinaryId = repositoryBinary.id;
                    if (binary) {
                        binaryId = binary.id;
                        return [2 /*return*/, this.inventory.childAdditionsAdd(binaryId, repositoryBinaryId)];
                    }
                    return [2 /*return*/];
                });
            });
        };
        RepositoryService.prototype.cleanUp = function (mosToDelete) {
            var _this = this;
            mosToDelete.forEach(function (mo) {
                var c8y_IsBinary = mo.c8y_IsBinary;
                lodashEs.isUndefined(c8y_IsBinary) ? _this.delete(mo) : _this.inventoryBinary.delete(mo);
            });
        };
        RepositoryService.prototype.delete = function (entity) {
            return this.inventory.delete(entity, { forceCascade: true });
        };
        RepositoryService.prototype.errorMsg = function () {
            var msg = ngxComponents.gettext('Failed to save');
            this.alert.danger(msg);
        };
        RepositoryService.prototype.getBaseVersionsCount$ = function (entry) {
            if (this.isLegacyEntry(entry)) {
                return rxjs.of(1);
            }
            return rxjs.from(this.listBaseVersions(entry, { pageSize: 1, withTotalPages: true })).pipe(operators.map(function (_b) {
                var paging = _b.paging;
                return paging.totalPages;
            }));
        };
        RepositoryService.prototype.getBaseVersionFromMO = function (mo) {
            return this.isPatch(mo) ? lodashEs.get(mo, 'c8y_Patch.dependency') : lodashEs.get(mo, 'c8y_Firmware.version');
        };
        RepositoryService.prototype.isPatch = function (mo) {
            return !!lodashEs.get(mo, 'c8y_Patch.dependency');
        };
        RepositoryService.prototype.getPatchVersionsCount$ = function (entry, baseVersion) {
            if (this.isLegacyEntry(baseVersion)) {
                return rxjs.of(0);
            }
            return rxjs.from(this.listPatchVersions(entry, baseVersion, { pageSize: 1, withTotalPages: true })).pipe(operators.map(function (_b) {
                var paging = _b.paging;
                return paging.totalPages;
            }));
        };
        RepositoryService.prototype.isLegacyEntry = function (entry) {
            return Boolean(entry.url);
        };
        /**
         * Lists all versions (base and patch ones) of given top level entry.
         * Versions are ordered by creation time (assuming the earlier created, the older the version).
         * @param entry Top level repository entry.
         * @param params Additional query params.
         */
        RepositoryService.prototype.listAllVersions = function (entry, params) {
            if (params === void 0) { params = {}; }
            if (this.isLegacyEntry(entry)) {
                return this.getBaseVersionResultListForLegacyEntry(entry);
            }
            var VERSION_FILTER_ORDER = {
                __filter: {},
                __orderby: [{ 'creationTime.date': -1 }, { creationTime: -1 }]
            };
            return this.listChildren(entry, VERSION_FILTER_ORDER, params);
        };
        /**
         * Lists base versions of given top level entry.
         * Versions are ordered by creation time (assuming the earlier created, the older the version).
         * @param entry Top level repository entry.
         * @param params Additional query params.
         */
        RepositoryService.prototype.listBaseVersions = function (entry, params) {
            if (params === void 0) { params = {}; }
            if (this.isLegacyEntry(entry)) {
                return this.getBaseVersionResultListForLegacyEntry(entry);
            }
            var NO_PATCH_FILTER_ORDER = {
                __filter: {
                    __not: { __has: 'c8y_Patch' }
                },
                __orderby: [{ 'creationTime.date': -1 }, { creationTime: -1 }]
            };
            return this.listChildren(entry, NO_PATCH_FILTER_ORDER, params);
        };
        /**
         * Lists patch versions of given base version under the entry.
         * Versions are ordered by creation time (assuming the earlier created, the older the version).
         * @param entry Top level repository entry.
         * @param baseVersion Base version.
         * @param params Additional query params.
         */
        RepositoryService.prototype.listPatchVersions = function (entry, baseVersion, params) {
            if (params === void 0) { params = {}; }
            var version = lodashEs.isString(baseVersion) ? baseVersion : lodashEs.get(baseVersion, 'c8y_Firmware.version');
            var PATCH_FILTER_ORDER = {
                __filter: {
                    'c8y_Patch.dependency': version
                },
                __orderby: [{ 'creationTime.date': -1 }, { creationTime: -1 }]
            };
            return this.listChildren(entry, PATCH_FILTER_ORDER, params);
        };
        /**
         * Lists patch versions of given base version under the entry including the base version.
         * Versions are ordered by creation time (assuming the earlier created, the older the version).
         * In terms of legacy base version the entry gets transformed to fit the needed data model.
         * @param entry Top level repository entry.
         * @param baseVersion Base version.
         * @param params Additional query params.
         */
        RepositoryService.prototype.listBaseVersionAndPatches = function (entry, baseVersion, params) {
            if (params === void 0) { params = {}; }
            if (this.isLegacyEntry(entry)) {
                return Promise.resolve({
                    data: [
                        Object.assign({
                            c8y_Firmware: {
                                version: entry.version,
                                url: entry.url
                            }
                        }, entry)
                    ]
                });
            }
            var PATCH_FILTER_ORDER = {
                __filter: {
                    __or: {
                        'c8y_Patch.dependency': baseVersion.c8y_Firmware.version,
                        'c8y_Firmware.version': baseVersion.c8y_Firmware.version
                    }
                },
                __orderby: [{ 'c8y_Patch.dependency': 1 }, { 'c8y_Firmware.version': 1 }]
            };
            return this.listChildren(entry, PATCH_FILTER_ORDER, params);
        };
        RepositoryService.prototype.listChildren = function (entry, filters, params) {
            if (filters === void 0) { filters = {}; }
            if (params === void 0) { params = {}; }
            var childrenFilters = { __bygroupid: entry.id };
            var query = this.queriesUtil.addAndFilter(filters, childrenFilters);
            // FIXME: needed because of issue in forOf directive (...)
            params.withTotalPages = true;
            return this.inventory.listQuery(query, params);
        };
        /**
         * Fetches all items from the list starting with the provided page.
         * @param firstPage The first page of the list to fetch all items for.
         */
        RepositoryService.prototype.fetchAllItemsFromList = function (firstPage) {
            return __awaiter(this, void 0, void 0, function () {
                var allItems, _b, paging, items;
                var _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            if (!!firstPage.then) return [3 /*break*/, 1];
                            allItems = __spreadArray([], __read(firstPage));
                            return [3 /*break*/, 5];
                        case 1: return [4 /*yield*/, firstPage];
                        case 2:
                            _b = _d.sent(), paging = _b.paging, items = _b.data;
                            allItems = __spreadArray([], __read(items));
                            _d.label = 3;
                        case 3:
                            if (!(paging && paging.nextPage)) return [3 /*break*/, 5];
                            return [4 /*yield*/, paging.next()];
                        case 4:
                            (_c = _d.sent(), paging = _c.paging, items = _c.data);
                            allItems = __spreadArray(__spreadArray([], __read(allItems)), __read(items));
                            return [3 /*break*/, 3];
                        case 5: return [2 /*return*/, allItems];
                    }
                });
            });
        };
        /**
         * Gets top level repository entry managed object for base or patch version.
         * @param mo Base or patch version managed object with parents.
         */
        RepositoryService.prototype.getRepositoryEntryMO$ = function (mo) {
            if (!mo) {
                return rxjs.of(undefined);
            }
            var _b = __read(lodashEs.get(mo, 'additionParents.references'), 1), reference = _b[0];
            var id = lodashEs.get(reference, 'managedObject.id');
            return id
                ? rxjs.from(this.inventory.detail(id, { withChildren: false })).pipe(operators.map(function (_b) {
                    var data = _b.data;
                    return data;
                }))
                : rxjs.of(undefined);
        };
        /**
         * Gets base or patch version managed object.
         * @param deviceRepositoryFragment Device repository fragment.
         * @param type Top level repository entry type.
         * @param configuration Configuration object with options:
         * - **skipLegacy** - `boolean` - Exclude legacy entries.
         * - **filters** - `object` - Filter object.
         *
         * @deprecated as it doesn't support 'missing url' case
         */
        RepositoryService.prototype.getRepositoryBinaryMoByVersion = function (deviceRepositoryFragment, type, _b) {
            var _c;
            var _d = _b === void 0 ? {} : _b, _e = _d.skipLegacy, skipLegacy = _e === void 0 ? false : _e, _f = _d.filters, filters = _f === void 0 ? {} : _f;
            var version = deviceRepositoryFragment.version, url = deviceRepositoryFragment.url, name = deviceRepositoryFragment.name;
            var repositoryBinaryType = REPOSITORY_BINARY_TYPES[type];
            var query;
            var newModelBaseVersionQuery = (_c = {},
                _c[type + ".version"] = version,
                _c[type + ".url"] = url,
                _c.type = repositoryBinaryType,
                _c);
            var legacyVersionQuery = { url: url, type: type, name: name };
            filters = Object.assign({ withChildren: false, withParents: true }, filters);
            if (skipLegacy) {
                query = {
                    __and: Object.assign({}, newModelBaseVersionQuery)
                };
            }
            else {
                query = {
                    __or: [{ __and: Object.assign({}, newModelBaseVersionQuery) }, { __and: Object.assign({}, legacyVersionQuery) }]
                };
            }
            return this.inventory.listQuery(query, filters).then(function (_b) {
                var data = _b.data;
                return lodashEs.head(data);
            });
        };
        RepositoryService.prototype.getBinaryName$ = function (binaryUrl) {
            var _this = this;
            if (!binaryUrl) {
                return rxjs.of('---');
            }
            var binaryId = this.inventoryBinary.getIdFromUrl(binaryUrl);
            if (!binaryId) {
                return rxjs.of(binaryUrl);
            }
            return rxjs.defer(function () { return _this.inventory.detail(binaryId).then(function (result) { return result.data; }); }).pipe(operators.map(function (mo) { return mo.name; }));
        };
        /**
         * Generates an inventory query object which can be used to find
         * repository entries of specified type matching the type of provided device.
         * @param repositoryType The type of repository entries which will be queried with the generated query.
         * @param device The device for which matching repository entries will be queried with the generated query.
         */
        RepositoryService.prototype.getDeviceTypeQuery = function (repositoryType, device) {
            var result = { type: repositoryType };
            if (repositoryType === exports.RepositoryType.CONFIGURATION) {
                if (device.type) {
                    result = this.queriesUtil.addAndFilter(result, {
                        __or: [{ deviceType: device.type }, { __not: { __has: "deviceType" } }]
                    });
                }
            }
            else {
                result = this.queriesUtil.addAndFilter(result, {
                    __or: [
                        { 'c8y_Filter.type': device.type },
                        { 'c8y_Filter.type': '' },
                        { __not: { __has: "c8y_Filter.type" } }
                    ]
                });
            }
            return result;
        };
        /**
         * Generates an inventory query object which can be used to find configuration repository entries
         * matching the type of provided device and specified configuration type.
         * @param device The device for which matching repository entries will be queried with the generated query.
         * @param configurationType Configuration type for which matching repository entries will be queried with the generated query.
         */
        RepositoryService.prototype.getConfigurationTypeQuery = function (device, configurationType) {
            var query = this.getDeviceTypeQuery(exports.RepositoryType.CONFIGURATION, device);
            return this.queriesUtil.addAndFilter(query, {
                __or: [
                    { configurationType: configurationType },
                    { configurationType: '' },
                    { __not: { __has: "configurationType" } }
                ]
            });
        };
        /**
         * Gets the list of software installed in the device in the uniform format.
         * Supports c8y_SoftwareList and c8y_Software fragments.
         * @param device The device whose software list should be returned.
         */
        RepositoryService.prototype.getDeviceSoftwareList = function (device) {
            if (device.c8y_SoftwareList) {
                return lodashEs.cloneDeep(device.c8y_SoftwareList);
            }
            if (device.c8y_Software) {
                return lodashEs.map(device.c8y_Software, function (version, name) { return ({ name: name, version: version }); });
            }
            return [];
        };
        /**
         * Prepares a software update operation for given device and the list of changes, and sends it to the device.
         * @param device The device which the operation should be prepared for and sent to.
         * @param changes The list of software changes which should be applied.
         */
        RepositoryService.prototype.createSoftwareUpdateOperation = function (device, changes) {
            return __awaiter(this, void 0, void 0, function () {
                var operation;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            operation = this.getSoftwareUpdateOperation(device, changes);
                            return [4 /*yield*/, this.operation.create(operation)];
                        case 1: return [2 /*return*/, (_b.sent()).data];
                    }
                });
            });
        };
        /**
         * Prepares a software update operation for given device and changes.
         * Returned operation type depends on device's supported operations.
         * Supports c8y_SoftwareUpdate, c8y_SoftwareList, and c8y_Software operations.
         * @param device The device for which operation should be prepared.
         * @param changes The list of software changes which should be applied.
         */
        RepositoryService.prototype.getSoftwareUpdateOperation = function (device, changes) {
            var operation = {
                deviceId: device.id,
                description: "Apply software changes: " + changes
                    .map(function (change) { return change.action + " \"" + change.name + "\"" + (change.version ? " (version: " + change.version + ")" : ''); })
                    .join(', ')
            };
            if (device.c8y_SupportedOperations.includes('c8y_SoftwareUpdate')) {
                operation.c8y_SoftwareUpdate = lodashEs.cloneDeep(changes);
            }
            else if (device.c8y_SupportedOperations.includes('c8y_SoftwareList')) {
                operation.c8y_SoftwareList = lodashEs.cloneDeep(device.c8y_SoftwareList) || [];
                changes.forEach(function (change) {
                    var deviceSoftware = lodashEs.pick(change, ['name', 'version', 'url']);
                    if (change.action === 'delete') {
                        lodashEs.remove(operation.c8y_SoftwareList, deviceSoftware);
                    }
                    if (change.action === 'install') {
                        operation.c8y_SoftwareList.push(deviceSoftware);
                    }
                });
            }
            else if (device.c8y_SupportedOperations.includes('c8y_Software')) {
                operation.c8y_Software = lodashEs.cloneDeep(device.c8y_Software) || {};
                changes.forEach(function (change) {
                    if (change.action === 'delete') {
                        delete operation.c8y_Software[change.name];
                    }
                    if (change.action === 'install') {
                        operation.c8y_Software[change.name] = change.version;
                    }
                });
            }
            return operation;
        };
        /**
         * Extracts the list of device software changes from given operation in the context of given device.
         * @param operation The operation from which the list should be extracted.
         * @param device The target device of the operation.
         */
        RepositoryService.prototype.getDeviceSoftwareChangesFromOperation = function (operation, device) {
            if (operation.c8y_SoftwareUpdate) {
                return lodashEs.cloneDeep(operation.c8y_SoftwareUpdate);
            }
            if (operation.c8y_SoftwareList) {
                return this.getDeviceSoftwareChangesFromSoftwareListOperation(operation, device);
            }
            if (operation.c8y_Software) {
                return this.getDeviceSoftwareChangesFromSoftwareOperation(operation, device);
            }
            return [];
        };
        /**
         * Prepares a firmware update operation for given device and the selected repository binary, and sends it to the device.
         * @param device The device which the operation should be prepared for and sent to.
         * @param selectedOption The selected repository binary option.
         */
        RepositoryService.prototype.createFirmwareUpdateOperation = function (device, selectedOption) {
            return __awaiter(this, void 0, void 0, function () {
                var operation;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            operation = this.getFirmwareUpdateOperation(device, selectedOption);
                            return [4 /*yield*/, this.operation.create(operation)];
                        case 1: return [2 /*return*/, (_b.sent()).data];
                    }
                });
            });
        };
        /**
         * Prepares a firmware update operation for given device and selected version.
         * Supports c8y_Firmware operation.
         * @param device The device for which operation should be prepared.
         * @param selectedOption Selected firmware version.
         */
        RepositoryService.prototype.getFirmwareUpdateOperation = function (device, selectedOption) {
            delete selectedOption.id;
            var operation = {
                deviceId: device.id,
                description: "Update firmware to: \"" + selectedOption.name + "\"" + (selectedOption.version ? " (version: " + selectedOption.version + ")" : ''),
                c8y_Firmware: Object.assign({}, selectedOption)
            };
            return operation;
        };
        /**
         * Prepares a configuration file upload operation for given device and configuration type.
         * @param device The device for which operation should be prepared.
         * @param configurationType Selected configuration type.
         * @param isLegacy  A legacy operation is created without a configurationType.
         */
        RepositoryService.prototype.getUploadConfigurationFileOperation = function (device, configurationType, isLegacy) {
            if (isLegacy === void 0) { isLegacy = false; }
            if (isLegacy) {
                return {
                    deviceId: device.id,
                    description: "Retrieve configuration snapshot from device " + device.name,
                    c8y_UploadConfigFile: {}
                };
            }
            return {
                deviceId: device.id,
                description: "Retrieve " + configurationType + " configuration snapshot from device " + device.name,
                c8y_UploadConfigFile: {
                    type: configurationType
                }
            };
        };
        /**
         * Prepares a configuration file download operation for given device and configuration type.
         * @param device The device for which operation should be prepared.
         * @param configurationType Selected configuration type.
         * @param binaryUrl The url of a binary to be downloaded.
         * @param isLegacy A legacy operation is created without a configurationType.
         */
        RepositoryService.prototype.getDownloadConfigurationFileOperation = function (device, configurationType, configSnapshot, isLegacy) {
            if (isLegacy === void 0) { isLegacy = false; }
            if (isLegacy) {
                return {
                    deviceId: device.id,
                    description: "Send configuration snapshot " + configSnapshot.name + " to device " + device.name,
                    c8y_DownloadConfigFile: {
                        url: configSnapshot.binaryUrl,
                        c8y_ConfigurationDump: {
                            id: configSnapshot.id
                        }
                    }
                };
            }
            return {
                deviceId: device.id,
                description: "Send configuration snapshot " + configSnapshot.name + " of configuration type " + configurationType + " to device " + device.name,
                c8y_DownloadConfigFile: {
                    url: configSnapshot.binaryUrl,
                    type: configurationType
                }
            };
        };
        /**
         * Gets the last firmware update operation for given device.
         * Looks for c8y_Firmware operations.
         * @param deviceId The ID of the device to find an operation for.
         */
        RepositoryService.prototype.getLastFirmwareUpdateOperation = function (deviceId) {
            return __awaiter(this, void 0, void 0, function () {
                var filters;
                return __generator(this, function (_b) {
                    filters = {
                        deviceId: deviceId,
                        dateFrom: new Date(0).toISOString(),
                        dateTo: new Date(Date.now()).toISOString(),
                        revert: true,
                        pageSize: 1
                    };
                    return [2 /*return*/, this.getFirstMatchingOperation([Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_Firmware' })])];
                });
            });
        };
        /**
         * Gets the last software update operation for given device.
         * Looks for c8y_SoftwareUpdate, c8y_SoftwareList, or c8y_Software operations.
         * @param deviceId The ID of the device to find an operation for.
         */
        RepositoryService.prototype.getLastSoftwareUpdateOperation = function (deviceId) {
            return __awaiter(this, void 0, void 0, function () {
                var filters;
                return __generator(this, function (_b) {
                    filters = {
                        deviceId: deviceId,
                        dateFrom: new Date(0).toISOString(),
                        dateTo: new Date(Date.now()).toISOString(),
                        revert: true,
                        pageSize: 1
                    };
                    return [2 /*return*/, this.getFirstMatchingOperation([
                            Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_SoftwareUpdate' }),
                            Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_SoftwareList' }),
                            Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_Software' })
                        ])];
                });
            });
        };
        /**
         * Iterates over the list of filters and queries the operations.
         * If a query returns at least one operation, the first one will be returned.
         * Otherwise the next query will be performed.
         * If none of the queries returns any operation, null will be returned.
         * @param filtersList The list of filters for the queries.
         */
        RepositoryService.prototype.getFirstMatchingOperation = function (filtersList) {
            return __awaiter(this, void 0, void 0, function () {
                var matchingOperation, filtersList_1, filtersList_1_1, filters, operations, e_1_1;
                var e_1, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            matchingOperation = null;
                            _c.label = 1;
                        case 1:
                            _c.trys.push([1, 6, 7, 8]);
                            filtersList_1 = __values(filtersList), filtersList_1_1 = filtersList_1.next();
                            _c.label = 2;
                        case 2:
                            if (!!filtersList_1_1.done) return [3 /*break*/, 5];
                            filters = filtersList_1_1.value;
                            return [4 /*yield*/, this.operation.list(filters)];
                        case 3:
                            operations = (_c.sent()).data;
                            if (operations.length) {
                                matchingOperation = operations[0];
                                return [3 /*break*/, 5];
                            }
                            _c.label = 4;
                        case 4:
                            filtersList_1_1 = filtersList_1.next();
                            return [3 /*break*/, 2];
                        case 5: return [3 /*break*/, 8];
                        case 6:
                            e_1_1 = _c.sent();
                            e_1 = { error: e_1_1 };
                            return [3 /*break*/, 8];
                        case 7:
                            try {
                                if (filtersList_1_1 && !filtersList_1_1.done && (_b = filtersList_1.return)) _b.call(filtersList_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                            return [7 /*endfinally*/];
                        case 8: return [2 /*return*/, matchingOperation];
                    }
                });
            });
        };
        /**
         * Iterates over the list of filters and queries the operations.
         * It compares the operations retrieved by the queries by 'creationTime'
         * and return the latest one.
         * If none of the queries returns any operation, null will be returned.
         * @param filtersList The list of filters for the queries.
         */
        RepositoryService.prototype.getLatestMatchingOperation = function (filtersList) {
            return __awaiter(this, void 0, void 0, function () {
                var matchingOperation, filtersList_2, filtersList_2_1, filters, operations, e_2_1;
                var e_2, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            matchingOperation = null;
                            _c.label = 1;
                        case 1:
                            _c.trys.push([1, 6, 7, 8]);
                            filtersList_2 = __values(filtersList), filtersList_2_1 = filtersList_2.next();
                            _c.label = 2;
                        case 2:
                            if (!!filtersList_2_1.done) return [3 /*break*/, 5];
                            filters = filtersList_2_1.value;
                            return [4 /*yield*/, this.operation.list(filters)];
                        case 3:
                            operations = (_c.sent()).data;
                            if (operations.length) {
                                if (matchingOperation) {
                                    matchingOperation =
                                        new Date(matchingOperation.creationTime).getTime() <
                                            new Date(operations[0].creationTime).getTime()
                                            ? operations[0]
                                            : matchingOperation;
                                }
                                else {
                                    matchingOperation = operations[0];
                                }
                            }
                            _c.label = 4;
                        case 4:
                            filtersList_2_1 = filtersList_2.next();
                            return [3 /*break*/, 2];
                        case 5: return [3 /*break*/, 8];
                        case 6:
                            e_2_1 = _c.sent();
                            e_2 = { error: e_2_1 };
                            return [3 /*break*/, 8];
                        case 7:
                            try {
                                if (filtersList_2_1 && !filtersList_2_1.done && (_b = filtersList_2.return)) _b.call(filtersList_2);
                            }
                            finally { if (e_2) throw e_2.error; }
                            return [7 /*endfinally*/];
                        case 8: return [2 /*return*/, matchingOperation];
                    }
                });
            });
        };
        /**
         * Creates the operation and returns an observable to track its progress.
         * Fails the observable when the operation returns FAILED status.
         * Completes the observable when the operation returns SUCCESSFUL status.
         * @param operation The operation to create and track.
         */
        RepositoryService.prototype.createObservedOperation = function (operation) {
            var _this = this;
            return rxjs.from(this.operation.create(operation)).pipe(operators.map(function (_b) {
                var data = _b.data;
                return data;
            }), operators.take(1), operators.switchMap(function (createdOperation) { return _this.observeOperation(createdOperation); }));
        };
        /**
         * Returns an observable to track progress of given operation.
         * Fails the observable when the operation returns FAILED status.
         * Completes the observable when the operation returns SUCCESSFUL status.
         * @param operation The operation to be observed.
         */
        RepositoryService.prototype.observeOperation = function (operation) {
            var _this = this;
            var observedOperation$ = rxjs.of(operation);
            var operationUpdates$ = observedOperation$.pipe(operators.switchMap(function (observedOperation) { return _this.operationRealtime.onAll$(observedOperation.deviceId); }), operators.map(function (_b) {
                var data = _b.data;
                return data;
            }), operators.withLatestFrom(observedOperation$), operators.filter(function (_b) {
                var _c = __read(_b, 2), operationUpdate = _c[0], observedOperation = _c[1];
                return operationUpdate.id === observedOperation.id;
            }), operators.switchMap(function (_b) {
                var _c = __read(_b, 1), operationUpdate = _c[0];
                if (operationUpdate.status === client.OperationStatus.FAILED) {
                    return rxjs.throwError(operationUpdate);
                }
                return rxjs.of(operationUpdate);
            }), operators.takeWhile(function (operationUpdate) { return operationUpdate.status !== client.OperationStatus.SUCCESSFUL; }, true));
            return rxjs.merge(observedOperation$, operationUpdates$);
        };
        /**
         * Gets a single event with latest creationTime for the given device Id and event type.
         * @param deviceId The device Id for which the events should be queried.
         * @param type Event type.
         */
        RepositoryService.prototype.getLatestConfigurationEvent = function (deviceId, type) {
            return __awaiter(this, void 0, void 0, function () {
                var eventFilter, data;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            eventFilter = {
                                source: deviceId,
                                type: type,
                                dateFrom: this.dateFrom.toISOString(),
                                dateTo: this.dateTo.toISOString(),
                                pageSize: 1
                            };
                            return [4 /*yield*/, this.event.list(eventFilter)];
                        case 1:
                            data = (_b.sent()).data;
                            return [2 /*return*/, data[0]];
                    }
                });
            });
        };
        /**
         * Gets a list of operations for the given device Id, and operation type.
         * @param deviceId The device Id for which the operation should be queried.
         * @param operationType Operation type fragment.
         */
        RepositoryService.prototype.getConfigFileOperationList = function (deviceId, operationType) {
            return __awaiter(this, void 0, void 0, function () {
                var operationFilter;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            operationFilter = {
                                deviceId: deviceId,
                                fragmentType: operationType,
                                dateFrom: this.dateFrom.toISOString(),
                                dateTo: this.dateTo.toISOString(),
                                revert: true,
                                pageSize: 2000
                            };
                            return [4 /*yield*/, this.operation.list(operationFilter)];
                        case 1: return [2 /*return*/, (_b.sent()).data];
                    }
                });
            });
        };
        /**
         * Gets latest uploaded configuration snapshot for the given device, and configuration type.
         * @param device The device for which the configuration snapshot was uploaded.
         * @param configurationType Selected configuration type.
         */
        RepositoryService.prototype.getConfigSnapshot = function (device, configurationType) {
            return __awaiter(this, void 0, void 0, function () {
                var event, configSnapshot, _b, ex_1, msg;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0: return [4 /*yield*/, this.getLatestConfigurationEvent(device.id, configurationType)];
                        case 1:
                            event = _c.sent();
                            if (!event) return [3 /*break*/, 6];
                            configSnapshot = {
                                time: event.time,
                                name: event.text,
                                deviceType: device.type,
                                configurationType: configurationType
                            };
                            _c.label = 2;
                        case 2:
                            _c.trys.push([2, 5, , 6]);
                            _b = configSnapshot;
                            return [4 /*yield*/, this.eventBinary.download(event)];
                        case 3: return [4 /*yield*/, (_c.sent()).text()];
                        case 4:
                            _b.binary = _c.sent();
                            if (event.c8y_IsBinary) {
                                configSnapshot.binaryType = event.c8y_IsBinary.type;
                            }
                            return [3 /*break*/, 6];
                        case 5:
                            ex_1 = _c.sent();
                            msg = ngxComponents.gettext('Could not get the binary.');
                            this.alert.danger(msg);
                            return [3 /*break*/, 6];
                        case 6: return [2 /*return*/, configSnapshot];
                    }
                });
            });
        };
        RepositoryService.prototype.getLegacyConfigSnapshot = function (deviceId) {
            return __awaiter(this, void 0, void 0, function () {
                var configSnapshot, mo, device, snapshotId, ex_2, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0: return [4 /*yield*/, this.inventory.detail(deviceId, { withChildren: false })];
                        case 1:
                            device = (_c.sent()).data;
                            snapshotId = device.c8y_ConfigurationDump && device.c8y_ConfigurationDump.id;
                            if (!snapshotId) {
                                return [2 /*return*/];
                            }
                            _c.label = 2;
                        case 2:
                            _c.trys.push([2, 4, , 5]);
                            return [4 /*yield*/, this.inventory.detail(snapshotId)];
                        case 3:
                            mo = (_c.sent()).data;
                            return [3 /*break*/, 5];
                        case 4:
                            ex_2 = _c.sent();
                            return [3 /*break*/, 5];
                        case 5:
                            if (!mo) return [3 /*break*/, 7];
                            configSnapshot = {
                                time: mo.creationTime,
                                name: mo.name
                            };
                            _b = configSnapshot;
                            return [4 /*yield*/, this.getBinaryText(mo.url, { allowExternal: false })];
                        case 6:
                            _b.binary = _c.sent();
                            _c.label = 7;
                        case 7: return [2 /*return*/, configSnapshot];
                    }
                });
            });
        };
        /**
         * Returns a binary object as text.
         * @param binaryUrl The URL to find binary
         * @param options The object with additional options:
         * - **allowExternal** - `boolean` - allows downloading external binary file
         * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`
         */
        RepositoryService.prototype.getBinaryText = function (binaryUrl, options) {
            return __awaiter(this, void 0, void 0, function () {
                var binaryId, res;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            binaryId = this.inventoryBinary.getIdFromUrl(binaryUrl);
                            if (!(!binaryId && options.allowExternal)) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.getExternalBinaryResponse(binaryUrl, options)];
                        case 1:
                            res = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, this.getInternalBinaryResponse(binaryId, options)];
                        case 3:
                            res = _b.sent();
                            _b.label = 4;
                        case 4:
                            if (!res) {
                                return [2 /*return*/, null];
                            }
                            return [2 /*return*/, res.text()];
                    }
                });
            });
        };
        /**
         * Returns a binary object as File.
         * @param binaryUrl The URL to find binary
         * @param options The object with additional options:
         * - **allowExternal** - `boolean` - allows downloading external binary file
         */
        RepositoryService.prototype.getBinaryFile = function (binaryUrl, options) {
            return __awaiter(this, void 0, void 0, function () {
                var binaryId, _b, name, contentType, res, _c, arrayBuffer;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            binaryId = this.inventoryBinary.getIdFromUrl(binaryUrl);
                            if (!binaryId && !options.allowExternal) {
                                return [2 /*return*/, null];
                            }
                            return [4 /*yield*/, this.inventory.detail(binaryId)];
                        case 1:
                            _b = (_d.sent()).data, name = _b.name, contentType = _b.contentType;
                            if (!!!binaryId) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.getInternalBinaryResponse(binaryId)];
                        case 2:
                            _c = _d.sent();
                            return [3 /*break*/, 5];
                        case 3: return [4 /*yield*/, this.getExternalBinaryResponse(binaryUrl)];
                        case 4:
                            _c = _d.sent();
                            _d.label = 5;
                        case 5:
                            res = _c;
                            return [4 /*yield*/, res.arrayBuffer()];
                        case 6:
                            arrayBuffer = _d.sent();
                            return [2 /*return*/, new File([arrayBuffer], name, { type: contentType })];
                    }
                });
            });
        };
        /**
         * Gets the last configuration update operation for given device.
         * Looks for c8y_Configuration and c8y_SendConfiguration operations.
         * @param deviceId The ID of the device to find an operation for.
         */
        RepositoryService.prototype.getLastConfigUpdateOperation = function (deviceId) {
            return __awaiter(this, void 0, void 0, function () {
                var filters;
                return __generator(this, function (_b) {
                    filters = {
                        deviceId: deviceId,
                        dateFrom: new Date(0).toISOString(),
                        dateTo: new Date(Date.now()).toISOString(),
                        revert: true,
                        pageSize: 1
                    };
                    return [2 /*return*/, this.getLatestMatchingOperation([
                            Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_Configuration' }),
                            Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_SendConfiguration' })
                        ])];
                });
            });
        };
        /**
         * Prepares a configuration download operation for given device and its current configuration.
         * Supports c8y_SendConfiguration operation.
         * @param device The device for which operation should be prepared.
         */
        RepositoryService.prototype.createTextBasedConfigurationReloadOperation = function (device) {
            return {
                deviceId: device.id,
                description: ngxComponents.gettext('Requested current configuration'),
                c8y_SendConfiguration: {}
            };
        };
        /**
         * Prepares a configuration update operation for the given device.
         * Supports c8y_Configuration operation.
         * @param device The device for which operation should be prepared.
         * @param config The configuration which will update the existing one.
         */
        RepositoryService.prototype.createTextBasedConfigurationUpdateOperation = function (device, config) {
            return {
                deviceId: device.id,
                description: ngxComponents.gettext('Configuration update'),
                c8y_Configuration: {
                    config: config
                }
            };
        };
        RepositoryService.prototype.getBinary = function (binaryId) {
            return __awaiter(this, void 0, void 0, function () {
                var ex_3, msg;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, this.inventoryBinary.download(binaryId)];
                        case 1: return [2 /*return*/, _b.sent()];
                        case 2:
                            ex_3 = _b.sent();
                            msg = ngxComponents.gettext('Could not get the binary.');
                            this.alert.danger(msg);
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Gets all available snapshots from the repository for the given device.
         * @param device The device for which the snapshots should be prepared.
         * @param configurationType Selected configuration type.
         */
        RepositoryService.prototype.getSnapshotsFromRepository = function (device, configurationType) {
            return __awaiter(this, void 0, void 0, function () {
                var searchQuery, res;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            searchQuery = this.getConfigurationTypeQuery(device, configurationType);
                            return [4 /*yield*/, this.listRepositoryEntries(exports.RepositoryType.CONFIGURATION, {
                                    query: searchQuery,
                                    params: { pageSize: 100 }
                                })];
                        case 1:
                            res = _b.sent();
                            return [2 /*return*/, res.data];
                    }
                });
            });
        };
        /**
         * Returns a binary object.
         * @param binaryId binary ID
         * @param options The object with additional options:
         * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`
         */
        RepositoryService.prototype.getInternalBinaryResponse = function (binaryId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var res, ex_4, msg;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, this.inventoryBinary.download(binaryId)];
                        case 1:
                            res = _b.sent();
                            return [3 /*break*/, 3];
                        case 2:
                            ex_4 = _b.sent();
                            if (!options.noAlerts) {
                                msg = ngxComponents.gettext('Could not get the binary.');
                                this.alert.danger(msg);
                            }
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/, res];
                    }
                });
            });
        };
        /**
         * Returns a binary object.
         * @param binaryUrl The URL to find binary
         * @param options The object with additional options:
         * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`
         */
        RepositoryService.prototype.getExternalBinaryResponse = function (binaryUrl, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var res, fetchRes, _a_1, msg;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, fetch(binaryUrl)];
                        case 1:
                            fetchRes = _b.sent();
                            if (fetchRes.status >= 400) {
                                throw res;
                            }
                            res = fetchRes;
                            return [3 /*break*/, 3];
                        case 2:
                            _a_1 = _b.sent();
                            if (!options.noAlerts) {
                                msg = ngxComponents.gettext('Could not get the external binary');
                                this.alert.danger(msg);
                            }
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/, res];
                    }
                });
            });
        };
        RepositoryService.prototype.createEntry = function (mo) {
            return __awaiter(this, void 0, void 0, function () {
                var binaryId, newMo;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.inventoryBinary.getIdFromUrl(mo.url)];
                        case 1:
                            binaryId = _b.sent();
                            return [4 /*yield*/, this.inventory.create(mo)];
                        case 2:
                            newMo = _b.sent();
                            if (!binaryId) return [3 /*break*/, 4];
                            return [4 /*yield*/, this.inventory.childAdditionsAdd(binaryId, newMo.data)];
                        case 3:
                            _b.sent();
                            _b.label = 4;
                        case 4: return [2 /*return*/, newMo];
                    }
                });
            });
        };
        RepositoryService.prototype.updateEntry = function (mo, url) {
            return __awaiter(this, void 0, void 0, function () {
                var existingBinaryId, newBinaryId, id;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.inventoryBinary.getIdFromUrl(url)];
                        case 1:
                            existingBinaryId = _b.sent();
                            return [4 /*yield*/, this.inventoryBinary.getIdFromUrl(mo.url)];
                        case 2:
                            newBinaryId = _b.sent();
                            if (!(existingBinaryId && existingBinaryId !== newBinaryId)) return [3 /*break*/, 4];
                            id = this.inventoryBinary.getIdFromUrl(url);
                            return [4 /*yield*/, this.inventoryBinary.delete(id)];
                        case 3:
                            _b.sent();
                            _b.label = 4;
                        case 4:
                            if (!newBinaryId) return [3 /*break*/, 6];
                            return [4 /*yield*/, this.inventory.childAdditionsAdd(newBinaryId, mo)];
                        case 5:
                            _b.sent();
                            _b.label = 6;
                        case 6: return [2 /*return*/, this.inventory.update(mo)];
                    }
                });
            });
        };
        RepositoryService.prototype.getBaseVersionResultListForLegacyEntry = function (entry) {
            var _b;
            return Promise.resolve({
                res: {},
                data: [
                    Object.assign(Object.assign({}, entry), (_b = {}, _b[entry.type] = {
                        version: entry.version,
                        url: entry.url
                    }, _b))
                ]
            });
        };
        RepositoryService.prototype.getDeviceSoftwareChangesFromSoftwareListOperation = function (operation, device) {
            var changes = [];
            lodashEs.forEach(device.c8y_SoftwareList, function (deviceSoftware) {
                var operationSoftware = lodashEs.find(operation.c8y_SoftwareList, { name: deviceSoftware.name });
                if ((operationSoftware && operationSoftware.version) !==
                    (deviceSoftware && deviceSoftware.version)) {
                    changes.push(Object.assign(Object.assign({}, deviceSoftware), { action: 'delete' }));
                }
            });
            lodashEs.forEach(operation.c8y_SoftwareList, function (operationSoftware) {
                var deviceSoftware = lodashEs.find(device.c8y_SoftwareList, { name: operationSoftware.name });
                if ((operationSoftware && operationSoftware.version) !==
                    (deviceSoftware && deviceSoftware.version)) {
                    changes.push(Object.assign(Object.assign({}, operationSoftware), { action: 'install' }));
                }
            });
            return changes;
        };
        RepositoryService.prototype.getDeviceSoftwareChangesFromSoftwareOperation = function (operation, device) {
            var changes = [];
            lodashEs.forEach(device.c8y_Software, function (deviceSoftwareVersion, deviceSoftwareName) {
                if (operation.c8y_Software[deviceSoftwareName] !== deviceSoftwareVersion) {
                    changes.push({
                        name: deviceSoftwareName,
                        version: deviceSoftwareVersion,
                        action: 'delete'
                    });
                }
            });
            lodashEs.forEach(operation.c8y_Software, function (operationSoftwareVersion, operationSoftwareName) {
                var deviceSoftwareVersion = device.c8y_Software && device.c8y_Software[operationSoftwareName];
                if (deviceSoftwareVersion !== operationSoftwareVersion) {
                    changes.push({
                        name: operationSoftwareName,
                        version: operationSoftwareVersion,
                        action: 'install'
                    });
                }
            });
            return changes;
        };
        return RepositoryService;
    }());
    RepositoryService.decorators = [
        { type: core.Injectable }
    ];
    RepositoryService.ctorParameters = function () { return [
        { type: client.InventoryService },
        { type: client.InventoryBinaryService },
        { type: client.OperationService },
        { type: ngxComponents.AlertService },
        { type: client.EventService },
        { type: ngxComponents.OperationRealtimeService },
        { type: client.EventBinaryService }
    ]; };

    var SaveToRepositoryComponent = /** @class */ (function () {
        function SaveToRepositoryComponent(modal, alertService, repositoryService) {
            var _this = this;
            this.modal = modal;
            this.alertService = alertService;
            this.repositoryService = repositoryService;
            this.result = new Promise(function (resolve, reject) {
                _this._save = resolve;
                _this._cancel = reject;
            });
        }
        SaveToRepositoryComponent.prototype.save = function () {
            return __awaiter(this, void 0, void 0, function () {
                var configSnapshotData, ex_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            configSnapshotData = {
                                selected: {
                                    configurationType: this.configSnapshot.configurationType
                                },
                                version: this.configSnapshot.name,
                                deviceType: this.configSnapshot.deviceType,
                                description: this.configSnapshot.description,
                                binary: {
                                    file: new File([this.configSnapshot.binary], this.configSnapshot.name)
                                }
                            };
                            return [4 /*yield*/, this.repositoryService.save(configSnapshotData, exports.RepositoryType.CONFIGURATION)];
                        case 1:
                            _a.sent();
                            this.alertService.success(ngxComponents.gettext('Configuration saved.'));
                            this._save();
                            return [3 /*break*/, 3];
                        case 2:
                            ex_1 = _a.sent();
                            this.alertService.addServerFailure(ex_1);
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        SaveToRepositoryComponent.prototype.close = function () {
            this._cancel();
            this.modal.hide();
        };
        return SaveToRepositoryComponent;
    }());
    SaveToRepositoryComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-save-config-to-configuration-repository',
                    template: "<div class=\"modal-header bg-primary text-center text-white\">\n  <div style=\"font-size: 62px;\">\n    <span c8yIcon=\"gears\"></span>\n  </div>\n  <h4 class=\"text-uppercase\" translate>\n    Save configuration\n  </h4>\n</div>\n<div class=\"modal-body\">\n  <form #saveConfigurationSnapshot=\"ngForm\" class=\"p-t-24\">\n    <c8y-form-group>\n      <label translate for=\"name\">Name</label>\n      <input\n        id=\"name\"\n        type=\"text\"\n        class=\"form-control\"\n        autocomplete=\"off\"\n        name=\"name\"\n        [(ngModel)]=\"configSnapshot.name\"\n        required\n      />\n    </c8y-form-group>\n    <c8y-form-group>\n      <label translate for=\"deviceType\">Device type</label>\n      <input\n        id=\"deviceType\"\n        class=\"form-control\"\n        rows=\"6\"\n        name=\"deviceType\"\n        [(ngModel)]=\"configSnapshot.deviceType\"\n      />\n    </c8y-form-group>\n    <c8y-form-group>\n      <label translate for=\"description\">Description</label>\n      <input\n        type=\"text\"\n        id=\"description\"\n        class=\"form-control\"\n        maxlength=\"254\"\n        autocomplete=\"off\"\n        name=\"description\"\n        [(ngModel)]=\"configSnapshot.description\"\n      />\n    </c8y-form-group>\n    <c8y-form-group>\n      <label translate for=\"configurationType\">Configuration type</label>\n      <input\n        id=\"configurationType\"\n        class=\"form-control\"\n        rows=\"6\"\n        name=\"configurationType\"\n        [(ngModel)]=\"configSnapshot.configurationType\"\n      />\n    </c8y-form-group>\n  </form>\n</div>\n<div class=\"modal-footer\">\n  <button title=\"{{ 'Cancel' | translate }}\" class=\"btn btn-default\" (click)=\"close()\" translate>\n    Cancel\n  </button>\n\n  <button\n    title=\"{{ 'Save configuration to repository' | translate }}\"\n    class=\"btn btn-primary\"\n    (click)=\"save()\"\n    [disabled]=\"saveConfigurationSnapshot.form.invalid\"\n    translate\n  >\n    Save\n  </button>\n</div>\n"
                },] }
    ];
    SaveToRepositoryComponent.ctorParameters = function () { return [
        { type: modal.BsModalRef },
        { type: ngxComponents.AlertService },
        { type: RepositoryService }
    ]; };

    var ConfigurationPreviewComponent = /** @class */ (function () {
        function ConfigurationPreviewComponent(deviceConfigurationService, operationRealtime, bsModal, user, appState, repositoryService, operationService, alertService) {
            this.deviceConfigurationService = deviceConfigurationService;
            this.operationRealtime = operationRealtime;
            this.bsModal = bsModal;
            this.user = user;
            this.appState = appState;
            this.repositoryService = repositoryService;
            this.operationService = operationService;
            this.alertService = alertService;
            this.isLegacy = false;
            this.canCallAction = true;
            this.deviceConfigurationOperation = exports.DeviceConfigurationOperation;
        }
        Object.defineProperty(ConfigurationPreviewComponent.prototype, "configurationType", {
            get: function () {
                return this._configurationType;
            },
            set: function (type) {
                this._configurationType = type;
                this.setOperation(type);
            },
            enumerable: false,
            configurable: true
        });
        ConfigurationPreviewComponent.prototype.ngOnInit = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    this.setCanCallAction();
                    this.setOperation(this._configurationType);
                    this.operationsSubscription = this.operationRealtime
                        .onAll$(this.device.id)
                        .pipe(operators.map(function (_a) {
                        var data = _a.data;
                        return data;
                    }))
                        .subscribe(function (operation) {
                        _this.updatePreview(operation);
                    });
                    return [2 /*return*/];
                });
            });
        };
        ConfigurationPreviewComponent.prototype.setOperation = function (configType) {
            return __awaiter(this, void 0, void 0, function () {
                var operationList, operation;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.repositoryService.getConfigFileOperationList(this.device.id, this.operationToTrigger)];
                        case 1:
                            operationList = _a.sent();
                            operation = this.isLegacy
                                ? operationList.find(function (op) { return op[_this.operationToTrigger] && !op[_this.operationToTrigger].type; })
                                : operationList.find(function (op) { return op[_this.operationToTrigger].type === configType; });
                            this.operation =
                                operation && operation.status !== client.OperationStatus.SUCCESSFUL ? operation : undefined;
                            return [2 /*return*/];
                    }
                });
            });
        };
        ConfigurationPreviewComponent.prototype.setCanCallAction = function () {
            this.canCallAction = this.deviceConfigurationService.hasAnySupportedOperation(this.device, this.operationToTrigger);
        };
        ConfigurationPreviewComponent.prototype.createDeviceOperation = function () {
            return __awaiter(this, void 0, void 0, function () {
                var operationCfg, _a, ex_1;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (this.operationToTrigger === exports.DeviceConfigurationOperation.DOWNLOAD_CONFIG) {
                                operationCfg = this.repositoryService.getDownloadConfigurationFileOperation(this.device, this._configurationType, this.configSnapshot, this.isLegacy);
                            }
                            if (this.operationToTrigger === exports.DeviceConfigurationOperation.UPLOAD_CONFIG) {
                                operationCfg = this.repositoryService.getUploadConfigurationFileOperation(this.device, this._configurationType, this.isLegacy);
                            }
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 3, , 4]);
                            _a = this;
                            return [4 /*yield*/, this.operationService.create(operationCfg)];
                        case 2:
                            _a.operation = (_b.sent()).data;
                            return [3 /*break*/, 4];
                        case 3:
                            ex_1 = _b.sent();
                            this.alertService.addServerFailure(ex_1);
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        ConfigurationPreviewComponent.prototype.showOperation = function () {
            if (this.operationToTrigger === exports.DeviceConfigurationOperation.DOWNLOAD_CONFIG) {
                return !!this.operation;
            }
            return (this.operation &&
                [client.OperationStatus.PENDING, client.OperationStatus.EXECUTING, client.OperationStatus.FAILED].includes(this.operation.status));
        };
        ConfigurationPreviewComponent.prototype.showBinary = function () {
            if (this.operationToTrigger === exports.DeviceConfigurationOperation.DOWNLOAD_CONFIG) {
                return true;
            }
            return !this.showOperation();
        };
        ConfigurationPreviewComponent.prototype.isCreateOperationDisabled = function () {
            return (this.operation &&
                [client.OperationStatus.PENDING, client.OperationStatus.EXECUTING].includes(this.operation.status));
        };
        ConfigurationPreviewComponent.prototype.updatePreview = function (operation) {
            if (operation &&
                operation[this.operationToTrigger] &&
                (this.isLegacy ||
                    (operation[this.operationToTrigger].type &&
                        operation[this.operationToTrigger].type === this.configurationType))) {
                this.operation = operation;
                this.updateSnapshotsOnConfigUpload(operation);
            }
        };
        ConfigurationPreviewComponent.prototype.download = function () {
            var blob = new Blob([this.configSnapshot.binary], { type: this.configSnapshot.binaryType });
            var fileName = this.configSnapshot.name;
            switch (this.configSnapshot.binaryType) {
                case 'text/csv':
                case 'application/csv':
                    fileName = fileName.concat('.csv');
                    break;
                case 'text/yaml':
                case 'application/x-yaml':
                    fileName = fileName.concat('.yaml');
                    break;
                case 'application/json':
                    fileName = fileName.concat('.json');
                    break;
            }
            fileSaver.saveAs(blob, fileName);
        };
        ConfigurationPreviewComponent.prototype.saveToRepository = function () {
            return __awaiter(this, void 0, void 0, function () {
                var initialState, modal, ex_2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            initialState = {
                                configSnapshot: lodashEs.cloneDeep(this.configSnapshot)
                            };
                            modal = this.bsModal.show(SaveToRepositoryComponent, {
                                class: 'modal-sm',
                                initialState: initialState,
                                ignoreBackdropClick: true
                            }).content;
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, modal.result];
                        case 2:
                            _a.sent();
                            this.deviceConfigurationService.updateConfigurations(true);
                            modal.close();
                            return [3 /*break*/, 4];
                        case 3:
                            ex_2 = _a.sent();
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        ConfigurationPreviewComponent.prototype.hasPermission = function () {
            return this.user.hasAnyRole(this.appState.currentUser.value, [
                'ROLE_INVENTORY_ADMIN',
                'ROLE_INVENTORY_CREATE'
            ]);
        };
        ConfigurationPreviewComponent.prototype.ngOnDestroy = function () {
            if (this.operationsSubscription) {
                this.operationsSubscription.unsubscribe();
            }
        };
        ConfigurationPreviewComponent.prototype.updateSnapshotsOnConfigUpload = function (operation) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (operation[exports.DeviceConfigurationOperation.UPLOAD_CONFIG] &&
                        operation.status === client.OperationStatus.SUCCESSFUL) {
                        this.deviceConfigurationService.updateConfigurations();
                    }
                    return [2 /*return*/];
                });
            });
        };
        return ConfigurationPreviewComponent;
    }());
    ConfigurationPreviewComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-device-configuration-preview',
                    template: "<div class=\"content-flex-55 p-b-16\">\n  <div class=\"col-7 p-t-4\">\n    <p>\n      <span class=\"text-label-small text-uppercase m-r-4\" translate>Configuration</span>\n      <span *ngIf=\"configSnapshot?.name; else emptyText\">\n        <strong>{{ configSnapshot.name }}</strong>\n      </span>\n      <ng-template #emptyText> --- </ng-template>\n    </p>\n    <p>\n      <span class=\"text-label-small text-uppercase m-r-4\" translate>Last updated</span>\n      <small *ngIf=\"configSnapshot?.time; else emptyDate\">\n        {{ configSnapshot.time | c8yDate }}\n      </small>\n      <ng-template #emptyDate> --- </ng-template>\n    </p>\n  </div>\n  <div class=\"col-5\">\n    <button\n      id=\"action-btn\"\n      class=\"btn btn-default btn-sm pull-right\"\n      type=\"button\"\n      title=\"{{ actionButtonText | translate }}\"\n      (click)=\"createDeviceOperation()\"\n      [disabled]=\"isCreateOperationDisabled()\"\n      *ngIf=\"canCallAction\"\n    >\n      <i [c8yIcon]=\"actionButtonIcon\"></i> {{ actionButtonText | translate }}\n    </button>\n  </div>\n</div>\n<div class=\"c8y-empty-state text-left\" *ngIf=\"!configSnapshot?.binary && showBinary()\">\n  <h1 [c8yIcon]=\"'file-image-o'\"></h1>\n  <p>\n    <strong translate>No preview available.</strong><br />\n    <small *ngIf=\"configSnapshot?.binary !== ''; else emptyFile\" translate\n      >The file is not available.</small\n    >\n    <ng-template #emptyFile>\n      <small translate>The file is empty.</small>\n    </ng-template>\n  </p>\n</div>\n<div *ngIf=\"configSnapshot?.binary && showBinary()\" class=\"flex-grow d-flex d-col\">\n  <c8y-source-code-preview\n    [text]=\"configSnapshot.binary\"\n    [isDisabled]=\"true\"\n    class=\"d-contents\"\n  ></c8y-source-code-preview>\n  <div *ngIf=\"canSaveSnapshot\" class=\"p-t-16\">\n    <button\n      type=\"button\"\n      class=\"btn btn-primary btn-sm pull-right m-l-8\"\n      (click)=\"download()\"\n      translate\n    >\n      Download\n    </button>\n    <button\n      *ngIf=\"hasPermission()\"\n      type=\"button\"\n      class=\"btn btn-default btn-sm pull-right\"\n      (click)=\"saveToRepository()\"\n      translate\n    >\n      Save to repository\n    </button>\n  </div>\n</div>\n<div *ngIf=\"showOperation()\">\n  <c8y-single-operation [operation]=\"operation\"></c8y-single-operation>\n</div>\n"
                },] }
    ];
    ConfigurationPreviewComponent.ctorParameters = function () { return [
        { type: DeviceConfigurationService },
        { type: ngxComponents.OperationRealtimeService },
        { type: modal.BsModalService },
        { type: client.UserService },
        { type: ngxComponents.AppStateService },
        { type: RepositoryService },
        { type: client.OperationService },
        { type: ngxComponents.AlertService }
    ]; };
    ConfigurationPreviewComponent.propDecorators = {
        device: [{ type: core.Input }],
        configurationType: [{ type: core.Input }],
        configSnapshot: [{ type: core.Input }],
        canSaveSnapshot: [{ type: core.Input }],
        actionButtonText: [{ type: core.Input }],
        actionButtonIcon: [{ type: core.Input }],
        isLegacy: [{ type: core.Input }],
        operationToTrigger: [{ type: core.Input }]
    };

    var DeviceConfigurationListComponent = /** @class */ (function () {
        function DeviceConfigurationListComponent() {
            this.configSelected = new core.EventEmitter();
            this.filterTerm = '';
        }
        DeviceConfigurationListComponent.prototype.showConfigurationTypePreview = function (config) {
            this.selectedConfig = config;
            this.configSelected.emit(config);
        };
        DeviceConfigurationListComponent.prototype.updatePipe = function (filterTerm) {
            this.filterTerm = filterTerm;
        };
        return DeviceConfigurationListComponent;
    }());
    DeviceConfigurationListComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-device-configuration-list',
                    template: "<div class=\"p-l-16 m-b-8\" *ngIf=\"isFilterEnabled\">\n  <c8y-filter [icon]=\"'search'\" (onSearch)=\"updatePipe($event)\"></c8y-filter>\n</div>\n\n<!-- EMPTY STATE -->\n<div class=\"c8y-empty-state text-left\" *ngIf=\"items?.length === 0\">\n  <h1 [c8yIcon]=\"emptyState.icon\"></h1>\n  <p>\n    <strong>{{ emptyState.title | translate }}</strong\n    ><br />\n    <small>{{ emptyState.text | translate }}</small>\n  </p>\n</div>\n\n<!-- CONFIGURATIONS AVAILABLE -->\n<div class=\"c8y-nav-stacked\">\n  <div\n    class=\"c8y-stacked-item flex-row\"\n    [class.active]=\"config === selectedConfig\"\n    *ngFor=\"let config of items | configurationFilterPipe: filterTerm\"\n    (click)=\"showConfigurationTypePreview(config)\"\n  >\n    <div class=\"list-item-icon\">\n      <i [c8yIcon]=\"itemIcon\"></i>\n    </div>\n    <div class=\"list-item-body text-truncate\">\n      <div class=\"d-flex\">\n        <span class=\"text-truncate\" title=\"{{ config.name }}\">{{ config.name }}</span>\n        <span class=\"text-label-small flex-item-right flex-item-middle\">{{ config.deviceType }}</span>\n      </div>\n    </div>\n  </div>\n</div>\n\n<!-- for Carlos: config.configurationType to differentiate whether a config matches configuration type. -->\n"
                },] }
    ];
    DeviceConfigurationListComponent.propDecorators = {
        items: [{ type: core.Input }],
        itemIcon: [{ type: core.Input }],
        emptyState: [{ type: core.Input }],
        isFilterEnabled: [{ type: core.Input }],
        configSelected: [{ type: core.Output }]
    };

    var TextBasedConfigurationComponent = /** @class */ (function () {
        function TextBasedConfigurationComponent(route, alertService, repositoryService, deviceConfigurationService, inventoryService) {
            this.route = route;
            this.alertService = alertService;
            this.repositoryService = repositoryService;
            this.deviceConfigurationService = deviceConfigurationService;
            this.inventoryService = inventoryService;
            this.reloadingConfig = false;
        }
        TextBasedConfigurationComponent.prototype.ngOnInit = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.load()];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        TextBasedConfigurationComponent.prototype.load = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.device = this.route.snapshot.parent.data.contextData;
                            return [4 /*yield*/, this.loadDevice()];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.loadOperation()];
                        case 2:
                            _a.sent();
                            this.showTextBasedConfigReload = this.deviceConfigurationService.hasAnySupportedOperation(this.device, [exports.DeviceConfigurationOperation.SEND_CONFIG]);
                            this.showTextBasedConfigSave = this.deviceConfigurationService.hasAnySupportedOperation(this.device, [exports.DeviceConfigurationOperation.CONFIG]);
                            if (this.device.c8y_Configuration && this.device.c8y_Configuration.config) {
                                this.config = this.device.c8y_Configuration.config;
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        TextBasedConfigurationComponent.prototype.loadOperation = function () {
            return __awaiter(this, void 0, void 0, function () {
                var operation;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.repositoryService.getLastConfigUpdateOperation(this.device.id)];
                        case 1:
                            operation = _a.sent();
                            if (operation !== null) {
                                this.reloadingConfig =
                                    !!operation.c8y_SendConfiguration &&
                                        (operation.status === client.OperationStatus.PENDING ||
                                            operation.status === client.OperationStatus.EXECUTING);
                                this.repositoryService.observeOperation(operation).subscribe(function (operationUpdate) {
                                    _this.latestOperation = operationUpdate;
                                });
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        Object.defineProperty(TextBasedConfigurationComponent.prototype, "savingConfig", {
            get: function () {
                return this.latestOperation
                    ? !!this.latestOperation.c8y_Configuration &&
                        (this.latestOperation.status === client.OperationStatus.PENDING ||
                            this.latestOperation.status === client.OperationStatus.EXECUTING)
                    : false;
            },
            enumerable: false,
            configurable: true
        });
        TextBasedConfigurationComponent.prototype.reloadConfiguration = function () {
            return __awaiter(this, void 0, void 0, function () {
                var operationCfg;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.reloadingConfig = true;
                            return [4 /*yield*/, this.repositoryService.createTextBasedConfigurationReloadOperation(this.device)];
                        case 1:
                            operationCfg = _a.sent();
                            try {
                                this.repositoryService
                                    .createObservedOperation(operationCfg)
                                    .subscribe(function (operationUpdate) { return _this.onOperationReloadSuccess(operationUpdate); }, function (operationUpdate) { return _this.onOperationReloadError(operationUpdate); }, function () { return _this.onOperationReloadComplete(); });
                            }
                            catch (ex) {
                                this.alertService.addServerFailure(ex);
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        TextBasedConfigurationComponent.prototype.updateConfiguration = function (config) {
            return __awaiter(this, void 0, void 0, function () {
                var operationCfg;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.repositoryService.createTextBasedConfigurationUpdateOperation(this.device, config)];
                        case 1:
                            operationCfg = _a.sent();
                            try {
                                this.repositoryService
                                    .createObservedOperation(operationCfg)
                                    .subscribe(function (operationUpdate) { return _this.onOperationUpdateSuccess(operationUpdate); }, function (operationUpdate) { return _this.onOperationUpdateError(operationUpdate); }, function () { return _this.onOperationUpdateComplete(); });
                            }
                            catch (ex) {
                                this.alertService.addServerFailure(ex);
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        TextBasedConfigurationComponent.prototype.onOperationReloadSuccess = function (operationUpdate) {
            this.latestOperation = operationUpdate;
            if (operationUpdate.status === client.OperationStatus.PENDING) {
                this.alertService.success(ngxComponents.gettext('Configuration will be reloaded.'));
            }
        };
        TextBasedConfigurationComponent.prototype.onOperationReloadError = function (operationUpdate) {
            this.latestOperation = operationUpdate;
            this.reloadingConfig = false;
        };
        TextBasedConfigurationComponent.prototype.onOperationReloadComplete = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.loadDevice()];
                        case 1:
                            _a.sent();
                            this.config = this.device.c8y_Configuration.config;
                            this.reloadingConfig = false;
                            return [2 /*return*/];
                    }
                });
            });
        };
        TextBasedConfigurationComponent.prototype.onOperationUpdateSuccess = function (operationUpdate) {
            this.latestOperation = operationUpdate;
            if (operationUpdate.status === client.OperationStatus.PENDING) {
                this.alertService.success(ngxComponents.gettext('Configuration will be updated.'));
            }
        };
        TextBasedConfigurationComponent.prototype.onOperationUpdateError = function (operationUpdate) {
            this.latestOperation = operationUpdate;
        };
        TextBasedConfigurationComponent.prototype.onOperationUpdateComplete = function () {
            this.device.c8y_Configuration.config = this.config;
        };
        TextBasedConfigurationComponent.prototype.loadDevice = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _a = this;
                            return [4 /*yield*/, this.inventoryService.detail(this.device.id, {
                                    withChildren: false
                                })];
                        case 1:
                            _a.device = (_b.sent()).data;
                            return [2 /*return*/];
                    }
                });
            });
        };
        return TextBasedConfigurationComponent;
    }());
    TextBasedConfigurationComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-text-based-configuration',
                    template: "<div class=\"d-flex d-col fit-h\">\n  <fieldset class=\"card-block bg-gray-white fit-w\">\n    <div class=\"content-flex-50\">\n      <div class=\"flex-item-left d-flex\">\n        <button\n          title=\"{{ 'Get configuration from device' | translate }}\"\n          type=\"button\"\n          class=\"btn btn-default btn-sm flex-item-v-center m-t-8 m-b-8\"\n          *ngIf=\"showTextBasedConfigReload\"\n          (click)=\"reloadConfiguration()\"\n          [disabled]=\"reloadingConfig || savingConfig\"\n        >\n          <i\n            c8yIcon=\"refresh\"\n            *ngIf=\"reloadingConfig\"\n            class=\"m-r-4\"\n            [ngClass]=\"{ 'icon-spin': reloadingConfig }\"\n          ></i>\n          <i c8yIcon=\"download\" *ngIf=\"!reloadingConfig\" class=\"m-r-4\"></i>\n\n          {{ 'Get configuration from device' | translate }}\n        </button>\n      </div>\n      <c8y-single-operation\n        *ngIf=\"latestOperation !== undefined\"\n        [operation]=\"latestOperation\"\n        class=\"flex-grow\"\n      ></c8y-single-operation>\n    </div>\n  </fieldset>\n  <div class=\"flex-grow\">\n    <textarea\n      [(ngModel)]=\"config\"\n      class=\"form-control fit-h p-r-16 p-l-16\"\n      [disabled]=\"reloadingConfig || savingConfig\"\n      c8y-spellcheck=\"false\"\n    ></textarea>\n  </div>\n  <div class=\"card-footer fit-w separator\" *ngIf=\"showTextBasedConfigSave\">\n    <button\n      type=\"button\"\n      id=\"send-config-btn\"\n      (click)=\"updateConfiguration(config)\"\n      [disabled]=\"reloadingConfig || savingConfig || !config\"\n      class=\"btn btn-primary\"\n      [ngClass]=\"{ 'btn-pending': savingConfig }\"\n    >\n      <span title=\"{{ 'Send' | translate }}\" *ngIf=\"!savingConfig\">\n        {{ 'Send configuration to device' | translate }}\n      </span>\n      <span title=\"{{ 'Sending\u2026' | translate }}\" *ngIf=\"savingConfig\">\n        {{ 'Sending\u2026' | translate }}\n      </span>\n    </button>\n  </div>\n</div>\n"
                },] }
    ];
    TextBasedConfigurationComponent.ctorParameters = function () { return [
        { type: router.ActivatedRoute },
        { type: ngxComponents.AlertService },
        { type: RepositoryService },
        { type: DeviceConfigurationService },
        { type: client.InventoryService }
    ]; };

    var DeviceConfigurationComponent = /** @class */ (function () {
        function DeviceConfigurationComponent(route, deviceConfigurationService, realtime, repositoryService) {
            var _this = this;
            this.route = route;
            this.deviceConfigurationService = deviceConfigurationService;
            this.realtime = realtime;
            this.repositoryService = repositoryService;
            this.supportedConfigurations = [];
            this.showBinaryBasedConfig = false;
            this.configSnapshot = {};
            this.reloading = false;
            this.deviceConfigurationService.configurationsUpdated.subscribe(function (repositorySnapsOnly) {
                _this.updateSnapshots(repositorySnapsOnly);
            });
        }
        DeviceConfigurationComponent.prototype.ngOnInit = function () {
            this.device = this.route.snapshot.parent.data.contextData;
            if (this.device.c8y_SupportedConfigurations) {
                this.supportedConfigurations = this.device.c8y_SupportedConfigurations.map(function (item) { return ({
                    name: item
                }); });
            }
            if (this.deviceConfigurationService.hasAnySupportedOperation(this.device, [
                exports.DeviceConfigurationOperation.DOWNLOAD_CONFIG,
                exports.DeviceConfigurationOperation.UPLOAD_CONFIG
            ])) {
                this.supportedConfigurations.push({
                    name: ngxComponents.gettext('Legacy configuration snapshot'),
                    isLegacy: true
                });
            }
            if (this.supportedConfigurations.length > 0) {
                this.showBinaryBasedConfig = true;
            }
            this.repositorySnapshotsEmptyState = {
                icon: 'gears',
                title: ngxComponents.gettext('No configurations available.'),
                text: ngxComponents.gettext('Add configuration to configuration repository')
            };
            this.showTextBasedConfig =
                this.deviceConfigurationService.hasAnySupportedOperation(this.device, [
                    exports.DeviceConfigurationOperation.CONFIG,
                    exports.DeviceConfigurationOperation.SEND_CONFIG
                ]) || lodashEs.has(this.device, 'c8y_Configuration');
        };
        DeviceConfigurationComponent.prototype.onConfigTypeSelected = function (config) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    this.configurationType = config.name;
                    this.isLegacy = config.isLegacy;
                    this.updateSnapshots();
                    return [2 /*return*/];
                });
            });
        };
        DeviceConfigurationComponent.prototype.onRepositoryConfigSelected = function (config) {
            return __awaiter(this, void 0, void 0, function () {
                var binary, _a, ex_1;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            this.repositorySnapshot = {
                                id: config.id,
                                time: config.creationTime,
                                name: config.name,
                                binaryUrl: config.url,
                                deviceType: config.deviceType,
                                configurationType: config.configurationType
                            };
                            if (!config.url) return [3 /*break*/, 6];
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 5, , 6]);
                            return [4 /*yield*/, this.repositoryService.getBinaryFile(config.url, {
                                    allowExternal: false
                                })];
                        case 2:
                            binary = _b.sent();
                            if (!binary) return [3 /*break*/, 4];
                            _a = this.repositorySnapshot;
                            return [4 /*yield*/, binary.text()];
                        case 3:
                            _a.binary = _b.sent();
                            _b.label = 4;
                        case 4: return [3 /*break*/, 6];
                        case 5:
                            ex_1 = _b.sent();
                            return [3 /*break*/, 6];
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        DeviceConfigurationComponent.prototype.updateSnapshots = function (repositorySnapsOnly) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, _b, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            this.reloading = true;
                            this.repositorySnapshot = undefined;
                            _a = this;
                            return [4 /*yield*/, this.repositoryService.getSnapshotsFromRepository(this.device, this.configurationType)];
                        case 1:
                            _a.repositorySnapshots = _d.sent();
                            if (!!repositorySnapsOnly) return [3 /*break*/, 6];
                            _b = this;
                            if (!this.isLegacy) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.repositoryService.getLegacyConfigSnapshot(this.device)];
                        case 2:
                            _c = _d.sent();
                            return [3 /*break*/, 5];
                        case 3: return [4 /*yield*/, this.repositoryService.getConfigSnapshot(this.device, this.configurationType)];
                        case 4:
                            _c = _d.sent();
                            _d.label = 5;
                        case 5:
                            _b.configSnapshot = _c;
                            _d.label = 6;
                        case 6:
                            if (!this.showTextBasedConfig) return [3 /*break*/, 8];
                            return [4 /*yield*/, this.textBasedConfigurationComponent.load()];
                        case 7:
                            _d.sent();
                            _d.label = 8;
                        case 8:
                            this.reloading = false;
                            return [2 /*return*/];
                    }
                });
            });
        };
        return DeviceConfigurationComponent;
    }());
    DeviceConfigurationComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-device-configuration',
                    template: "<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\" title=\"{{ 'Reload' | translate }}\" (click)=\"updateSnapshots()\">\n    <i c8yIcon=\"refresh\" [ngClass]=\"{ 'icon-spin': reloading }\"></i>\n    {{ 'Reload' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<div class=\"card content-fullpage card-has-tabs\">\n  <tabset>\n    <div class=\"card-header separator\" *ngIf=\"showBinaryBasedConfig && !showTextBasedConfig\">\n      <h4 class=\"card-title\">{{ 'Configurations' | translate }}</h4>\n    </div>\n    <div class=\"card-header separator\" *ngIf=\"!showBinaryBasedConfig && showTextBasedConfig\">\n      <h4 class=\"card-title\">{{ 'Text-based configuration' | translate }}</h4>\n    </div>\n    <tab heading=\"{{ 'Configurations' | translate }}\" *ngIf=\"showBinaryBasedConfig\">\n      <div class=\"card--grid card grid__col--4-8--md grid__row--6-6--md m-b-0\">\n        <!-- DEVICE SUPPORTED CONFIGURATIONS -->\n        <div class=\"card--grid__inner-scroll bg-gray-white\">\n          <div class=\"p-l-16 p-r-16\">\n            <h5 class=\"legend form-block\">\n              <span translate>Device-supported configurations</span>\n            </h5>\n          </div>\n          <c8y-device-configuration-list\n            [items]=\"supportedConfigurations\"\n            [itemIcon]=\"'gears'\"\n            (configSelected)=\"onConfigTypeSelected($event)\"\n          ></c8y-device-configuration-list>\n        </div>\n\n        <!-- CONFIGURATION PREVIEW -->\n        <div class=\"card--grid__inner-scroll d-flex d-col flex-grow\">\n          <div class=\"card-block d-flex d-col flex-grow\">\n            <h5 class=\"legend form-block\"><span translate>Preview</span></h5>\n\n            <!-- EMPTY STATE -->\n            <div class=\"c8y-empty-state text-left\" *ngIf=\"!configurationType\">\n              <h1 [c8yIcon]=\"'file-text'\"></h1>\n              <p>\n                <strong translate>No configuration selected.</strong><br />\n                <small translate>Select a configuration to preview</small>\n              </p>\n            </div>\n\n            <!-- PREVIEW AVAILABLE STATE -->\n            <c8y-device-configuration-preview\n              *ngIf=\"configurationType\"\n              [device]=\"device\"\n              [configurationType]=\"configurationType\"\n              [configSnapshot]=\"configSnapshot\"\n              [canSaveSnapshot]=\"true\"\n              [operationToTrigger]=\"'c8y_UploadConfigFile'\"\n              [actionButtonText]=\"'Get snapshot from device' | translate\"\n              [actionButtonIcon]=\"'download'\"\n              [isLegacy]=\"isLegacy\"\n              class=\"d-flex d-col flex-grow\"\n            ></c8y-device-configuration-preview>\n          </div>\n        </div>\n\n        <!-- AVAILABLE SUPPORTED CONFIGURATIONS -->\n        <div class=\"card--grid__inner-scroll bg-gray-white\">\n          <div class=\"p-l-16 p-r-16\">\n            <h5 class=\"legend form-block\" translate>Available supported configurations</h5>\n          </div>\n\n          <!-- EMPTY STATE -->\n          <div class=\"c8y-empty-state text-left\" *ngIf=\"!configurationType\">\n            <h1 [c8yIcon]=\"'gears'\"></h1>\n            <p>\n              <strong translate>No selection</strong><br />\n              <small translate\n                >Select a configuration from the device-supported configuration list</small\n              >\n            </p>\n          </div>\n          <div class=\"p-r-16\" *ngIf=\"configurationType\">\n            <c8y-device-configuration-list\n              [items]=\"repositorySnapshots\"\n              [itemIcon]=\"'file-text'\"\n              [emptyState]=\"repositorySnapshotsEmptyState\"\n              [isFilterEnabled]=\"true\"\n              (configSelected)=\"onRepositoryConfigSelected($event)\"\n            ></c8y-device-configuration-list>\n          </div>\n        </div>\n\n        <!-- CONFIGURATION PREVIEW -->\n        <div class=\"card--grid__inner-scroll d-flex d-col flex-grow\">\n          <div class=\"card-block flex-grow d-flex d-col\">\n            <h5 class=\"legend form-block\" translate>Preview</h5>\n\n            <!-- EMPTY STATE -->\n\n            <div class=\"c8y-empty-state text-left\" *ngIf=\"!repositorySnapshot\">\n              <h1 [c8yIcon]=\"'file-text'\"></h1>\n              <p>\n                <strong translate>No configuration selected.</strong><br />\n                <small *ngIf=\"!configurationType; else noSnapshot\" translate\n                  >Select a configuration to preview</small\n                >\n                <ng-template #noSnapshot>\n                  <small translate>Select the configuration you want to preview</small>\n                </ng-template>\n              </p>\n            </div>\n\n            <!-- CONFIGURATION SELECTED STATE -->\n            <c8y-device-configuration-preview\n              *ngIf=\"repositorySnapshot\"\n              [device]=\"device\"\n              [configurationType]=\"configurationType\"\n              [configSnapshot]=\"repositorySnapshot\"\n              [operationToTrigger]=\"'c8y_DownloadConfigFile'\"\n              [actionButtonText]=\"'Send configuration to device' | translate\"\n              [actionButtonIcon]=\"'upload'\"\n              [isLegacy]=\"isLegacy\"\n              class=\"d-flex d-col flex-grow\"\n            ></c8y-device-configuration-preview>\n          </div>\n        </div>\n      </div>\n    </tab>\n    <tab heading=\"{{ 'Text-based configuration' | translate }}\" *ngIf=\"showTextBasedConfig\">\n      <c8y-text-based-configuration></c8y-text-based-configuration>\n    </tab>\n  </tabset>\n</div>\n"
                },] }
    ];
    DeviceConfigurationComponent.ctorParameters = function () { return [
        { type: router.ActivatedRoute },
        { type: DeviceConfigurationService },
        { type: client.Realtime },
        { type: RepositoryService }
    ]; };
    DeviceConfigurationComponent.propDecorators = {
        textBasedConfigurationComponent: [{ type: core.ViewChild, args: [TextBasedConfigurationComponent,] }]
    };

    var DeviceConfigurationGuard = /** @class */ (function () {
        function DeviceConfigurationGuard(deviceConfigurationService) {
            this.deviceConfigurationService = deviceConfigurationService;
        }
        DeviceConfigurationGuard.prototype.canActivate = function (route, state) {
            var contextData = route.data.contextData || route.parent.data.contextData;
            if (!contextData) {
                return false;
            }
            return ((contextData.c8y_SupportedConfigurations &&
                contextData.c8y_SupportedConfigurations.length > 0) ||
                this.deviceConfigurationService.hasAnySupportedOperation(contextData, [
                    exports.DeviceConfigurationOperation.DOWNLOAD_CONFIG,
                    exports.DeviceConfigurationOperation.UPLOAD_CONFIG,
                    exports.DeviceConfigurationOperation.CONFIG,
                    exports.DeviceConfigurationOperation.SEND_CONFIG
                ]) ||
                lodashEs.has(contextData, 'c8y_Configuration'));
        };
        return DeviceConfigurationGuard;
    }());
    DeviceConfigurationGuard.decorators = [
        { type: core.Injectable }
    ];
    DeviceConfigurationGuard.ctorParameters = function () { return [
        { type: DeviceConfigurationService }
    ]; };

    var SourceCodePreviewComponent = /** @class */ (function () {
        function SourceCodePreviewComponent() {
        }
        return SourceCodePreviewComponent;
    }());
    SourceCodePreviewComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-source-code-preview',
                    template: "<textarea\n  [disabled]=\"isDisabled\"\n  class=\"text-monospace form-control no-resize flex-grow\"\n  rows=\"4\"\n  >{{ text }}</textarea\n>\n"
                },] }
    ];
    SourceCodePreviewComponent.propDecorators = {
        isDisabled: [{ type: core.Input }],
        text: [{ type: core.Input }]
    };

    var ConfigurationDetailComponent = /** @class */ (function () {
        function ConfigurationDetailComponent(repositoryService, bsModalRef, alert) {
            var _this = this;
            this.repositoryService = repositoryService;
            this.bsModalRef = bsModalRef;
            this.alert = alert;
            this.binary = {
                file: undefined,
                url: undefined
            };
            this.pattern = '';
            this.mo = {};
            this.saving = false;
            this.uploadChoice = 'uploadBinary';
            this.textForConfigurationUrlPopover = ngxComponents.gettext("Path for binaries can vary depending on device agent implementation, e.g.:\n    /configuration/binaries/configuration1.bin\n    https://configuration/binary/123\n    ftp://configuration/binary/123.tar.gz\n  ");
            this.result = new Promise(function (resolve, reject) {
                _this._save = resolve;
                _this._cancel = reject;
            });
        }
        ConfigurationDetailComponent.prototype.ngOnInit = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _a = this;
                            return [4 /*yield*/, this.repositoryService.listRepositoryEntries(exports.RepositoryType.CONFIGURATION)];
                        case 1:
                            _a.configs = _b.sent();
                            if (this.selected) {
                                this.uploadChoice = this.binary.file ? 'uploadBinary' : 'uploadUrl';
                                this.existingBinary = this.binary.file;
                            }
                            this.setPipe('');
                            this.submitButtonTitle = this.mo.id
                                ? ngxComponents.gettext('Update configuration')
                                : ngxComponents.gettext('Add configuration');
                            return [2 /*return*/];
                    }
                });
            });
        };
        ConfigurationDetailComponent.prototype.cancel = function () {
            this.bsModalRef.hide();
            this._cancel();
        };
        ConfigurationDetailComponent.prototype.setPipe = function (filterStr) {
            this.pattern = filterStr;
            this.filterPipe = rxjs.pipe(operators.map(function (data) { return lodashEs.uniqBy(data, 'configurationType'); }), operators.map(function (data) {
                return data.filter(function (mo) { return mo.configurationType &&
                    mo.configurationType.toLowerCase().indexOf(filterStr.toLowerCase()) > -1; });
            }));
        };
        ConfigurationDetailComponent.prototype.onFile = function (dropped) {
            this.configurationForm.form.markAsDirty();
            if (!lodashEs.isUndefined(dropped.url)) {
                this.binary = {
                    url: dropped.url
                };
                return;
            }
            else if (!lodashEs.isUndefined(dropped.droppedFiles)) {
                this.binary = {
                    file: dropped.droppedFiles[0].file
                };
                return;
            }
            else {
                this.binary = {
                    file: undefined,
                    url: undefined
                };
            }
        };
        ConfigurationDetailComponent.prototype.save = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _a, selected, version, description, binary, deviceType, ex_1;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 2, 3, 4]);
                            this.saving = true;
                            _a = this, selected = _a.selected, version = _a.version, description = _a.description, binary = _a.binary, deviceType = _a.deviceType;
                            if (this.existingBinary === this.binary.file) {
                                binary.file = undefined;
                            }
                            return [4 /*yield*/, this.repositoryService.save({ selected: selected, version: version, description: description, binary: binary, deviceType: deviceType }, exports.RepositoryType.CONFIGURATION, this.mo)];
                        case 1:
                            _b.sent();
                            this.alert.success(this.mo.id ? ngxComponents.gettext('Configuration updated.') : ngxComponents.gettext('Configuration created.'));
                            this.bsModalRef.hide();
                            this._save();
                            return [3 /*break*/, 4];
                        case 2:
                            ex_1 = _b.sent();
                            this.alert.addServerFailure(ex_1);
                            this._cancel();
                            return [3 /*break*/, 4];
                        case 3:
                            this.saving = false;
                            return [7 /*endfinally*/];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        return ConfigurationDetailComponent;
    }());
    ConfigurationDetailComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-configuration-detail',
                    template: "<div class=\"viewport-modal\">\n  <div class=\"modal-header dialog-header\">\n    <i [c8yIcon]=\"'cogs'\"></i>\n    <h4 translate *ngIf=\"mo.id\">Update configuration</h4>\n    <h4 translate *ngIf=\"!mo.id\">Add configuration</h4>\n  </div>\n\n  <form\n    class=\"d-contents\"\n    #configurationForm=\"ngForm\"\n    (ngSubmit)=\"configurationForm.form.valid && save()\"\n  >\n    <div class=\"modal-inner-scroll\">\n      <div class=\"modal-body\">\n        <c8y-form-group>\n          <label translate>Name</label>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'e.g.' | translate }} hosts\"\n            autocomplete=\"off\"\n            required\n            maxlength=\"254\"\n            [(ngModel)]=\"version\"\n            name=\"version\"\n          />\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <label translate>Device type</label>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'e.g.' | translate }} c8y_Linux\"\n            maxlength=\"254\"\n            autocomplete=\"off\"\n            [(ngModel)]=\"deviceType\"\n            name=\"deviceType\"\n          />\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <label translate>Description</label>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'e.g. Host configuration' | translate }} c8y_Linux\"\n            maxlength=\"254\"\n            autocomplete=\"off\"\n            [(ngModel)]=\"description\"\n            name=\"description\"\n          />\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <label translate>Configuration type</label>\n          <c8y-typeahead\n            [(ngModel)]=\"selected\"\n            name=\"confType\"\n            placeholder=\"{{ 'e.g.' | translate }} ssh\"\n            maxlength=\"254\"\n            (onSearch)=\"setPipe($event)\"\n            displayProperty=\"configurationType\"\n          >\n            <c8y-li\n              *c8yFor=\"let config of configs; pipe: filterPipe; notFound: notFoundTemplate\"\n              class=\"p-l-8 p-r-8 c8y-list__item--link\"\n              (click)=\"selected = config; setPipe('')\"\n              [active]=\"selected === config\"\n            >\n              <c8y-highlight\n                [text]=\"config.configurationType || '--'\"\n                [pattern]=\"pattern\"\n              ></c8y-highlight>\n            </c8y-li>\n            <ng-template #notFoundTemplate>\n              <c8y-li class=\"bg-gray-lighter p-8\" *ngIf=\"pattern.length > 0\">\n                <span translate>No match found.</span>\n                <button\n                  title=\"{{ 'Add new`configuration type`' | translate }}\"\n                  type=\"button\"\n                  class=\"btn btn-primary btn-xs m-l-16\"\n                  translate\n                >\n                  Add new`configuration type`\n                </button>\n              </c8y-li>\n            </ng-template>\n          </c8y-typeahead>\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <div class=\"legend form-block m-t-40\" translate>Configuration file</div>\n          <c8y-file-picker\n            [maxAllowedFiles]=\"1\"\n            (onFilesPicked)=\"onFile($event)\"\n            [uploadChoice]=\"uploadChoice\"\n            [fileUrl]=\"binary.url\"\n            [fileBinary]=\"binary.file\"\n            [fileUrlPopover]=\"textForConfigurationUrlPopover\"\n          >\n          </c8y-file-picker>\n        </c8y-form-group>\n      </div>\n    </div>\n\n    <div class=\"modal-footer\">\n      <button\n        (click)=\"cancel()\"\n        type=\"button\"\n        class=\"btn btn-default\"\n        title=\"{{ 'Cancel' | translate }}\"\n        [disabled]=\"saving\"\n      >\n        <span translate>Cancel</span>\n      </button>\n      <button\n        class=\"btn btn-primary\"\n        type=\"submit\"\n        title=\"{{ submitButtonTitle | translate }}\"\n        [ngClass]=\"{ 'btn-pending': saving }\"\n        [disabled]=\"\n          !configurationForm.valid ||\n          configurationForm.pristine ||\n          (!binary?.url && !binary?.file) ||\n          saving\n        \"\n      >\n        {{ submitButtonTitle | translate }}\n      </button>\n    </div>\n  </form>\n</div>\n"
                },] }
    ];
    ConfigurationDetailComponent.ctorParameters = function () { return [
        { type: RepositoryService },
        { type: modal.BsModalRef },
        { type: ngxComponents.AlertService }
    ]; };
    ConfigurationDetailComponent.propDecorators = {
        configurationForm: [{ type: core.ViewChild, args: ['configurationForm', { static: true },] }]
    };

    var ConfigurationListComponent = /** @class */ (function () {
        function ConfigurationListComponent(alert, repositoryService, bsModalService, modalService, translateService, inventoryBinaryService, inventoryService) {
            this.alert = alert;
            this.repositoryService = repositoryService;
            this.bsModalService = bsModalService;
            this.modalService = modalService;
            this.translateService = translateService;
            this.inventoryBinaryService = inventoryBinaryService;
            this.inventoryService = inventoryService;
            this.filterTerm = '';
            this.reloading = false;
            this.DELETED_SUCCESS_MSG = ngxComponents.gettext('Configuration deleted.');
        }
        ConfigurationListComponent.prototype.ngOnInit = function () {
            this.loadConfigurations();
        };
        ConfigurationListComponent.prototype.loadConfigurations = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _a, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            this.reloading = true;
                            _a = this;
                            _b = rxjs.of;
                            return [4 /*yield*/, this.repositoryService.listRepositoryEntries(exports.RepositoryType.CONFIGURATION)];
                        case 1:
                            _a.configurations$ = _b.apply(void 0, [_c.sent()]);
                            this.reloading = false;
                            this.reset();
                            return [2 /*return*/];
                    }
                });
            });
        };
        ConfigurationListComponent.prototype.add = function () {
            return __awaiter(this, void 0, void 0, function () {
                var ex_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 3, , 4]);
                            return [4 /*yield*/, this.bsModalService.show(ConfigurationDetailComponent, {
                                    class: 'modal-sm',
                                    ignoreBackdropClick: true
                                }).content.result];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.loadConfigurations()];
                        case 2:
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            ex_1 = _a.sent();
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        ConfigurationListComponent.prototype.edit = function (configuration) {
            return __awaiter(this, void 0, void 0, function () {
                var fileBinary, modal, ex_2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.repositoryService.getBinaryFile(configuration.url, {
                                allowExternal: false
                            })];
                        case 1:
                            fileBinary = _a.sent();
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 5, , 6]);
                            modal = this.bsModalService.show(ConfigurationDetailComponent, {
                                class: 'modal-sm',
                                ignoreBackdropClick: true,
                                initialState: {
                                    selected: configuration,
                                    version: configuration.name,
                                    deviceType: configuration.deviceType,
                                    description: configuration.description,
                                    binary: { file: fileBinary, url: configuration.url }
                                }
                            }).content;
                            modal.mo = configuration;
                            return [4 /*yield*/, modal.result];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, this.loadConfigurations()];
                        case 4:
                            _a.sent();
                            return [3 /*break*/, 6];
                        case 5:
                            ex_2 = _a.sent();
                            return [3 /*break*/, 6];
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        ConfigurationListComponent.prototype.isBinaryFile = function (configuration) {
            return configuration.url ? !!this.inventoryBinaryService.getIdFromUrl(configuration.url) : false;
        };
        ConfigurationListComponent.prototype.getBinaryName = function (configuration) {
            return this.repositoryService.getBinaryName$(configuration.url);
        };
        ConfigurationListComponent.prototype.download = function (configuration) {
            return __awaiter(this, void 0, void 0, function () {
                var fileBinary;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.repositoryService.getBinaryFile(configuration.url, {
                                allowExternal: false
                            })];
                        case 1:
                            fileBinary = _a.sent();
                            fileSaver.saveAs(fileBinary);
                            return [2 /*return*/];
                    }
                });
            });
        };
        ConfigurationListComponent.prototype.delete = function (configuration) {
            return __awaiter(this, void 0, void 0, function () {
                var title, confirmationText, hint, proceed, body, labels, ex_3;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 4, , 5]);
                            title = ngxComponents.gettext('Delete configuration snapshot');
                            confirmationText = ngxComponents.gettext('You are about to delete the configuration snapshot {{ name }}.');
                            hint = ngxComponents.gettext('This operation is irreversible.');
                            proceed = ngxComponents.gettext('Do you want to proceed?');
                            body = [
                                this.translateService.instant(confirmationText, {
                                    name: configuration.name
                                }),
                                this.translateService.instant(hint),
                                this.translateService.instant(proceed)
                            ].join(' ');
                            labels = {
                                ok: ngxComponents.gettext('Delete')
                            };
                            return [4 /*yield*/, this.modalService.confirm(title, body, ngxComponents.Status.DANGER, labels)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.repositoryService.delete(configuration)];
                        case 2:
                            _a.sent();
                            this.alert.success(this.DELETED_SUCCESS_MSG);
                            return [4 /*yield*/, this.loadConfigurations()];
                        case 3:
                            _a.sent();
                            return [3 /*break*/, 5];
                        case 4:
                            ex_3 = _a.sent();
                            if (ex_3) {
                                this.alert.addServerFailure(ex_3);
                            }
                            return [3 /*break*/, 5];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        ConfigurationListComponent.prototype.setPipe = function (filterTerm) {
            var _this = this;
            this.filterTerm = filterTerm;
            this.filterPipe = rxjs.pipe(operators.map(function (data) {
                _this.data =
                    filterTerm.trim().length === 0
                        ? data
                        : data.filter(function (mo) { return _this.filterContainString(mo.name, filterTerm) ||
                            _this.filterContainString(mo.configurationType, filterTerm) ||
                            _this.filterContainString(mo.deviceType, filterTerm) ||
                            _this.filterContainString(mo.description, filterTerm); });
                return _this.data;
            }));
        };
        ConfigurationListComponent.prototype.shouldShowEmptyState = function () {
            return !(this.data && this.data.length > 0);
        };
        ConfigurationListComponent.prototype.reset = function () {
            this.filter.filterTerm = '';
            this.setPipe('');
        };
        ConfigurationListComponent.prototype.filterContainString = function (name, filterTerm) {
            var term = filterTerm.toLowerCase().trim();
            return name && name.toLowerCase().indexOf(term) > -1;
        };
        return ConfigurationListComponent;
    }());
    ConfigurationListComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-configuration-list',
                    template: "<c8y-title>\n  <span translate>\n    Configuration snapshots repository\n  </span>&nbsp;\n  <small\n    *ngIf=\"(configurations$ | async)?.paging.totalPages === 1 && !filterTerm\"\n  >\n    {{ (configurations$ | async).data.length }}\n    <span translate>\n      snapshots\n    </span>\n  </small>\n  <small\n    *ngIf=\"(configurations$ | async)?.paging.totalPages > 1 && !filterTerm\"\n    [tooltip]=\"'More data available. Scroll to the bottom of the list to load it.' | translate\"\n    container=\"body\"\n  >\n    {{ (configurations$ | async).paging.pageSize }}+\n    <span translate>snapshots</span>\n  </small>\n  <small *ngIf=\"filterTerm\">\n    <span translate>\n      Search results for\n    </span>&nbsp;\"\n      {{ this.filterTerm }}\"\n    </small>\n</c8y-title>\n\n<c8y-action-bar-item itemClass=\"navbar-form\">\n  <c8y-filter\n    [icon]=\"'search'\"\n    (onSearch)=\"setPipe($event)\"\n  ></c8y-filter>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\"\n    (click)=\"add()\"\n  >\n    <i c8yIcon=\"plus-circle\"></i>\n    {{ 'Add configuration snapshot' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\"\n    title=\"{{ 'Reload' | translate }}\"\n    (click)=\"loadConfigurations()\"\n  >\n    <i [ngClass]=\"{ 'icon-spin': reloading }\"\n      c8yIcon=\"refresh\"\n    ></i>\n    {{ 'Reload' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<!-- empty state -->\n<div class=\"c8y-empty-state text-center\"\n  *ngIf=\"!filterTerm && (configurations$ | async)?.data.length === 0\"\n>\n  <h1 c8yIcon=\"gears\"></h1>\n  <h3 translate>There are no configuration snapshots defined</h3>\n  <p translate>Add a configuration snapshot first.</p>\n  <div>\n    <button (click)=\"add()\" class=\"btn btn-primary\" translate>\n      Add configuration snapshot\n    </button>\n  </div>\n  <p c8y-guide-docs>\n    <small translate ngNonBindable>\n      Find out more in the\n      <a c8y-guide-href=\"users-guide/device-management/#configuration-repository\">\n        User guide`KEEP_ORIGINAL`\n        </a>.\n    </small>\n  </p>\n</div>\n\n<!-- no results empty state -->\n<div class=\"c8y-empty-state\"\n  *ngIf=\"shouldShowEmptyState() && (configurations$ | async)?.data.length > 0\"\n>\n  <h1 class=\"c8y-icon-duocolor\"\n    c8yIcon=\"search\"\n  ></h1>\n  <h3 translate>\n    No results to display.\n  </h3>\n  <p translate>\n    Refine your search terms or check your spelling.\n  </p>\n</div>\n\n<c8y-list-group class=\"m-b-24\"\n  *ngIf=\"(configurations$ | async)?.data.length > 0\"\n  [ngClass]=\"{ 'dd-low': data && data.length ? data.length < 10 : (configurations$ | async)?.data.length < 10 }\"\n\n>\n  <c8y-li class=\"page-sticky-header c8y-list__item--empty-actions hidden-xs\"\n    *ngIf=\"!shouldShowEmptyState()\"\n  >\n    <c8y-li-icon>\n      <i class=\"p-l-24\"></i>\n    </c8y-li-icon>\n    <c8y-li-body class=\"content-flex-60\">\n      <div class=\"col-2\">\n        {{ 'Configuration' | translate }}\n      </div>\n      <div class=\"col-3\">\n        {{ 'Description' | translate }}\n      </div>\n      <div class=\"col-3\">\n        {{ 'File' | translate }}\n      </div>\n      <div class=\"col-2\">\n        {{ 'Device type' | translate }}\n      </div>\n      <div class=\"col-2\">\n        {{ 'Configuration type' | translate }}\n      </div>\n    </c8y-li-body>\n  </c8y-li>\n\n  <c8y-li *c8yFor=\"let configuration of configurations$; pipe: filterPipe\">\n    <c8y-li-icon icon=\"gears\"></c8y-li-icon>\n    <div class=\"content-flex-60\">\n      <button class=\"btn-clean col-2\"\n        (click)=\"edit(configuration)\"\n      >\n        <span class=\"text-truncate\"\n          title=\"{{ configuration.name || '-' }}\"\n        >\n          <c8y-highlight\n            [text]=\"configuration.name || '-'\"\n            elementClass=\"text-info\"\n            [pattern]=\"filterTerm\"\n          ></c8y-highlight>\n        </span>\n      </button>\n      <div class=\"col-3\">\n        <div class=\"text-label-small visible-xs-inline m-r-4\">\n          {{ 'Description' | translate }}\n        </div>\n        <small class=\"text-truncate\"\n          *ngIf=\"configuration.description; else emptyDescription\"\n          title=\"configuration.description\"\n        >\n          <c8y-highlight\n            [text]=\"configuration.description || '-'\"\n            elementClass=\"text-info\"\n            [pattern]=\"filterTerm\">\n          </c8y-highlight>\n        </small>\n      </div>\n      <div class=\"col-3\">\n        <span class=\"text-truncate\">\n          <span class=\"text-label-small m-r-4 visible-xs-inline\" translate>\n            File\n          </span>\n          <small\n            *ngIf=\"isBinaryFile(configuration); else noFile\"\n            title=\"{{ getBinaryName(configuration) | async }}\"\n          >\n            {{ getBinaryName(configuration) | async }}\n          </small>\n          <ng-template #noFile>\n            <small title=\"{{ configuration.url }}\">\n              {{ configuration.url }}\n            </small>\n          </ng-template>\n        </span>\n      </div>\n      <div class=\"col-2\">\n        <div class=\"text-truncate\"\n          title=\"{{ 'Device type' | translate }}: {{ configuration.deviceType || '-' }}\"\n        >\n          <span class=\"text-label-small visible-xs-inline m-r-4\" translate>\n            Device type\n          </span>\n          <span *ngIf=\"configuration.deviceType; else emptyText\">\n            <c8y-highlight\n              [text]=\"configuration.deviceType || '-'\"\n              elementClass=\"text-info\"\n              [pattern]=\"filterTerm\"\n            >\n            </c8y-highlight>\n          </span>\n        </div>\n      </div>\n      <div class=\"col-2\">\n        <div class=\"text-truncate\"\n          title=\"{{ configuration.configurationType }}\"\n        >\n          <span class=\"label label-primary\"\n            *ngIf=\"configuration.configurationType; else emptyText\"\n          >\n            <c8y-highlight\n              [text]=\"configuration.configurationType\"\n              elementClass=\"text-info\"\n              [pattern]=\"filterTerm\"\n            >\n            </c8y-highlight>\n          </span>\n        </div>\n      </div>\n    </div>\n    <c8y-li-action\n      (click)=\"edit(configuration)\"\n      icon=\"pencil\"\n      label=\"{{ 'Edit' | translate }}\"\n    >\n    </c8y-li-action>\n    <c8y-li-action\n      (click)=\"delete(configuration)\"\n      icon=\"trash-o\"\n      label=\"{{ 'Delete' | translate }}\"\n    >\n    </c8y-li-action>\n    <c8y-li-action\n      *ngIf=\"isBinaryFile(configuration)\"\n      (click)=\"download(configuration)\"\n      icon=\"download\"\n      label=\"{{ 'Download' | translate }}\"\n    >\n    </c8y-li-action>\n    <ng-template #emptyText>\n      <small class=\"text-muted\">\n        <em>{{ 'Undefined' | translate }}</em>\n      </small>\n    </ng-template>\n    <ng-template #emptyDescription>\n      <small class=\"text-muted\">\n        <em>{{ 'No description' | translate }}</em>\n      </small>\n    </ng-template>\n  </c8y-li>\n</c8y-list-group>\n"
                },] }
    ];
    ConfigurationListComponent.ctorParameters = function () { return [
        { type: ngxComponents.AlertService },
        { type: RepositoryService },
        { type: modal.BsModalService },
        { type: ngxComponents.ModalService },
        { type: core$1.TranslateService },
        { type: client.InventoryBinaryService },
        { type: client.InventoryService }
    ]; };
    ConfigurationListComponent.propDecorators = {
        filter: [{ type: core.ViewChild, args: [ngxComponents.FilterInputComponent, { static: false },] }]
    };
    __decorate([
        ngxComponents.memoize(lodashEs.property('id'))
    ], ConfigurationListComponent.prototype, "getBinaryName", null);

    var LinkRenderType;
    (function (LinkRenderType) {
        LinkRenderType[LinkRenderType["DOWNLOAD"] = 0] = "DOWNLOAD";
        LinkRenderType[LinkRenderType["LINK"] = 1] = "LINK";
        LinkRenderType[LinkRenderType["TEXTONLY"] = 2] = "TEXTONLY";
    })(LinkRenderType || (LinkRenderType = {}));

    var FileDownloadComponent = /** @class */ (function () {
        function FileDownloadComponent(repositoryService, inventoryBinaryService, alertService) {
            this.repositoryService = repositoryService;
            this.inventoryBinaryService = inventoryBinaryService;
            this.alertService = alertService;
            this.linkRenderType = LinkRenderType;
            this.isDownloading = false;
        }
        FileDownloadComponent.prototype.getBinaryName$ = function (binaryUrl) {
            return this.repositoryService.getBinaryName$(binaryUrl);
        };
        FileDownloadComponent.prototype.determineBehavior = function () {
            var result;
            if (this.inventoryBinaryService.getIdFromUrl(this.url)) {
                result = LinkRenderType.DOWNLOAD;
            }
            else if (this.url.match(/\/\//g)) {
                result = LinkRenderType.LINK;
            }
            else {
                result = LinkRenderType.TEXTONLY;
            }
            return result;
        };
        FileDownloadComponent.prototype.downloadFile = function () {
            return __awaiter(this, void 0, void 0, function () {
                var binary, ex_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            this.isDownloading = true;
                            return [4 /*yield*/, this.repositoryService.getBinaryFile(this.url, {
                                    allowExternal: false
                                })];
                        case 1:
                            binary = _a.sent();
                            this.isDownloading = false;
                            fileSaver.saveAs(binary);
                            return [3 /*break*/, 3];
                        case 2:
                            ex_1 = _a.sent();
                            this.isDownloading = false;
                            if (ex_1) {
                                this.alertService.addServerFailure(ex_1);
                            }
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        return FileDownloadComponent;
    }());
    FileDownloadComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-file-download',
                    template: "<a\n  *ngIf=\"determineBehavior() === linkRenderType.LINK\"\n  href=\"{{ url }}\"\n  class=\"pointer\"\n  target=\"_blank\"\n  rel=\"noopener noreferrer\"\n>\n  {{ getBinaryName$(url) | async }}\n</a>\n\n<span *ngIf=\"determineBehavior() === linkRenderType.TEXTONLY\">{{\n  getBinaryName$(url) | async\n}}</span>\n\n<span *ngIf=\"determineBehavior() === linkRenderType.DOWNLOAD\">\n  <a *ngIf=\"!isDownloading\" class=\"pointer\" (click)=\"downloadFile()\">\n    {{ getBinaryName$(url) | async }}\n  </a>\n\n  <span *ngIf=\"isDownloading\">\n    <i c8yIcon=\"spinner\" class=\"icon-spin\"></i> {{ 'Downloading\u2026' | translate }}\n  </span>\n</span>\n"
                },] }
    ];
    FileDownloadComponent.ctorParameters = function () { return [
        { type: RepositoryService },
        { type: client.InventoryBinaryService },
        { type: ngxComponents.AlertService }
    ]; };
    FileDownloadComponent.propDecorators = {
        url: [{ type: core.Input }]
    };
    __decorate([
        ngxComponents.memoize()
    ], FileDownloadComponent.prototype, "getBinaryName$", null);
    __decorate([
        ngxComponents.memoize()
    ], FileDownloadComponent.prototype, "determineBehavior", null);

    // MODAL STRUCTURE
    // - selectModalObject (repository entry (repositoryCategory) -> type c8y_Firmware/c8y_Software)
    //   -- ISelectModalOption (repository binary entry (repositoryBinary) => type c8y_FirmwareBinary/c8y_SoftwareBinary)
    //   -- ISelectModalOption...
    // - selectModalObject...
    /**
     * RepositorySelectModalComponent displays repository entries options and allows to select them.
     *
     * @example
     * ```
     * import { take } from 'rxjs/operators';
     * import { RepositorySelectModalComponent, ModalSelectionMode, RepositoryType } from '@c8y/ngx-components/repository';
     *
     * const initialState = {
     *   repositoryType: RepositoryType.FIRMWARE,
     *   title: gettext('Install firmware'),
     *   subTitle: gettext('Available firmwares matching the device type'),
     *   icon: 'c8y-firmware',
     *   mode: ModalSelectionMode.SINGLE,
     *   labels: { ok: gettext('Install') },
     *   disableSelected: false
     * };
     *
     * const modal = this.bsModal.show(RepositorySelectModalComponent, {
     *   ignoreBackdropClick: true,
     *   initialState
     * });
     *
     * modal.content.load.next();
     * modal.content.resultEmitter.pipe(take(1)).subscribe((firmware) => {
     *   ...
     * })
     * ```
     */
    var RepositorySelectModalComponent = /** @class */ (function () {
        function RepositorySelectModalComponent(repositoryService, translateService) {
            var _this = this;
            this.repositoryService = repositoryService;
            this.translateService = translateService;
            /**
             * Optional
             * Allows to provide custom data.
             * @example
             * ```
             * import { from } from 'rxjs';
             *
             * const repositoryEntry = { name: 'ExampleEntry', type: 'c8y_Firmware' };
             * const versions = [{ c8y_Firmware: { version: '1.0.0', url: 'http://example.com' } }];
             *
             * const initialState = {repositoryEntriesWithVersions$: from({ ...repositoryEntry, versions })};
             * ```
             */
            this.repositoryEntriesWithVersions$ = undefined;
            /**
             * Optional
             * Allows to use custom badges templates.
             * @example
             * ```
             * import { gettext } from '@c8y/ngx-components';
             *
             * const badgeTemplates = { '=1': gettext('{{count}} version'), other: gettext('{{count}} versions') };
             * const initialState = { badgeTemplates };
             * ```
             */
            this.badgeTemplates = { '=1': ngxComponents.gettext('{{count}} version'), other: ngxComponents.gettext('{{count}} versions') };
            /**
             * Optional
             * Allows to provide custom modal title.
             */
            this.title = ngxComponents.gettext('Select repository entry');
            /**
             * Loads the content of the modal.
             * Must be invoked by the modal's caller.
             */
            this.load = new rxjs.Subject();
            /**
             * Optional
             * Emits a search string currently entered in the filter input.
             * Use it to filter the items if you use custom repositoryEntriesWithVersions$.
             */
            this.searchTerm = new rxjs.BehaviorSubject('');
            /**
             * Optional
             * Allows to provide device type query to restrict search criteria.
             * Only takes effect when repositoryEntriesWithVersions$ is not provided,
             * otherwise modal's caller have to provide already filtered data in the repositoryEntriesWithVersions$.
             */
            this.deviceTypeQuery = {};
            /**
             * Optional
             * Allows to provide query to restrict search criteria.
             * Only takes effect when repositoryEntriesWithVersions$ is not provided,
             * otherwise modal's caller have to provide already filtered data in the repositoryEntriesWithVersions$.
             */
            this.searchQuery = {};
            /**
             * Optional
             * Allows to provide custom labels for the buttons responsible for confirm/dismiss modal actions.
             */
            this.labels = { ok: ngxComponents.gettext('Save') };
            /**
             * Optional
             * Allows to hide the filter input field.
             * By default, the filter input field is displayed.
             */
            this.showFilter = true;
            /**
             * Optional
             * Allows to show a warning that the search criteria should be narrowed down.
             * By default, this warning is hidden.
             */
            this.areMoreEntries = false;
            /**
             * Emits the list of selected options.
             */
            this.resultEmitter = new core.EventEmitter();
            /**
             * Optional
             * Allows to change selection mode.
             * Supported options:
             *   * single: only single option can be selected.
             *   * multiple: multiple options can be selected.
             */
            this.mode = ngxComponents.ModalSelectionMode.SINGLE;
            /**
             * Allows to block selection of the other versions from the same repository entry.
             */
            this.disableSelected = true;
            this.modalEntries = this.load.pipe(operators.switchMap(function () { return _this.repositoryEntriesWithVersions$; }), operators.mergeMap(function (mos) { return _this.aggregate(mos); }), operators.tap(function (items) {
                _this.areMoreEntries = items.length >= _this.PAGE_SIZE ? true : false;
            }));
            this.PAGE_SIZE = 100;
            this.queriesUtil = new client.QueriesUtil();
        }
        RepositorySelectModalComponent.prototype.ngOnInit = function () {
            var _this = this;
            if (!this.repositoryType) {
                throw new Error('Repository type must be defined');
            }
            if (!this.repositoryEntriesWithVersions$) {
                this.repositoryEntriesWithVersions$ = rxjs.from(this.repositoryService.listRepositoryEntries(this.repositoryType, {
                    query: this.queriesUtil.addOrFilter(this.deviceTypeQuery, this.searchQuery),
                    params: { pageSize: this.PAGE_SIZE }
                })).pipe(operators.map(function (_a) {
                    var data = _a.data;
                    return data;
                }), operators.map(function (mos) { return _this.getAndAssignRepositoryBinaries(mos); }), operators.shareReplay(1));
            }
        };
        RepositorySelectModalComponent.prototype.getAndAssignRepositoryBinaries = function (mos) {
            var _this = this;
            mos.forEach(function (mo) {
                mo.versions = _this.repositoryService.listAllVersions(mo);
            });
            return mos;
        };
        RepositorySelectModalComponent.prototype.search = function (searchTerm) {
            this.searchTerm.next(searchTerm);
            if (!searchTerm) {
                this.searchQuery = {};
            }
            else {
                this.searchQuery = { name: "*" + searchTerm + "*" };
            }
            this.load.next();
        };
        RepositorySelectModalComponent.prototype.result = function (selectedItems) {
            this.resultEmitter.emit(selectedItems);
        };
        RepositorySelectModalComponent.prototype.aggregate = function (mos) {
            return __awaiter(this, void 0, void 0, function () {
                var repositoryType, selectedItems;
                var _this = this;
                return __generator(this, function (_a) {
                    repositoryType = this.repositoryType;
                    selectedItems = this.selected;
                    return [2 /*return*/, Promise.all(mos.map(function (repositoryEntry) { return __awaiter(_this, void 0, void 0, function () {
                            var options, _a, selectModalObject;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _a = this.getSelectModalOptions;
                                        return [4 /*yield*/, this.repositoryService.fetchAllItemsFromList(repositoryEntry.versions)];
                                    case 1:
                                        options = _a.apply(this, [_b.sent(), selectedItems, repositoryEntry, repositoryType]);
                                        selectModalObject = this.getSelectModalObject(repositoryEntry, options);
                                        return [2 /*return*/, selectModalObject];
                                }
                            });
                        }); }))];
                });
            });
        };
        RepositorySelectModalComponent.prototype.getSelectModalOptions = function (versions, selectedItems, repositoryEntry, repositoryType) {
            var _this = this;
            var selectModalOptions = [];
            versions.forEach(function (repositoryBinary) {
                var isSelected = _this.isBinaryRepositorySelected(selectedItems, repositoryEntry, repositoryBinary, repositoryType);
                var version = repositoryBinary["" + repositoryType].version;
                var bodyValue = version || "(" + _this.translateService.instant(ngxComponents.gettext('not specified`version`')) + ")";
                var bodyClass = version ? '' : 'text-muted';
                selectModalOptions.push({
                    body: [
                        {
                            value: bodyValue,
                            class: bodyClass
                        }
                    ],
                    obj: Object.assign(Object.assign(Object.assign({ id: repositoryBinary.id, name: repositoryEntry.name, version: version }, (lodashEs.get(repositoryBinary, 'c8y_Patch.dependency') && {
                        dependency: lodashEs.get(repositoryBinary, 'c8y_Patch.dependency')
                    })), (lodashEs.get(repositoryBinary, 'c8y_Patch') && { isPatch: true })), { url: repositoryBinary["" + repositoryType].url }),
                    selected: isSelected
                });
            });
            return selectModalOptions;
        };
        RepositorySelectModalComponent.prototype.isBinaryRepositorySelected = function (selectedItems, repositoryEntry, repositoryBinary, repositoryType) {
            var isSelected = selectedItems
                ? selectedItems.filter(function (repositoryFragment) { return repositoryFragment.name === repositoryEntry.name &&
                    repositoryFragment.version === repositoryBinary["" + repositoryType].version; }).length > 0
                : false;
            return isSelected;
        };
        RepositorySelectModalComponent.prototype.getSelectModalObject = function (repositoryEntry, options) {
            var label = options.length === 1
                ? this.translateService.instant(this.badgeTemplates['=1'], { count: options.length })
                : this.translateService.instant(this.badgeTemplates.other, { count: options.length });
            var selectModalObject = {
                groupId: repositoryEntry.id,
                body: [
                    { value: repositoryEntry.name, class: 'text-truncate' },
                    { value: repositoryEntry.description, class: 'text-truncate text-muted' }
                ],
                additionalInformation: { value: label, class: 'label label-info' },
                options: options
            };
            return selectModalObject;
        };
        return RepositorySelectModalComponent;
    }());
    RepositorySelectModalComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-repository-select-modal',
                    template: "<c8y-select-modal\n  [icon]=\"icon\"\n  [title]=\"title\"\n  [subTitle]=\"subTitle\"\n  [items]=\"modalEntries | async\"\n  [mode]=\"mode\"\n  [disableSelected]=\"disableSelected\"\n  [labels]=\"labels\"\n  [showFilter]=\"showFilter\"\n  [areMoreEntries]=\"areMoreEntries\"\n  (search)=\"search($event)\"\n  (result)=\"result($event)\"\n>\n</c8y-select-modal>\n"
                },] }
    ];
    RepositorySelectModalComponent.ctorParameters = function () { return [
        { type: RepositoryService },
        { type: core$1.TranslateService }
    ]; };

    var FirmwareDeviceTabComponent = /** @class */ (function () {
        function FirmwareDeviceTabComponent(route, repository, inventory, bsModal) {
            var _this = this;
            this.route = route;
            this.repository = repository;
            this.inventory = inventory;
            this.bsModal = bsModal;
            this.isEmpty = lodashEs.isEmpty;
            this.reloading = false;
            this.device$ = new rxjs.BehaviorSubject(this.route.parent.snapshot.data.contextData);
            this.deviceFirmwareFragment$ = this.device$.pipe(operators.map(function (device) { return device.c8y_Firmware; }));
            this.firmwareBinary$ = this.deviceFirmwareFragment$.pipe(operators.filter(function (deviceFirmwareFragment) { return !lodashEs.isEmpty(deviceFirmwareFragment); }), operators.switchMap(function (deviceFirmwareFragment) { return rxjs.from(_this.repository.getRepositoryBinaryMoByVersion(deviceFirmwareFragment, exports.RepositoryType.FIRMWARE)); }), operators.shareReplay(1));
            this.repositoryEntry$ = this.firmwareBinary$.pipe(operators.switchMap(function (mo) { return _this.repository.getRepositoryEntryMO$(mo); }), operators.shareReplay(1));
            this.patches$ = rxjs.combineLatest(this.firmwareBinary$, this.repositoryEntry$).pipe(operators.switchMap(function (_a) {
                var _b = __read(_a, 2), firmwareBinary = _b[0], repositoryEntry = _b[1];
                if (repositoryEntry && firmwareBinary) {
                    var version = _this.repository.getBaseVersionFromMO(firmwareBinary);
                    return rxjs.from(_this.repository.listPatchVersions(repositoryEntry, version)).pipe(operators.map(function (_a) {
                        var data = _a.data;
                        return data;
                    }));
                }
                else {
                    return rxjs.of([]);
                }
            }), operators.shareReplay(1));
            this.supportsFirmwareOperations$ = this.device$.pipe(operators.map(function (device) { return lodashEs.get(device, 'c8y_SupportedOperations', []).indexOf('c8y_Firmware') > -1; }));
            this.changesOperation$ = new rxjs.BehaviorSubject(null);
            this.changesInProgress$ = this.changesOperation$.pipe(operators.map(function (operation) { return _this.isInProgress(operation); }));
        }
        FirmwareDeviceTabComponent.prototype.ngOnInit = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: 
                        // TODO check route snapshot, why is not refreshing device.
                        // Scenario: missing deviceFirmwareFragment => install new version => switch tabs.
                        // Expected: device should be set.
                        return [4 /*yield*/, this.loadDevice()];
                        case 1:
                            // TODO check route snapshot, why is not refreshing device.
                            // Scenario: missing deviceFirmwareFragment => install new version => switch tabs.
                            // Expected: device should be set.
                            _a.sent();
                            return [4 /*yield*/, this.loadOperation()];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        FirmwareDeviceTabComponent.prototype.installFirmware = function () {
            var _this = this;
            var initialState = {
                repositoryEntriesWithVersions$: rxjs.of([]),
                repositoryEntriesWithVersionsFn$: function (modal) { return _this.getRepositoryEntriesWithVersions$(modal.content.searchTerm); },
                repositoryType: exports.RepositoryType.FIRMWARE,
                title: ngxComponents.gettext('Install firmware'),
                subTitle: ngxComponents.gettext('Available firmwares matching the device type'),
                icon: 'c8y-firmware',
                mode: ngxComponents.ModalSelectionMode.SINGLE,
                labels: { ok: ngxComponents.gettext('Install') },
                disableSelected: false
            };
            this.deviceFirmwareFragment$
                .pipe(operators.take(1), operators.switchMap(function (deviceFirmwareFragment) {
                if (deviceFirmwareFragment) {
                    var name = deviceFirmwareFragment.name, version = deviceFirmwareFragment.version;
                    var selected = [{ name: name, version: version }];
                    lodashEs.assign(initialState, { selected: selected });
                }
                var modal = _this.bsModal.show(RepositorySelectModalComponent, {
                    ignoreBackdropClick: true,
                    initialState: initialState
                });
                if (initialState.repositoryEntriesWithVersionsFn$) {
                    modal.content.repositoryEntriesWithVersions$ = initialState.repositoryEntriesWithVersionsFn$(modal);
                }
                modal.content.load.next();
                return modal.content.resultEmitter;
            }))
                .subscribe(function (_a) {
                var _b = __read(_a, 1), selectedFirmware = _b[0];
                _this.handleOperation(selectedFirmware);
            });
        };
        FirmwareDeviceTabComponent.prototype.getRepositoryEntriesWithVersions$ = function (searchTerm$) {
            var _this = this;
            return searchTerm$.pipe(operators.distinctUntilChanged(), operators.switchMap(function (searchTerm) { return _this.repository.listRepositoryEntries(exports.RepositoryType.FIRMWARE, {
                query: _this.repository.getDeviceTypeQuery(exports.RepositoryType.FIRMWARE, _this.device$.value),
                partialName: searchTerm,
                params: { pageSize: 100 }
            }); }), operators.map(function (_a) {
                var data = _a.data;
                return data;
            }), operators.map(function (mos) { return _this.getAndAssignRepositoryBinaries(mos); }), operators.shareReplay(1));
        };
        FirmwareDeviceTabComponent.prototype.getAndAssignRepositoryBinaries = function (mos) {
            var _this = this;
            mos.forEach(function (mo) {
                mo.versions = _this.repository.listBaseVersions(mo);
            });
            return mos;
        };
        FirmwareDeviceTabComponent.prototype.addPatch = function () {
            var _this = this;
            var initialState = {
                repositoryType: exports.RepositoryType.FIRMWARE,
                repositoryEntriesWithVersions$: this.getRepositoryEntryWithPatches$(),
                title: ngxComponents.gettext('Install firmware'),
                subTitle: ngxComponents.gettext('Available firmwares matching the device type'),
                icon: 'c8y-firmware',
                mode: ngxComponents.ModalSelectionMode.SINGLE,
                labels: { ok: ngxComponents.gettext('Install') },
                disableSelected: false
            };
            this.deviceFirmwareFragment$
                .pipe(operators.take(1), operators.switchMap(function (deviceFirmwareFragment) {
                if (deviceFirmwareFragment) {
                    var name = deviceFirmwareFragment.name, version = deviceFirmwareFragment.version;
                    var selected = [{ name: name, version: version }];
                    lodashEs.assign(initialState, { selected: selected });
                }
                var modal = _this.bsModal.show(RepositorySelectModalComponent, {
                    ignoreBackdropClick: true,
                    initialState: initialState
                });
                modal.content.load.next();
                return modal.content.resultEmitter;
            }))
                .subscribe(function (_a) {
                var _b = __read(_a, 1), selectedOption = _b[0];
                _this.handleOperation(selectedOption);
            });
        };
        FirmwareDeviceTabComponent.prototype.getRepositoryEntryWithPatches$ = function () {
            return rxjs.combineLatest(this.repositoryEntry$, this.patches$).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), repositoryEntry = _b[0], patches = _b[1];
                return [Object.assign(Object.assign({}, repositoryEntry), { versions: patches })];
            }));
        };
        FirmwareDeviceTabComponent.prototype.loadDevice = function () {
            return __awaiter(this, void 0, void 0, function () {
                var deviceId, device;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.reloading = true;
                            deviceId = this.device$.value.id;
                            return [4 /*yield*/, this.inventory.detail(deviceId, { withChildren: false })];
                        case 1:
                            device = (_a.sent()).data;
                            this.device$.next(device);
                            this.reloading = false;
                            return [2 /*return*/];
                    }
                });
            });
        };
        FirmwareDeviceTabComponent.prototype.handleOperation = function (selectedFirmware) {
            return __awaiter(this, void 0, void 0, function () {
                var operation;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.repository.createFirmwareUpdateOperation(this.device$.value, selectedFirmware)];
                        case 1:
                            operation = _a.sent();
                            this.trackOperation(operation);
                            return [2 /*return*/];
                    }
                });
            });
        };
        FirmwareDeviceTabComponent.prototype.loadOperation = function () {
            return __awaiter(this, void 0, void 0, function () {
                var deviceId, operation;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            deviceId = this.device$.value.id;
                            return [4 /*yield*/, this.repository.getLastFirmwareUpdateOperation(deviceId)];
                        case 1:
                            operation = _a.sent();
                            this.trackOperation(operation);
                            return [2 /*return*/];
                    }
                });
            });
        };
        FirmwareDeviceTabComponent.prototype.trackOperation = function (operation) {
            var _this = this;
            this.changesOperation$.next(operation);
            if (this.isInProgress(operation)) {
                this.repository.observeOperation(operation).subscribe(function (operationUpdate) {
                    _this.changesOperation$.next(operationUpdate);
                    if (operationUpdate.status === client.OperationStatus.SUCCESSFUL) {
                        _this.loadDevice();
                    }
                }, function (operationUpdate) {
                    _this.changesOperation$.next(operationUpdate);
                });
            }
        };
        FirmwareDeviceTabComponent.prototype.isInProgress = function (operation) {
            return (operation && [client.OperationStatus.PENDING, client.OperationStatus.EXECUTING].includes(operation.status));
        };
        return FirmwareDeviceTabComponent;
    }());
    FirmwareDeviceTabComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-firmware-device-tab',
                    template: "<div class=\"row\">\n  <div class=\"col-lg-12 col-lg-max\">\n    <div class=\"card\">\n      <div class=\"card-header separator\">\n        <h4 class=\"card-title\" translate>Current firmware</h4>\n      </div>\n      <div class=\"inner-scroll\">\n        <fieldset *ngIf=\"changesOperation$ | async\" class=\"card-block bg-gray-white\">\n          <c8y-single-operation [operation]=\"changesOperation$ | async\"></c8y-single-operation>\n        </fieldset>\n        <div class=\"card-block p-t-0 p-b-0\">\n          <!-- EMPTY STATE -->\n          <ng-container *ngIf=\"isEmpty(deviceFirmwareFragment$ | async); else firmwareBlock\">\n            <div class=\"c8y-empty-state text-center\">\n              <h1 c8yIcon=\"c8y-firmware\" class=\"c8y-icon-duocolor\"></h1>\n              <p>\n                <strong translate>No firmware installed.</strong> <br />\n                <small translate>Click below to install firmware into this device.</small>\n              </p>\n            </div>\n          </ng-container>\n\n          <!-- FIRMWARE -->\n          <ng-template #firmwareBlock>\n            <c8y-list-group class=\"no-border-last\">\n              <c8y-li>\n                <c8y-li-icon>\n                  <i c8yIcon=\"c8y-firmware\"></i>\n                </c8y-li-icon>\n\n                <c8y-li-body *ngIf=\"deviceFirmwareFragment$ | async as deviceFirmwareFragment\">\n                  <!-- Firmware title -->\n                  <p class=\"m-b-16 text-medium\">\n                    {{ deviceFirmwareFragment.name }}\n                  </p>\n                  <!-- Firmware description -->\n                  <div *ngIf=\"repositoryEntry$ | async as repositoryEntry\">\n                    <p class=\"text-label-small\" translate>Description</p>\n                    <p>\n                      {{ repositoryEntry.description }}\n                    </p>\n                  </div>\n\n                  <!-- BASE/PATCH VERSION -->\n                  <div class=\"m-b-16\">\n                    <p class=\"text-label-small\" translate>Version</p>\n                    <p *ngIf=\"deviceFirmwareFragment.version; else versionNotSpecified\">\n                      {{ deviceFirmwareFragment.version }}\n                    </p>\n                    <ng-template #versionNotSpecified>\n                      <p>\n                        <em class=\"text-muted\"> ({{ 'not specified`version`' | translate }}) </em>\n                      </p>\n                    </ng-template>\n                  </div>\n\n                  <!-- ADD PATCH -->\n                  <button\n                    *ngIf=\"\n                      (supportsFirmwareOperations$ | async) && (this.patches$ | async)?.length > 0\n                    \"\n                    (click)=\"addPatch()\"\n                    class=\"btn btn-xs btn-primary\"\n                    [disabled]=\"changesInProgress$ | async\"\n                    title=\"{{ 'Patches available' | translate }}\"\n                  >\n                    {{ 'Patches available' | translate }}\n                  </button>\n                </c8y-li-body>\n              </c8y-li>\n            </c8y-list-group>\n          </ng-template>\n        </div>\n      </div>\n      <div *ngIf=\"supportsFirmwareOperations$ | async\" class=\"card-footer separator-top\">\n        <!-- INSTALL FIRMWARE -->\n        <button\n          *ngIf=\"isEmpty(deviceFirmwareFragment$ | async)\"\n          class=\"btn btn-primary\"\n          (click)=\"installFirmware()\"\n          title=\"{{ 'Install firmware' | translate }}\"\n        >\n          {{ 'Install firmware' | translate }}\n        </button>\n\n        <!-- REPLACE FIRMWARE -->\n        <button\n          *ngIf=\"!isEmpty(deviceFirmwareFragment$ | async)\"\n          class=\"btn btn-primary\"\n          (click)=\"installFirmware()\"\n          [disabled]=\"changesInProgress$ | async\"\n          title=\"{{ 'Replace firmware' | translate }}\"\n        >\n          {{ 'Replace firmware' | translate }}\n        </button>\n      </div>\n    </div>\n  </div>\n</div>\n"
                },] }
    ];
    FirmwareDeviceTabComponent.ctorParameters = function () { return [
        { type: router.ActivatedRoute },
        { type: RepositoryService },
        { type: client.InventoryService },
        { type: modal.BsModalService }
    ]; };

    var FIRMWARE_FRAGMENT = 'c8y_Firmware';
    var SUPPORTED_OPERATIONS_FRAGMENT = 'c8y_SupportedOperations';
    var FirmwareDeviceTabGuard = /** @class */ (function () {
        function FirmwareDeviceTabGuard() {
        }
        FirmwareDeviceTabGuard.prototype.canActivate = function (route) {
            var contextData = lodashEs.get(route, 'data.contextData') || lodashEs.get(route, 'parent.data.contextData');
            var supportedOperations = lodashEs.get(contextData, SUPPORTED_OPERATIONS_FRAGMENT);
            return ((!!supportedOperations ? lodashEs.indexOf(supportedOperations, FIRMWARE_FRAGMENT) >= 0 : false) ||
                lodashEs.has(contextData, 'c8y_Firmware'));
        };
        return FirmwareDeviceTabGuard;
    }());
    FirmwareDeviceTabGuard.decorators = [
        { type: core.Injectable }
    ];

    var AddFirmwareModalComponent = /** @class */ (function () {
        function AddFirmwareModalComponent(modal, repositoryService, alert) {
            this.modal = modal;
            this.repositoryService = repositoryService;
            this.alert = alert;
            this.saved = new core.EventEmitter();
            this.onInput = new rxjs.BehaviorSubject('');
            this.model = {
                selected: undefined,
                version: undefined,
                description: undefined,
                deviceType: undefined,
                binary: {
                    file: undefined,
                    url: undefined
                }
            };
            this.saving = false;
            this.firmwarePreselected = false;
            this.textForFirmwareUrlPopover = ngxComponents.gettext("Path for binaries can vary depending on device agent implementation, e.g.:\n    /firmware/binaries/firmware1.bin\n    https://firmware/binary/123\n    ftp://firmware/binary/123.tar.gz\n  ");
        }
        AddFirmwareModalComponent.prototype.ngOnInit = function () {
            this.setInitialState();
            this.loadFirmwares();
        };
        AddFirmwareModalComponent.prototype.setInitialState = function () {
            if (this.model.selected) {
                this.firmwarePreselected = true;
            }
        };
        AddFirmwareModalComponent.prototype.loadFirmwares = function () {
            var _this = this;
            this.inputSubscription$ = this.onInput
                .pipe(operators.tap(function () {
                if (!_this.firmwarePreselected) {
                    _this.model.description = null;
                    if (_this.form) {
                        _this.form.form.get('description').reset();
                    }
                }
            }), operators.debounceTime(300), operators.distinctUntilChanged(), operators.switchMap(function (searchStr) { return _this.getFirmwareResult(searchStr); }))
                .subscribe(function (result) {
                _this.firmwaresResult = result;
            });
        };
        AddFirmwareModalComponent.prototype.getFirmwareResult = function (searchStr) {
            return rxjs.from(this.repositoryService.listRepositoryEntries(exports.RepositoryType.FIRMWARE, {
                partialName: searchStr,
                skipLegacy: true
            }));
        };
        AddFirmwareModalComponent.prototype.save = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    this.saving = true;
                    this.repositoryService
                        .create(this.model, exports.RepositoryType.FIRMWARE)
                        .then(function (savedFirmware) {
                        _this.successMsg();
                        _this.saving = false;
                        _this.saved.next(savedFirmware);
                        _this.cancel();
                    })
                        .catch(function (e) {
                        _this.saving = false;
                        _this.saved.error(e);
                        _this.cancel();
                    });
                    return [2 /*return*/];
                });
            });
        };
        AddFirmwareModalComponent.prototype.successMsg = function () {
            var msg = ngxComponents.gettext('Firmware added.');
            this.alert.success(msg);
        };
        AddFirmwareModalComponent.prototype.cancel = function () {
            this.modal.hide();
            this.saved.complete();
        };
        AddFirmwareModalComponent.prototype.ngOnDestroy = function () {
            this.inputSubscription$.unsubscribe();
        };
        AddFirmwareModalComponent.prototype.onFile = function (dropped) {
            if (!lodashEs.isUndefined(dropped.url)) {
                this.model.binary = {
                    url: dropped.url
                };
                return;
            }
            else if (!lodashEs.isUndefined(dropped.droppedFiles)) {
                this.model.binary = {
                    file: dropped.droppedFiles[0].file
                };
                return;
            }
            else {
                this.model.binary = {
                    file: undefined,
                    url: undefined
                };
            }
        };
        AddFirmwareModalComponent.prototype.onFirmwareSelect = function (firmware) {
            lodashEs.assign(this.model, {
                selected: firmware,
                description: firmware.description,
                deviceType: lodashEs.get(firmware, 'c8y_Filter.type')
            });
        };
        return AddFirmwareModalComponent;
    }());
    AddFirmwareModalComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-add-firmware-software-modal',
                    template: "<div class=\"viewport-modal\">\n  <div class=\"modal-header dialog-header\">\n    <i [c8yIcon]=\"'c8y-firmware'\"></i>\n    <h4 translate>\n      Add firmware\n    </h4>\n  </div>\n  <div class=\"p-16 text-center separator-bottom\" *ngIf=\"!firmwarePreselected\">\n    <p class=\"lead m-0\" translate>\n      Select or create new firmware\n    </p>\n  </div>\n  <form\n    class=\"d-contents\"\n    autocomplete=\"off\"\n    #firmwareForm=\"ngForm\"\n    (ngSubmit)=\"firmwareForm.form.valid && save()\"\n  >\n    <div class=\"modal-inner-scroll\">\n      <div class=\"modal-body\">\n        <div [hidden]=\"firmwarePreselected\">\n          <c8y-form-group>\n            <label for=\"firmwareName\" translate>Firmware</label>\n            <c8y-typeahead\n              [(ngModel)]=\"model.selected\"\n              name=\"firmwareName\"\n              placeholder=\"{{ 'Select or enter' | translate }}\"\n              (onSearch)=\"onInput.next($event)\"\n              [required]=\"true\"\n            >\n              <c8y-li\n                *c8yFor=\"\n                  let firmware of firmwaresResult;\n                  loadMore: 'auto';\n                  notFound: notFoundTemplate\n                \"\n                class=\"p-l-8 p-r-8 c8y-list__item--link\"\n                (click)=\"onFirmwareSelect(firmware)\"\n                [active]=\"model.selected === firmware\"\n              >\n                <c8y-highlight\n                  [text]=\"firmware.name || '--'\"\n                  [pattern]=\"onInput | async\"\n                ></c8y-highlight>\n              </c8y-li>\n              <ng-template #notFoundTemplate>\n                <c8y-li class=\"bg-gray-lighter p-8\" *ngIf=\"(onInput | async)?.length > 0\">\n                  <span translate>No match found.</span>\n                  <button\n                    title=\"{{ 'Add new`firmware`' | translate }}\"\n                    type=\"button\"\n                    class=\"btn btn-primary btn-xs m-l-16\"\n                    translate\n                  >\n                    Add new`firmware`\n                  </button>\n                </c8y-li>\n              </ng-template>\n            </c8y-typeahead>\n          </c8y-form-group>\n\n          <c8y-form-group>\n            <label for=\"firmwareDescription\" translate>Description</label>\n            <input\n              id=\"firmwareDescription\"\n              class=\"form-control\"\n              autocomplete=\"off\"\n              name=\"description\"\n              [(ngModel)]=\"model.description\"\n              placeholder=\"{{ 'e.g. Firmware for hardware revision b' | translate }}\"\n              [disabled]=\"model.selected?.id\"\n              [required]=\"true\"\n            />\n          </c8y-form-group>\n\n          <c8y-form-group>\n            <label class=\"control-label\" for=\"firmwareDeviceTypeFilter\">\n              {{ 'Device type filter' | translate }}\n              <button\n                class=\"btn btn-clean text-primary\"\n                popover=\"{{\n                  'If the filter is set, the firmware will show up for installation only for devices of that type. If no filter is set, it will be available for all devices.'\n                    | translate\n                }}\"\n                triggers=\"focus\"\n                container=\"body\"\n                placement=\"right\"\n              >\n                <i [c8yIcon]=\"'question-circle-o'\"></i>\n              </button>\n            </label>\n            <input\n              id=\"firmwareDeviceTypeFilter\"\n              class=\"form-control\"\n              name=\"firmwareDeviceTypeFilter\"\n              [(ngModel)]=\"model.deviceType\"\n              placeholder=\"{{ 'e.g.' | translate }} c8y_Linux\"\n              [disabled]=\"model.selected?.id\"\n            />\n          </c8y-form-group>\n        </div>\n\n        <c8y-form-group>\n          <label for=\"firmwareVersion\" translate>Version</label>\n          <input\n            id=\"firmwareVersion\"\n            class=\"form-control\"\n            autocomplete=\"off\"\n            name=\"version\"\n            [(ngModel)]=\"model.version\"\n            placeholder=\"{{ 'e.g.' | translate }} 1.0.0\"\n            [required]=\"true\"\n          />\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <div class=\"legend form-block m-t-40\" translate>Firmware file</div>\n          <c8y-file-picker [maxAllowedFiles]=\"1\" (onFilesPicked)=\"onFile($event)\" [fileUrlPopover]=\"textForFirmwareUrlPopover\">\n          </c8y-file-picker>\n        </c8y-form-group>\n      </div>\n    </div>\n    <div class=\"modal-footer\">\n      <button\n        title=\"{{ 'Cancel' | translate }}\"\n        class=\"btn btn-default\"\n        type=\"button\"\n        (click)=\"cancel()\"\n        [disabled]=\"saving\"\n        translate\n      >\n        Cancel\n      </button>\n\n      <button\n        title=\"{{ 'Add firmware' | translate }}\"\n        class=\"btn btn-primary\"\n        type=\"submit\"\n        [ngClass]=\"{ 'btn-pending': saving }\"\n        [disabled]=\"\n          !firmwareForm.form.valid ||\n          firmwareForm.form.pristine ||\n          saving ||\n          (!model.binary?.url && !model.binary?.file)\n        \"\n        translate\n      >\n        Add firmware\n      </button>\n    </div>\n  </form>\n</div>\n"
                },] }
    ];
    AddFirmwareModalComponent.ctorParameters = function () { return [
        { type: modal.BsModalRef },
        { type: RepositoryService },
        { type: ngxComponents.AlertService }
    ]; };
    AddFirmwareModalComponent.propDecorators = {
        form: [{ type: core.ViewChild, args: ['firmwareForm', { static: false },] }],
        saved: [{ type: core.Output }]
    };

    var AddFirmwarePatchModalComponent = /** @class */ (function () {
        function AddFirmwarePatchModalComponent(modal, repository, alert) {
            var _this = this;
            this.modal = modal;
            this.repository = repository;
            this.alert = alert;
            this.saved = new core.EventEmitter();
            this.textForFirmwareUrlPopover = ngxComponents.gettext("Path for binaries can vary depending on device agent implementation, e.g.:\n    /firmware/binaries/firmware1.bin\n    https://firmware/binary/123\n    ftp://firmware/binary/123.tar.gz\n  ");
            this.model = {
                selected: undefined,
                dependency: null,
                patchVersion: undefined,
                binary: {
                    file: undefined,
                    url: undefined
                }
            };
            this.firmwareInput$ = new rxjs.BehaviorSubject('');
            this.firmwares$ = this.firmwareInput$.pipe(operators.debounceTime(300), operators.distinctUntilChanged(), operators.switchMap(function (searchStr) { return rxjs.from(_this.repository.listRepositoryEntries(exports.RepositoryType.FIRMWARE, {
                partialName: searchStr,
                skipLegacy: true
            })); }), operators.shareReplay(1));
            this.firmwareSelected$ = new rxjs.BehaviorSubject(null);
            this.patchDependencyInput$ = new rxjs.BehaviorSubject('');
            this.saving = false;
            this.firmwarePreselected = false;
            this.baseVersions$ = rxjs.merge(this.firmwareInput$.pipe(operators.tap(function () {
                _this.model.dependency = null;
                if (_this.form) {
                    _this.form.form.get('patchDependency').reset();
                }
            }), operators.switchMap(function () { return rxjs.of(null); })), this.firmwareSelected$).pipe(operators.switchMap(function (selectedFirmware) { return selectedFirmware ? _this.repository.listBaseVersions(selectedFirmware) : rxjs.of(null); }), operators.shareReplay(1));
            this.baseVersionsFilterPipe = rxjs.pipe(operators.switchMap(function (data) { return _this.patchDependencyInput$.pipe(operators.map(function (partialVersion) { return data.filter(function (mo) {
                var version = mo.c8y_Firmware.version.toLowerCase();
                return (partialVersion.length === 0 || version.indexOf(partialVersion.toLowerCase()) > -1);
            }); })); }));
        }
        AddFirmwarePatchModalComponent.prototype.ngOnInit = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    this.setInitialState();
                    return [2 /*return*/];
                });
            });
        };
        AddFirmwarePatchModalComponent.prototype.setInitialState = function () {
            if (this.model.selected) {
                this.firmwarePreselected = true;
                this.firmwareSelected$.next(this.model.selected);
            }
        };
        AddFirmwarePatchModalComponent.prototype.save = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    this.saving = true;
                    this.repository
                        .create(this.model, exports.RepositoryType.FIRMWARE)
                        .then(function (savedFirmware) {
                        _this.successMsg();
                        _this.saving = false;
                        _this.saved.next(savedFirmware);
                        _this.cancel();
                    })
                        .catch(function (e) {
                        _this.saving = false;
                        _this.saved.error(e);
                        _this.cancel();
                    });
                    return [2 /*return*/];
                });
            });
        };
        AddFirmwarePatchModalComponent.prototype.successMsg = function () {
            var msg = ngxComponents.gettext('Firmware patch added.');
            this.alert.success(msg);
        };
        AddFirmwarePatchModalComponent.prototype.cancel = function () {
            this.modal.hide();
            this.saved.complete();
        };
        AddFirmwarePatchModalComponent.prototype.onFile = function (dropped) {
            if (!lodashEs.isUndefined(dropped.url)) {
                this.model.binary = {
                    url: dropped.url
                };
                return;
            }
            else if (!lodashEs.isUndefined(dropped.droppedFiles)) {
                this.model.binary = {
                    file: dropped.droppedFiles[0].file
                };
                return;
            }
            else {
                this.model.binary = {
                    file: undefined,
                    url: undefined
                };
            }
        };
        return AddFirmwarePatchModalComponent;
    }());
    AddFirmwarePatchModalComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-add-firmware-patch-modal.component',
                    template: "<div class=\"viewport-modal\">\n  <div class=\"modal-header dialog-header\">\n    <i [c8yIcon]=\"'c8y-firmware'\"></i>\n    <h4 translate>\n      Add firmware patch\n    </h4>\n  </div>\n  <div class=\"p-16 text-center separator-bottom\">\n    <p class=\"lead m-0\" translate>\n      Select a firmware version\n    </p>\n  </div>\n\n  <form\n    class=\"d-contents\"\n    autocomplete=\"off\"\n    #firmwarePatchForm=\"ngForm\"\n    (ngSubmit)=\"firmwarePatchForm.form.valid && save()\">\n    <div class=\"modal-inner-scroll\">\n      <div class=\"modal-body\">\n        <div [hidden]=\"firmwarePreselected\">\n          <c8y-form-group>\n            <label for=\"firmwareName\" translate>Firmware</label>\n            <c8y-typeahead\n              [ngModel]=\"model.selected\"\n              name=\"firmwareName\"\n              placeholder=\"{{ 'Select or enter' | translate }}\"\n              (onSearch)=\"firmwareInput$.next($event)\"\n              [allowFreeEntries]=\"false\"\n              [required]=\"true\"\n            >\n              <c8y-li\n                *c8yFor=\"let firmware of firmwares$ | async; loadMore: 'auto'\"\n                class=\"p-l-8 p-r-8 c8y-list__item--link\"\n                (click)=\"model.selected = firmware; firmwareSelected$.next(firmware)\"\n                [active]=\"model.selected === firmware\"\n              >\n                <c8y-highlight\n                  [text]=\"firmware.name || '--'\"\n                  [pattern]=\"firmwareInput$ | async\"\n                ></c8y-highlight>\n              </c8y-li>\n            </c8y-typeahead>\n            <c8y-messages\n              ><c8y-message\n                name=\"notExisting\"\n                [text]=\"'Select one of the existing firmwares.' | translate\"\n              ></c8y-message>\n            </c8y-messages>\n          </c8y-form-group>\n        </div>\n\n        <c8y-form-group>\n          <label for=\"patchDependency\" class=\"m-r-8\" translate>Version</label>\n          <c8y-typeahead\n            [ngModel]=\"model.dependency\"\n            name=\"patchDependency\"\n            placeholder=\"{{ 'Select or enter' | translate }}\"\n            (onSearch)=\"patchDependencyInput$.next($event)\"\n            [displayProperty]=\"'c8y_Firmware.version'\"\n            [allowFreeEntries]=\"false\"\n            [disabled]=\"\n              (baseVersions$ | async) === null || (baseVersions$ | async)?.data.length === 0\n            \"\n            [required]=\"true\"\n          >\n            <c8y-li\n              *c8yFor=\"\n                let baseVersion of baseVersions$;\n                loadMore: 'auto';\n                pipe: baseVersionsFilterPipe\n              \"\n              class=\"p-l-8 p-r-8 c8y-list__item--link\"\n              (click)=\"model.dependency = baseVersion\"\n              [active]=\"model.dependency === baseVersion\"\n            >\n              <c8y-highlight\n                [text]=\"baseVersion.c8y_Firmware.version || '--'\"\n                [pattern]=\"patchDependencyInput$ | async\"\n              ></c8y-highlight>\n            </c8y-li>\n          </c8y-typeahead>\n          <c8y-messages\n            ><c8y-message\n              name=\"notExisting\"\n              [text]=\"'Select one of the existing versions.' | translate\"\n            ></c8y-message>\n          </c8y-messages>\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <label for=\"patchVersion\" translate>Patch</label>\n          <input\n            id=\"patchVersion\"\n            class=\"form-control\"\n            autocomplete=\"off\"\n            name=\"patchVersion\"\n            [(ngModel)]=\"model.patchVersion\"\n            placeholder=\"{{ 'e.g.' | translate }} 1.0.0\"\n            required\n          />\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <div class=\"legend form-block m-t-40\" translate>Patch file</div>\n          <c8y-file-picker [maxAllowedFiles]=\"1\" (onFilesPicked)=\"onFile($event)\" [fileUrlPopover]=\"textForFirmwareUrlPopover\">\n          </c8y-file-picker>\n        </c8y-form-group>\n      </div>\n    </div>\n    <div class=\"modal-footer\">\n      <button\n        title=\"{{ 'Cancel' | translate }}\"\n        class=\"btn btn-default\"\n        type=\"button\"\n        (click)=\"cancel()\"\n        [disabled]=\"saving\"\n        translate\n      >\n        Cancel\n      </button>\n      <button\n        title=\"{{ 'Add firmware patch' | translate }}\"\n        class=\"btn btn-primary\"\n        type=\"submit\"\n        [ngClass]=\"{ 'btn-pending': saving }\"\n        [disabled]=\"\n          !firmwarePatchForm.form.valid ||\n          firmwarePatchForm.form.pristine ||\n          (!model.binary?.url && !model.binary?.file) ||\n          saving\n        \"\n        translate\n      >\n        Add firmware patch\n      </button>\n    </div>\n  </form>\n</div>\n"
                },] }
    ];
    AddFirmwarePatchModalComponent.ctorParameters = function () { return [
        { type: modal.BsModalRef },
        { type: RepositoryService },
        { type: ngxComponents.AlertService }
    ]; };
    AddFirmwarePatchModalComponent.propDecorators = {
        saved: [{ type: core.Output }],
        dropdown: [{ type: core.ViewChild, args: ['dropdown', { static: false },] }],
        form: [{ type: core.ViewChild, args: ['firmwarePatchForm', { static: false },] }]
    };

    var FirmwareDetailsComponent = /** @class */ (function () {
        function FirmwareDetailsComponent(activatedRoute, inventoryService, repositoryService, alertService, translateService, modalService, bsModalService) {
            var _this = this;
            this.activatedRoute = activatedRoute;
            this.inventoryService = inventoryService;
            this.repositoryService = repositoryService;
            this.alertService = alertService;
            this.translateService = translateService;
            this.modalService = modalService;
            this.bsModalService = bsModalService;
            this.reload$ = new rxjs.Subject();
            this.reloading$ = new rxjs.BehaviorSubject(false);
            this.updateFirmware$ = new rxjs.Subject();
            this.firmwareUpdated$ = new rxjs.Subject();
            this.baseVersionsUpdated$ = new rxjs.Subject();
            this.patchVersionsUpdated$ = new rxjs.Subject();
            this.firmware$ = rxjs.merge(this.activatedRoute.params.pipe(operators.map(function (params) { return params.id; }), operators.switchMap(function (id) { return rxjs.defer(function () { return _this.inventoryService.detail(id).then(function (result) { return result.data; }); }); })), this.reload$.pipe(operators.tap(function () { return _this.reloading$.next(true); }), operators.switchMap(function () { return _this.activatedRoute.params; }), operators.map(function (params) { return params.id; }), operators.switchMap(function (id) { return rxjs.defer(function () { return _this.inventoryService.detail(id).then(function (result) { return result.data; }); }); }), operators.tap(function () { return _this.reloading$.next(false); })), this.firmwareUpdated$).pipe(operators.shareReplay(1));
            this.baseVersions$ = rxjs.merge(this.firmware$.pipe(operators.distinctUntilKeyChanged('id')), this.baseVersionsUpdated$, this.patchVersionsUpdated$, this.reload$).pipe(operators.switchMap(function () { return _this.firmware$; }), operators.switchMap(function (firmware) { return _this.repositoryService.listBaseVersions(firmware); }), operators.shareReplay(1));
            this.isLegacy$ = this.firmware$.pipe(operators.map(function (firmware) { return _this.repositoryService.isLegacyEntry(firmware); }), operators.shareReplay(1));
            this.canAddPatchVersions$ = rxjs.combineLatest(this.isLegacy$, this.baseVersions$.pipe(operators.map(function (_a) {
                var data = _a.data;
                return data.length > 0;
            }))).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), isLegacy = _b[0], hasBaseVersions = _b[1];
                return !isLegacy && hasBaseVersions;
            }));
            this.expanded = {};
            this.destroy$ = new rxjs.Subject();
        }
        FirmwareDetailsComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.updateFirmware$
                .pipe(operators.withLatestFrom(this.firmware$), operators.switchMap(function (_a) {
                var _b = __read(_a, 2), firmwarePartial = _b[0], firmware = _b[1];
                return _this.inventoryService.update(Object.assign({ id: firmware.id }, firmwarePartial));
            }), operators.map(function (_a) {
                var data = _a.data;
                return data;
            }), operators.tap(function (firmware) { return _this.firmwareUpdated$.next(firmware); }), operators.tap(function () { return _this.alertService.success(ngxComponents.gettext('Saved.')); }), operators.takeUntil(this.destroy$))
                .subscribe();
        };
        FirmwareDetailsComponent.prototype.getPatchVersionsCount$ = function (baseVersion) {
            var _this = this;
            return rxjs.merge(this.firmware$.pipe(operators.distinctUntilKeyChanged('id')), this.baseVersionsUpdated$, this.patchVersionsUpdated$, this.reload$).pipe(operators.switchMap(function () { return _this.firmware$; }), operators.switchMap(function (firmware) { return _this.repositoryService.getPatchVersionsCount$(firmware, baseVersion); }), operators.shareReplay(1));
        };
        FirmwareDetailsComponent.prototype.getBinaryName$ = function (binaryUrl) {
            return this.repositoryService.getBinaryName$(binaryUrl);
        };
        FirmwareDetailsComponent.prototype.getPatchVersions$ = function (baseVersion) {
            var _this = this;
            return rxjs.merge(this.firmware$.pipe(operators.distinctUntilKeyChanged('id')), this.patchVersionsUpdated$, this.reload$).pipe(operators.switchMap(function () { return _this.firmware$; }), operators.switchMap(function (firmware) { return _this.repositoryService.listPatchVersions(firmware, baseVersion); }), operators.shareReplay(1));
        };
        FirmwareDetailsComponent.prototype.addBaseVersion = function () {
            var _this = this;
            this.firmware$
                .pipe(operators.take(1), operators.switchMap(function (firmware) {
                var initialState = {
                    model: {
                        selected: firmware,
                        description: firmware.description
                    }
                };
                var config = {
                    class: 'modal-sm',
                    ignoreBackdropClick: true,
                    initialState: initialState
                };
                var modalRef = _this.bsModalService.show(AddFirmwareModalComponent, config);
                return modalRef.content.saved;
            }))
                .subscribe(function () { return _this.baseVersionsUpdated$.next(); });
        };
        FirmwareDetailsComponent.prototype.addPatchVersion = function () {
            var _this = this;
            this.firmware$
                .pipe(operators.take(1), operators.switchMap(function (firmware) {
                var initialState = {
                    model: {
                        selected: firmware
                    }
                };
                var config = {
                    class: 'modal-sm',
                    ignoreBackdropClick: true,
                    initialState: initialState
                };
                var modalRef = _this.bsModalService.show(AddFirmwarePatchModalComponent, config);
                return modalRef.content.saved;
            }))
                .subscribe(function () { return _this.patchVersionsUpdated$.next(); });
        };
        FirmwareDetailsComponent.prototype.deleteBaseVersion = function (baseVersion) {
            return __awaiter(this, void 0, void 0, function () {
                var title, body, labels, ex_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 3, , 4]);
                            title = ngxComponents.gettext('Delete firmware');
                            body = "\n        " + this.translateService.instant(ngxComponents.gettext('You are about to delete firmware {{ version }} with all its patches.'), { version: baseVersion.c8y_Firmware.version }) + "\n        " + this.translateService.instant(ngxComponents.gettext('This operation is irreversible.')) + "\n        " + this.translateService.instant(ngxComponents.gettext('Do you want to proceed?')) + "\n      ";
                            labels = {
                                ok: ngxComponents.gettext('Delete')
                            };
                            return [4 /*yield*/, this.modalService.confirm(title, body, ngxComponents.Status.DANGER, labels)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.repositoryService.delete(baseVersion)];
                        case 2:
                            _a.sent();
                            this.alertService.success(ngxComponents.gettext('Firmware deleted.'));
                            this.baseVersionsUpdated$.next();
                            return [3 /*break*/, 4];
                        case 3:
                            ex_1 = _a.sent();
                            // only if not cancel from modal
                            if (ex_1) {
                                this.alertService.addServerFailure(ex_1);
                            }
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        FirmwareDetailsComponent.prototype.deletePatchVersion = function (patchVersion) {
            return __awaiter(this, void 0, void 0, function () {
                var title, body, labels, ex_2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 3, , 4]);
                            title = ngxComponents.gettext('Delete firmware patch');
                            body = "\n        " + this.translateService.instant(ngxComponents.gettext('You are about to delete firmware patch {{ version }}.'), { version: patchVersion.c8y_Firmware.version }) + "\n        " + this.translateService.instant(ngxComponents.gettext('This operation is irreversible.')) + "\n        " + this.translateService.instant(ngxComponents.gettext('Do you want to proceed?')) + "\n      ";
                            labels = {
                                ok: ngxComponents.gettext('Delete')
                            };
                            return [4 /*yield*/, this.modalService.confirm(title, body, ngxComponents.Status.DANGER, labels)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.repositoryService.delete(patchVersion)];
                        case 2:
                            _a.sent();
                            this.alertService.success(ngxComponents.gettext('Firmware patch deleted.'));
                            this.patchVersionsUpdated$.next();
                            return [3 /*break*/, 4];
                        case 3:
                            ex_2 = _a.sent();
                            // only if not cancel from modal
                            if (ex_2) {
                                this.alertService.addServerFailure(ex_2);
                            }
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        FirmwareDetailsComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.unsubscribe();
        };
        return FirmwareDetailsComponent;
    }());
    FirmwareDetailsComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-firmware-details',
                    template: "<c8y-title>\n  {{ (firmware$ | async)?.name }}\n</c8y-title>\n\n<c8y-breadcrumb>\n  <c8y-breadcrumb-item\n    path=\"#/firmware\"\n    label=\"{{ 'Firmware repository' | translate }}\"\n    icon=\"c8y-firmware\"\n  >\n  </c8y-breadcrumb-item>\n</c8y-breadcrumb>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button\n    *ngIf=\"!(isLegacy$ | async)\"\n    class=\"btn btn-link\"\n    title=\"{{ 'Add firmware' | translate }}\"\n    (click)=\"addBaseVersion()\"\n  >\n    <i c8yIcon=\"plus-circle\"></i>\n    {{ 'Add firmware' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button\n    *ngIf=\"canAddPatchVersions$ | async\"\n    class=\"btn btn-link\"\n    title=\"{{ 'Add firmware patch' | translate }}\"\n    (click)=\"addPatchVersion()\"\n  >\n    <i c8yIcon=\"plus-circle\"></i>\n    {{ 'Add firmware patch' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\" title=\"{{ 'Reload' | translate }}\" (click)=\"reload$.next()\">\n    <i c8yIcon=\"refresh\" [ngClass]=\"{ 'icon-spin': reloading$ | async }\"></i>\n    {{ 'Reload' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<div class=\"row\">\n  <div class=\"col-lg-12 col-lg-max\">\n    <div class=\"card m-b-4\">\n      <div class=\"card-header separator\">\n        <h4 class=\"card-title\" translate>\n          Name, description and device type filter\n        </h4>\n      </div>\n      <div class=\"card-block\">\n        <div class=\"row\">\n          <div class=\"col-md-4\">\n            <c8y-form-group>\n              <label class=\"control-label\">\n                {{ 'Name' | translate }}\n              </label>\n              <div class=\"input-group input-group-editable\">\n                <input\n                  #nameInput\n                  type=\"text\"\n                  class=\"form-control\"\n                  [ngModel]=\"(firmware$ | async)?.name\"\n                  #nameModel=\"ngModel\"\n                  placeholder=\"{{ 'e.g. My firmware' | translate }}\"\n                  [ngStyle]=\"{ 'width.ch': (firmware$ | async)?.name?.length || 31 }\"\n                  required\n                />\n                <span></span>\n                <div class=\"input-group-btn\">\n                  <button\n                    class=\"btn btn-primary\"\n                    title=\"{{ 'Save' | translate }}\"\n                    (click)=\"updateFirmware$.next({ name: nameInput.value }); nameModel.reset()\"\n                    [disabled]=\"nameInput.value.length == 0\"\n                  >\n                    {{ 'Save' | translate }}\n                  </button>\n                </div>\n              </div>\n            </c8y-form-group>\n          </div>\n          <div class=\"col-md-4\">\n            <c8y-form-group>\n              <label class=\"control-label\">\n                {{ 'Description' | translate }}\n              </label>\n              <div class=\"input-group input-group-editable\">\n                <input\n                  #descriptionInput\n                  type=\"text\"\n                  class=\"form-control\"\n                  [ngModel]=\"(firmware$ | async)?.description\"\n                  #descriptionModel=\"ngModel\"\n                  placeholder=\"{{ 'e.g. Firmware for hardware revision b' | translate }}\"\n                  [ngStyle]=\"{ 'width.ch': (firmware$ | async)?.description?.length || 31 }\"\n\n                />\n                <span></span>\n                <div class=\"input-group-btn\">\n                  <button\n                    class=\"btn btn-primary\"\n                    title=\"{{ 'Save' | translate }}\"\n                    (click)=\" updateFirmware$.next({ description: descriptionInput.value }); descriptionModel.reset() \"\n                  >\n                    {{ 'Save' | translate }}\n                  </button>\n                </div>\n              </div>\n            </c8y-form-group>\n          </div>\n          <div class=\"col-md-4\">\n            <c8y-form-group>\n              <label class=\"control-label\">\n                {{ 'Device type filter' | translate }}\n\n                <button\n                 class=\"btn-clean\"\n                  popover=\"{{ 'If the filter is set, the firmware will show up for installation only for devices of that type. If no filter is set, it will be available for all devices.' | translate }}\"\n                  [outsideClick]=\"true\"\n                  container=\"body\"\n                >\n                  <i c8yIcon=\"question-circle-o\" class=\"text-info\"></i>\n                </button>\n              </label>\n              <div class=\"input-group input-group-editable\">\n                <input\n                  #deviceTypeInput\n                  type=\"text\"\n                  class=\"form-control\"\n                  [ngModel]=\"(firmware$ | async)?.c8y_Filter?.type\"\n                  #deviceTypeModel=\"ngModel\"\n                  placeholder=\"{{ 'e.g.' | translate }} c8y_Linux\"\n                  [ngStyle]=\"{ 'width.ch': (firmware$ | async)?.type?.length || 31 }\"\n                />\n                <span></span>\n                <div class=\"input-group-btn\">\n                  <button\n                    class=\"btn btn-primary\"\n                    title=\"{{ 'Save' | translate }}\"\n                    (click)=\" updateFirmware$.next({ c8y_Filter: { type: deviceTypeInput.value } }); deviceTypeModel.reset()\"\n                  >\n                    {{ 'Save' | translate }}\n                  </button>\n                </div>\n              </div>\n            </c8y-form-group>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n<div class=\"row\">\n  <div class=\"col-lg-12 col-lg-max\">\n    <div class=\"card\">\n      <div class=\"card-header separator\">\n        <h4 class=\"card-title\" translate>\n          Versions and patches\n        </h4>\n      </div>\n\n      <div class=\"card-block p-t-0 p-b-24\">\n        <div *ngIf=\"(baseVersions$ | async)?.data.length === 0\">\n          <div class=\"c8y-empty-state text-center\">\n            <h1 c8yIcon=\"c8y-firmware\" class=\"c8y-icon-duocolor\"></h1>\n            <h3 translate>No versions to display.</h3>\n            <p translate>Add a new version by clicking below.</p>\n            <p>\n              <button\n                class=\"btn btn-primary\"\n                title=\"{{ 'Add firmware' | translate }}\"\n                (click)=\"addBaseVersion()\"\n              >\n                {{ 'Add firmware' | translate }}\n              </button>\n            </p>\n          </div>\n        </div>\n\n        <c8y-list-group\n          [ngClass]=\"{ 'dd-low': (baseVersions$ | async)?.data.length < 10 }\"\n          *ngIf=\"(baseVersions$ | async)?.data.length > 0\"\n        >\n          <c8y-li\n            *c8yFor=\"let baseVersion of baseVersions$ | async; let i = index; loadMore: 'auto'\"\n            [ngClass]=\"{ 'c8y-list__item--empty-actions': !(getPatchVersions$(baseVersion) | async)?.data.length }\"\n            [collapsed]=\"!expanded[baseVersion.id]\"\n            (collapsedChange)=\"expanded[baseVersion.id] = !$event\"\n          >\n            <c8y-li-icon>\n              <i c8yIcon=\"c8y-firmware\"></i>\n            </c8y-li-icon>\n\n            <c8y-li-body class=\"content-flex-50\">\n              <div class=\"col-4\">\n                <p class=\"text-truncate-wrap\" title=\"{{ baseVersion.c8y_Firmware.version }}\">\n                  {{ baseVersion.c8y_Firmware.version }}\n                </p>\n              </div>\n              <div class=\"col-5\">\n                <p class=\"text-truncate-wrap\">\n                  <span class=\"text-label-small m-r-8\" translate>\n                    File\n                  </span>\n                  <span title=\"{{ getBinaryName$(baseVersion.c8y_Firmware.url) | async }}\">\n                    <c8y-file-download url=\"{{ baseVersion.c8y_Firmware.url }}\"></c8y-file-download>\n                  </span>\n                </p>\n              </div>\n              <div class=\"col-2 flex-row a-i-start\">\n                <span *ngIf=\"isLegacy$ | async\" class=\"label label-warning flex-item-right-sm\">\n                  {{ 'Legacy' | translate }}\n                </span>\n\n                <span *ngIf=\"!(isLegacy$ | async)\">\n                  <span *ngIf=\"(getPatchVersionsCount$(baseVersion) | async) === null\">\n                    <span class=\"label label-info\">\n                      <i c8yIcon=\"circle-o-notch\" class=\"icon-spin\"></i>\n                    </span>\n                  </span>\n                  <span *ngIf=\"(getPatchVersionsCount$(baseVersion) | async) !== null\">\n                    <span [ngPlural]=\"getPatchVersionsCount$(baseVersion) | async\">\n                      <ng-template ngPluralCase=\"=0\">\n                        <span class=\"label label-default flex-item-right-sm\">\n                          <span translate>No patches</span>\n                        </span>\n                      </ng-template>\n                      <ng-template ngPluralCase=\"=1\">\n                        <span class=\"label label-info\">\n                          <span translate>1 patch</span>\n                        </span>\n                      </ng-template>\n                      <ng-template ngPluralCase=\"other\">\n                        <span class=\"label label-info\">\n                          <span\n                            ngNonBindable\n                            translate\n                            [translateParams]=\"{ count: getPatchVersionsCount$(baseVersion) | async }\"\n                          >\n                            {{ count }} patches\n                          </span>\n                        </span>\n                      </ng-template>\n                    </span>\n                  </span>\n                </span>\n              </div>\n              <div class=\"fit-h-20 visible-xs\" *ngIf=\"!(isLegacy$ | async)\">\n                <button\n                  class=\"btn btn-danger btn-xs m-t-8 \"\n                  (click)=\"deleteBaseVersion(baseVersion)\"\n                  title=\"{{ 'Delete' | translate }}\"\n                >\n                  <i c8yIcon=\"minus-circle\"></i>\n                  {{ 'Delete' | translate }}\n                </button>\n              </div>\n              <div *ngIf=\"!(isLegacy$ | async)\" class=\"flex-item-right fit-h-20 p-r-8 hidden-xs\">\n                <button\n                  class=\"btn btn-dot text-danger showOnHover\"\n                  (click)=\"deleteBaseVersion(baseVersion)\"\n                  title=\"{{ 'Delete' | translate }}\"\n                >\n                  <i c8yIcon=\"minus-circle\"></i>\n                </button>\n              </div>\n            </c8y-li-body>\n            <c8y-li-collapse *ngIf=\"(getPatchVersions$(baseVersion) | async)?.data.length\">\n              <c8y-list-group class=\"separator-top\">\n                <c8y-li\n                  *c8yFor=\" let patchVersion of getPatchVersions$(baseVersion) | async; let i = index; loadMore: 'auto' \"\n                >\n                  <c8y-li-icon>\n                    <i c8yIcon=\"c8y-firmware\"></i>\n                  </c8y-li-icon>\n                  <c8y-li-body class=\"content-flex-50\">\n                    <div class=\"col-4\">\n                      {{ patchVersion.c8y_Firmware.version }}\n                    </div>\n                    <div class=\"col-5\">\n                      <div class=\"text-truncate\">\n                        <span class=\"text-label-small m-r-8\" translate>\n                          File\n                        </span>\n                        <c8y-file-download\n                          url=\"{{ patchVersion.c8y_Firmware.url }}\"\n                        ></c8y-file-download>\n                      </div>\n                    </div>\n                    <div class=\"visible-xs m-t-8\">\n                      <button\n                        class=\"btn btn-danger btn-xs\"\n                        (click)=\"deletePatchVersion(patchVersion)\"\n                        title=\"{{ 'Delete' | translate }}\"\n                      >\n                        <i c8yIcon=\"minus-circle\"></i>\n                        {{ 'Delete' | translate }}\n                      </button>\n                    </div>\n                    <div class=\"flex-item-right p-r-8 hidden-xs fit-h-20\">\n                      <button\n                        class=\"btn btn-dot text-danger showOnHover\"\n                        (click)=\"deletePatchVersion(patchVersion)\"\n                        title=\"{{ 'Delete' | translate }}\"\n                      >\n                        <i c8yIcon=\"minus-circle\"></i>\n                      </button>\n                    </div>\n                  </c8y-li-body>\n                </c8y-li>\n              </c8y-list-group>\n            </c8y-li-collapse>\n          </c8y-li>\n        </c8y-list-group>\n      </div>\n    </div>\n  </div>\n</div>\n"
                },] }
    ];
    FirmwareDetailsComponent.ctorParameters = function () { return [
        { type: router.ActivatedRoute },
        { type: client.InventoryService },
        { type: RepositoryService },
        { type: ngxComponents.AlertService },
        { type: core$1.TranslateService },
        { type: ngxComponents.ModalService },
        { type: modal.BsModalService }
    ]; };
    __decorate([
        ngxComponents.memoize(lodashEs.property('id'))
    ], FirmwareDetailsComponent.prototype, "getPatchVersionsCount$", null);
    __decorate([
        ngxComponents.memoize()
    ], FirmwareDetailsComponent.prototype, "getBinaryName$", null);
    __decorate([
        ngxComponents.memoize(lodashEs.property('id'))
    ], FirmwareDetailsComponent.prototype, "getPatchVersions$", null);

    var FirmwareListComponent = /** @class */ (function () {
        function FirmwareListComponent(repositoryService, modalService, bsModalService, translateService, alertService, router, activatedRoute) {
            var _this = this;
            this.repositoryService = repositoryService;
            this.modalService = modalService;
            this.bsModalService = bsModalService;
            this.translateService = translateService;
            this.alertService = alertService;
            this.router = router;
            this.activatedRoute = activatedRoute;
            this.textFilter$ = new rxjs.BehaviorSubject('');
            this.reload$ = new rxjs.BehaviorSubject(null);
            this.reloading = false;
            this.firmwares$ = rxjs.combineLatest(this.textFilter$.pipe(operators.debounceTime(400), operators.distinctUntilChanged()), this.reload$).pipe(operators.tap(function () {
                _this.reloading = true;
            }), operators.switchMap(function (_a) {
                var _b = __read(_a, 1), text = _b[0];
                return _this.getFirmwares(text);
            }), operators.tap(function () {
                _this.reloading = false;
            }), operators.shareReplay(1));
            this.canAddFirmwarePatch$ = rxjs.from(this.repositoryService.listRepositoryEntries(exports.RepositoryType.FIRMWARE, { skipLegacy: true })).pipe(operators.map(function (_a) {
                var data = _a.data;
                return data.length > 0;
            }));
            this.isLegacy = this.repositoryService.isLegacyEntry.bind(this.repositoryService);
            this.DEVICE_TYPE_NOT_AVAILABLE = ngxComponents.gettext('No device type available');
        }
        FirmwareListComponent.prototype.getFirmwares = function (partialText) {
            var properties = ['name', 'description', 'c8y_Filter.type'];
            var partialTextFilter = { partialText: partialText, properties: properties };
            return this.repositoryService.listRepositoryEntries(exports.RepositoryType.FIRMWARE, {
                partialTextFilter: partialTextFilter
            });
        };
        FirmwareListComponent.prototype.addFirmware = function () {
            var _this = this;
            var config = { class: 'modal-sm', ignoreBackdropClick: true };
            var modalRef = this.bsModalService.show(AddFirmwareModalComponent, config);
            modalRef.content.saved.subscribe(function (savedFirmware) { return _this.editFirmware(savedFirmware); });
        };
        FirmwareListComponent.prototype.addFirmwarePatch = function () {
            var _this = this;
            var config = { class: 'modal-sm', ignoreBackdropClick: true };
            var modalRef = this.bsModalService.show(AddFirmwarePatchModalComponent, config);
            modalRef.content.saved.subscribe(function (savedFirmware) { return _this.editFirmware(savedFirmware); });
        };
        FirmwareListComponent.prototype.editFirmware = function (firmware) {
            this.router.navigate([firmware.id], { relativeTo: this.activatedRoute });
        };
        FirmwareListComponent.prototype.deleteFirmware = function (firmware) {
            return __awaiter(this, void 0, void 0, function () {
                var title, body, labels, ex_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 3, , 4]);
                            title = ngxComponents.gettext('Delete firmware');
                            body = "\n        " + this.translateService.instant(ngxComponents.gettext('You are about to delete firmware "{{ name }}" with all its versions and patches.'), { name: firmware.name }) + "\n        " + this.translateService.instant(ngxComponents.gettext('This operation is irreversible.')) + "\n        " + this.translateService.instant(ngxComponents.gettext('Do you want to proceed?')) + "\n      ";
                            labels = {
                                ok: ngxComponents.gettext('Delete')
                            };
                            return [4 /*yield*/, this.modalService.confirm(title, body, ngxComponents.Status.DANGER, labels)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.repositoryService.delete(firmware)];
                        case 2:
                            _a.sent();
                            this.alertService.success(ngxComponents.gettext('Firmware deleted.'));
                            this.reload$.next();
                            return [3 /*break*/, 4];
                        case 3:
                            ex_1 = _a.sent();
                            // only if not cancel from modal
                            if (ex_1) {
                                this.alertService.addServerFailure(ex_1);
                            }
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        FirmwareListComponent.prototype.getBaseVersionsCount$ = function (firmware) {
            var _this = this;
            return this.firmwares$.pipe(operators.switchMap(function () { return _this.repositoryService.getBaseVersionsCount$(firmware); }), operators.shareReplay(1));
        };
        FirmwareListComponent.prototype.getDeviceTypeTitle = function (firmware) {
            return lodashEs.get(firmware, 'c8y_Filter.type', this.translateService.instant(this.DEVICE_TYPE_NOT_AVAILABLE));
        };
        return FirmwareListComponent;
    }());
    FirmwareListComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-firmware-list',
                    template: "<c8y-title>\n  {{ 'Firmware repository' | translate }}\n</c8y-title>\n\n<c8y-action-bar-item [placement]=\"'left'\" itemClass=\"navbar-form\">\n  <div class=\"input-group input-group-search\">\n    <input class=\"form-control\"\n      type=\"search\"\n      title=\"{{ 'Filter firmware\u2026' | translate }}\"\n      placeholder=\"{{ 'Filter firmware\u2026' | translate }}\"\n      [ngModel]=\"textFilter$ | async\"\n      (ngModelChange)=\"textFilter$.next($event)\"\n    />\n    <span class=\"input-group-addon\">\n      <i\n        c8yIcon=\"search\"\n        *ngIf=\"(textFilter$ | async).length === 0\"\n      ></i>\n      <i class=\"text-muted\"\n        c8yIcon=\"times\"\n        *ngIf=\"(textFilter$ | async).length > 0\"\n        (click)=\"textFilter$.next('')\"\n      ></i>\n    </span>\n  </div>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\"\n    title=\"{{ 'Add firmware' | translate }}\"\n    (click)=\"addFirmware()\"\n  >\n    <i c8yIcon=\"plus-circle\"></i>\n    {{ 'Add firmware' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\"\n    *ngIf=\"canAddFirmwarePatch$ | async\"\n    title=\"{{ 'Add firmware patch' | translate }}\"\n    (click)=\"addFirmwarePatch()\"\n  >\n    <i c8yIcon=\"plus-circle\"></i>\n    {{ 'Add firmware patch' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\"\n    title=\"{{ 'Reload' | translate }}\"\n    (click)=\"reload$.next()\"\n  >\n    <i c8yIcon=\"refresh\"\n      [ngClass]=\"{ 'icon-spin': reloading }\"\n    ></i>\n    {{ 'Reload' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<!-- empty state-->\n<div class=\"c8y-empty-state text-center\"\n  *ngIf=\"(firmwares$ | async)?.data.length === 0 && (textFilter$ | async)?.length === 0\"\n>\n  <h1 class=\"c8y-icon-duocolor\"\n    c8yIcon=\"c8y-firmware\"\n  ></h1>\n  <h3 translate>\n    No firmwares to display.\n  </h3>\n  <p translate>\n    Add a new firmware by clicking below.\n  </p>\n  <p>\n    <button class=\"btn btn-primary\"\n      title=\"{{ 'Add firmware' | translate }}\"\n      (click)=\"addFirmware()\"\n      translate\n    >\n      Add firmware\n    </button>\n  </p>\n</div>\n\n<!-- no results empty state -->\n<div class=\"c8y-empty-state\"\n  *ngIf=\"(firmwares$ | async)?.data.length === 0 && (textFilter$ | async)?.length > 0\"\n  >\n  <h1 class=\"c8y-icon-duocolor\"\n    c8yIcon=\"search\"></h1>\n  <h3 translate>\n    No results to display.\n  </h3>\n  <p translate>\n    Refine your search terms or check your spelling.\n  </p>\n</div>\n\n<c8y-list-group class=\"m-b-24\"\n  *ngIf=\"(firmwares$ | async)?.data.length > 0\"\n  [ngClass]=\"{ 'dd-low': (firmwares$ | async)?.data.length < 10 }\"\n\n>\n  <c8y-li class=\"page-sticky-header c8y-list__item--empty-actions hidden-xs\">\n    <c8y-li-icon>\n      <i class=\"p-l-24\"></i>\n    </c8y-li-icon>\n    <c8y-li-body class=\"content-flex-60\">\n      <div class=\"col-3\">\n        {{'Firmware' | translate}}\n      </div>\n      <div class=\"col-4\">\n        {{'Description' | translate}}\n      </div>\n      <div class=\"col-3\">\n        {{'Device type' | translate}}\n      </div>\n      <div class=\"col-2\">\n        {{'Versions' | translate}}\n      </div>\n    </c8y-li-body>\n  </c8y-li>\n\n  <c8y-li *c8yFor=\"let firmware of firmwares$ | async; let i = index; loadMore: 'auto'\">\n    <c8y-li-icon icon=\"c8y-firmware\"></c8y-li-icon>\n    <c8y-li-body class=\"content-flex-60\">\n      <button class=\"btn-clean col-3\"\n        (click)=\"editFirmware(firmware)\"\n      >\n        <span class=\"text-truncate\"\n          title=\"{{ firmware.name }}\"\n        >\n          <c8y-highlight\n            [text]=\"firmware.name || '-'\"\n            elementClass=\"text-info\"\n            [pattern]=\"textFilter$ | async\"\n          ></c8y-highlight>\n        </span>\n      </button>\n      <div class=\"col-4\">\n        <p class=\"text-truncate\"\n          title=\"{{ firmware.description }}\"\n        >\n          <span class=\"text-label-small m-r-4 visible-xs-inline\">\n            {{'Description' | translate }}\n          </span>\n          <span *ngIf=\"firmware.description; else emptyDescription\">\n            <c8y-highlight\n              [text]=\"firmware.description || '-'\"\n              elementClass=\"text-info\"\n              [pattern]=\"textFilter$ | async\"\n            ></c8y-highlight>\n          </span>\n        </p>\n        <ng-template #emptyDescription>\n          <small class=\"text-muted\">\n            <em>{{ 'No description' | translate }}</em>\n          </small>\n        </ng-template>\n      </div>\n      <div class=\"col-3\">\n        <div class=\"text-truncate\">\n          <span class=\"text-label-small m-r-4 visible-xs-inline\" translate>\n            Device type\n          </span>\n          <span\n            *ngIf=\"firmware.c8y_Filter?.type; else emptyText\"\n            title=\"{{ firmware.c8y_Filter?.type }}\"\n          >\n            <c8y-highlight\n              [text]=\"firmware.c8y_Filter?.type || '-'\"\n              elementClass=\"text-info\"\n              [pattern]=\"textFilter$ | async\"\n            ></c8y-highlight>\n          </span>\n          <ng-template #emptyText>\n            <small class=\"text-muted\">\n              <em>{{ 'Undefined' | translate }}</em>\n            </small>\n          </ng-template>\n        </div>\n      </div>\n      <div class=\"col-2\">\n        <span class=\"label label-warning flex-item-right-sm\"\n          *ngIf=\"isLegacy(firmware)\"\n          >\n          <span translate>\n            Legacy\n          </span>\n        </span>\n\n        <span *ngIf=\"!isLegacy(firmware)\">\n          <span *ngIf=\"(getBaseVersionsCount$(firmware) | async) === null\">\n            <span class=\"label label-info flex-item-right-sm\">\n              <i c8yIcon=\"circle-o-notch\" class=\"icon-spin\"></i>\n            </span>\n          </span>\n          <span *ngIf=\"(getBaseVersionsCount$(firmware) | async) !== null\">\n            <span [ngPlural]=\"getBaseVersionsCount$(firmware) | async\">\n              <ng-template ngPluralCase=\"=0\">\n                <span class=\"label label-default flex-item-right-sm\">\n                  <span translate>\n                    No versions\n                  </span>\n                </span>\n              </ng-template>\n              <ng-template ngPluralCase=\"=1\">\n                <span class=\"label label-info flex-item-right-sm\">\n                  <span translate>\n                    1 version\n                  </span>\n                </span>\n              </ng-template>\n              <ng-template ngPluralCase=\"other\">\n                <span class=\"label label-info flex-item-right-sm\">\n                  <span\n                    ngNonBindable\n                    translate\n                    [translateParams]=\"{ count: getBaseVersionsCount$(firmware) | async }\"\n                  >\n                    {{ count }} versions\n                  </span>\n                </span>\n              </ng-template>\n            </span>\n          </span>\n        </span>\n      </div>\n    </c8y-li-body>\n\n    <c8y-li-action\n      (click)=\"editFirmware(firmware)\"\n      icon=\"pencil\"\n    >\n      {{ 'Edit' | translate }}\n    </c8y-li-action>\n\n    <c8y-li-action\n      (click)=\"deleteFirmware(firmware)\"\n      icon=\"trash\"\n    >\n      {{ 'Delete' | translate }}\n    </c8y-li-action>\n  </c8y-li>\n</c8y-list-group>\n"
                },] }
    ];
    FirmwareListComponent.ctorParameters = function () { return [
        { type: RepositoryService },
        { type: ngxComponents.ModalService },
        { type: modal.BsModalService },
        { type: core$1.TranslateService },
        { type: ngxComponents.AlertService },
        { type: router.Router },
        { type: router.ActivatedRoute }
    ]; };
    __decorate([
        ngxComponents.memoize(lodashEs.property('id'))
    ], FirmwareListComponent.prototype, "getBaseVersionsCount$", null);

    var RepositoryNavigationFactory = /** @class */ (function () {
        function RepositoryNavigationFactory() {
            this.navs = [];
        }
        RepositoryNavigationFactory.prototype.get = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (this.navs.length === 0) {
                        this.navs.push(new ngxComponents.NavigatorNode({
                            label: ngxComponents.gettext('Firmware repository'),
                            path: 'firmware',
                            icon: 'c8y-firmware',
                            parent: ngxComponents.gettext('Management'),
                            priority: 1000
                        }));
                        this.navs.push(new ngxComponents.NavigatorNode({
                            label: ngxComponents.gettext('Software repository'),
                            path: 'software',
                            icon: 'c8y-tools',
                            parent: ngxComponents.gettext('Management'),
                            priority: 900
                        }));
                        this.navs.push(new ngxComponents.NavigatorNode({
                            label: ngxComponents.gettext('Configuration repository'),
                            path: 'configuration',
                            icon: 'gears',
                            parent: ngxComponents.gettext('Management'),
                            priority: 800
                        }));
                    }
                    return [2 /*return*/, this.navs];
                });
            });
        };
        return RepositoryNavigationFactory;
    }());
    RepositoryNavigationFactory.decorators = [
        { type: core.Injectable }
    ];

    var AdvancedSoftwareService = /** @class */ (function (_super) {
        __extends(AdvancedSoftwareService, _super);
        function AdvancedSoftwareService(client, applicationService) {
            var _this = _super.call(this, client) || this;
            _this.applicationService = applicationService;
            _this.baseUrl = 'service/advanced-software';
            _this.listUrl = 'software';
            _this.propertyName = 'softwareList';
            return _this;
        }
        AdvancedSoftwareService.prototype.list = function (filter) {
            if (filter === void 0) { filter = {}; }
            return _super.prototype.list.call(this, filter);
        };
        AdvancedSoftwareService.prototype.isASMAvailable = function () {
            if (this.isAvailable === undefined) {
                this.isAvailable = this.applicationService
                    .isAvailable(AdvancedSoftwareService.applicationName)
                    .then(function (result) { return !!(result === null || result === void 0 ? void 0 : result.data); });
            }
            return this.isAvailable;
        };
        return AdvancedSoftwareService;
    }(client.Service));
    AdvancedSoftwareService.applicationName = 'advanced-software-mgmt';
    AdvancedSoftwareService.decorators = [
        { type: core.Injectable }
    ];
    AdvancedSoftwareService.ctorParameters = function () { return [
        { type: client.FetchClient },
        { type: client.ApplicationService }
    ]; };

    var DeviceSoftwareChangesComponent = /** @class */ (function () {
        function DeviceSoftwareChangesComponent() {
            this.clear = new core.EventEmitter();
            this.drop = new core.EventEmitter();
            this.apply = new core.EventEmitter();
            this.hideSoftwareChanges = new core.EventEmitter();
            this.changes$ = new rxjs.BehaviorSubject([]);
            this.installations$ = this.changes$.pipe(operators.map(function (changes) {
                return changes.filter(function (change) { return change.action === 'install'; });
            }));
            this.removals$ = this.changes$.pipe(operators.map(function (changes) {
                return changes.filter(function (change) { return change.action === 'delete'; });
            }));
        }
        DeviceSoftwareChangesComponent.prototype.ngOnChanges = function (changes) {
            if (changes.changes) {
                this.changes$.next(changes.changes.currentValue);
            }
        };
        return DeviceSoftwareChangesComponent;
    }());
    DeviceSoftwareChangesComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-device-software-changes',
                    template: "<div class=\"inner-scroll d-flex d-col\">\n  <div class=\"card-header separator sticky-top visible-sm visible-xs\">\n    <button\n      class=\"btn btn-clean text-primary\"\n      [title]=\"'Back' | translate\"\n      (click)=\"hideSoftwareChanges.emit()\"\n    >\n      <i c8yIcon=\"chevron-left\"></i><span translate>Back</span>\n    </button>\n  </div>\n  <div class=\"card-header separator large-padding sticky-top\">\n    <h4 class=\"card-title\" translate>Software changes</h4>\n  </div>\n  <div id=\"software-changes-list\" class=\"flex-grow inner-scroll\">\n    <div class=\"card-block large-padding\" *ngIf=\"(changes$ | async).length === 0; else changesList\">\n      <div class=\"c8y-empty-state text-center\">\n        <h1 class=\"c8y-icon c8y-icon-device-control c8y-icon-duocolor\"></h1>\n        <p>\n          <strong translate>No software changes.</strong> <br />\n          <small translate>Selected actions will be displayed here.</small>\n        </p>\n      </div>\n    </div>\n\n    <ng-template #changesList>\n      <fieldset\n        class=\"card-block p-t-0 p-b-0\"\n        *ngIf=\"(installations$ | async).length > 0\"\n        [disabled]=\"changesInProgress\"\n      >\n        <div class=\"form-block legend\" translate>Installations`software`</div>\n        <c8y-device-software-list\n          [softwareList]=\"installations$ | async\"\n          (remove)=\"drop.emit($event)\"\n        ></c8y-device-software-list>\n      </fieldset>\n\n      <fieldset\n        class=\"card-block p-t-0 p-b-0\"\n        *ngIf=\"(removals$ | async).length > 0\"\n        [disabled]=\"changesInProgress\"\n      >\n        <div class=\"form-block legend\" translate>Removals`software`</div>\n        <c8y-device-software-list\n          [softwareList]=\"removals$ | async\"\n          (remove)=\"drop.emit($event)\"\n        ></c8y-device-software-list>\n      </fieldset>\n    </ng-template>\n  </div>\n  <div\n    class=\"card-footer separator large-padding sticky-bottom\"\n    *ngIf=\"(changes$ | async).length > 0\"\n  >\n    <button\n      class=\"btn btn-default\"\n      (click)=\"clear.emit()\"\n      title=\"{{ 'Clear changes' | translate }}\"\n      [disabled]=\"changesInProgress\"\n      translate\n    >\n      Clear`changes`\n    </button>\n    <button\n      class=\"btn btn-primary\"\n      [ngClass]=\"{ 'btn-pending': changesInProgress }\"\n      [disabled]=\"changesInProgress\"\n      (click)=\"apply.emit(); hideSoftwareChanges.emit()\"\n      title=\"{{ 'Apply changes' | translate }}\"\n      translate\n    >\n      Apply changes\n    </button>\n  </div>\n</div>\n"
                },] }
    ];
    DeviceSoftwareChangesComponent.propDecorators = {
        changes: [{ type: core.Input }],
        changesInProgress: [{ type: core.Input }],
        clear: [{ type: core.Output }],
        drop: [{ type: core.Output }],
        apply: [{ type: core.Output }],
        hideSoftwareChanges: [{ type: core.Output }]
    };

    var DeviceSoftwareListComponent = /** @class */ (function () {
        function DeviceSoftwareListComponent(advancedSoftwareService) {
            this.advancedSoftwareService = advancedSoftwareService;
            this.filterCriteria$ = rxjs.of(null);
            this.update = new core.EventEmitter();
            this.remove = new core.EventEmitter();
            this.onListEmpty = new core.EventEmitter();
            this.supportsSoftwareOperations = false;
            this.operationTypes = ['c8y_SoftwareUpdate', 'c8y_SoftwareList', 'c8y_Software'];
            this.legacySoftwareList$ = new rxjs.BehaviorSubject([]);
        }
        Object.defineProperty(DeviceSoftwareListComponent.prototype, "softwareList", {
            set: function (softwareList) {
                if (softwareList !== null) {
                    this.legacySoftwareList$.next(softwareList);
                }
            },
            enumerable: false,
            configurable: true
        });
        DeviceSoftwareListComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.softwareItems$ = rxjs.combineLatest(this.filterCriteria$, this.legacySoftwareList$).pipe(operators.debounceTime(300), operators.distinctUntilChanged(), operators.switchMap(function (_c) {
                var _d = __read(_c, 2), filterCriteria = _d[0], legacySoftwareList = _d[1];
                if (legacySoftwareList) {
                    return rxjs.of(_this.getLegacySoftwareList(filterCriteria)).pipe(operators.map(function (resultList) { return ({ resultList: resultList, filterCriteria: filterCriteria }); }));
                }
                else {
                    return _this.getAdvancedSoftwareList(filterCriteria).then(function (resultList) { return ({
                        resultList: resultList,
                        filterCriteria: filterCriteria
                    }); });
                }
            }), operators.tap(function (_c) {
                var resultList = _c.resultList, filterCriteria = _c.filterCriteria;
                var _a, _b;
                _this.notifyListEmpty(!((_a = resultList === null || resultList === void 0 ? void 0 : resultList.paging) === null || _a === void 0 ? void 0 : _a.totalPages) && !filterCriteria);
                _this.noSearchResults = !((_b = resultList === null || resultList === void 0 ? void 0 : resultList.paging) === null || _b === void 0 ? void 0 : _b.totalPages) && !!filterCriteria;
            }), operators.map(function (_c) {
                var resultList = _c.resultList;
                return resultList;
            }));
            var supportedOperations = lodashEs.get(this.device, 'c8y_SupportedOperations', []);
            this.supportsSoftwareOperations = this.operationTypes.some(function (operationType) { return supportedOperations.indexOf(operationType) > -1; });
        };
        DeviceSoftwareListComponent.prototype.ngAfterContentInit = function () {
            this.showUpdate = this.update.observers.length > 0;
            this.showRemove = this.remove.observers.length > 0;
        };
        DeviceSoftwareListComponent.prototype.isSoftwareGoingToBeChanged = function (software) {
            var relevantChanges = lodashEs.filter(this.deviceSoftwareChanges, software);
            return relevantChanges.length > 0;
        };
        DeviceSoftwareListComponent.prototype.getAdvancedSoftwareList = function (filterCriteria) {
            var queryFilter = { deviceId: this.device.id };
            if (filterCriteria === null || filterCriteria === void 0 ? void 0 : filterCriteria.name) {
                lodashEs.set(queryFilter, 'name', "*" + filterCriteria.name + "*");
            }
            if (filterCriteria === null || filterCriteria === void 0 ? void 0 : filterCriteria.softwareType) {
                lodashEs.set(queryFilter, 'type', "" + filterCriteria.softwareType);
            }
            return this.advancedSoftwareService.list(queryFilter);
        };
        DeviceSoftwareListComponent.prototype.getLegacySoftwareList = function (filterCriteria) {
            var data = filterCriteria
                ? this.legacySoftwareList$.value.filter(function (item) {
                    var _a;
                    var match = true;
                    if (filterCriteria === null || filterCriteria === void 0 ? void 0 : filterCriteria.name) {
                        match = match && ((_a = item.name) === null || _a === void 0 ? void 0 : _a.includes(filterCriteria.name));
                    }
                    if (filterCriteria === null || filterCriteria === void 0 ? void 0 : filterCriteria.softwareType) {
                        match = match && item.softwareType === filterCriteria.softwareType;
                    }
                    return match;
                })
                : this.legacySoftwareList$.value;
            return {
                data: data,
                res: null,
                paging: {
                    totalPages: data.length
                }
            };
        };
        DeviceSoftwareListComponent.prototype.notifyListEmpty = function (isEmpty) {
            this.emptyList = isEmpty;
            this.onListEmpty.emit(isEmpty);
        };
        return DeviceSoftwareListComponent;
    }());
    DeviceSoftwareListComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-device-software-list',
                    template: "<c8y-list-group class=\"no-border-last\">\n  <c8y-li\n    [ngClass]=\"{ disabled: isSoftwareGoingToBeChanged(software) }\"\n    *c8yFor=\"let software of softwareItems$\"\n  >\n    <!-- SOFTWARE ICON -->\n    <c8y-li-icon>\n      <i c8yIcon=\"c8y-tools\"></i>\n    </c8y-li-icon>\n\n    <c8y-li-body class=\"content-flex-20\">\n      <div title=\"{{ software.name }}\" class=\"col-8\">\n        <!-- SOFTWARE NAME -->\n        <p class=\"text-truncate\">\n          {{ software.name }}\n          <!-- SOFTWARE TYPE-->\n          <span class=\"label label-primary m-l-8\">{{ software.softwareType }}</span>\n        </p>\n        <!-- SOFTWARE VERSION -->\n        <p class=\"text-truncate\">\n          <span class=\"text-label-small m-r-4\" translate> Version </span>\n          <span title=\"{{ software.version }}\">\n            {{ software.version }}\n          </span>\n        </p>\n      </div>\n\n      <div\n        *ngIf=\"supportsSoftwareOperations && (showUpdate || showRemove)\"\n        class=\"col-4 text-right\"\n      >\n        <!-- UPDATE SOFTWARE -->\n        <button\n          *ngIf=\"showUpdate && !isSoftwareGoingToBeChanged(software)\"\n          class=\"btn btn-default btn-xs showOnHover\"\n          (click)=\"update.emit(software)\"\n          title=\"{{ 'Update`software,verb`' | translate }}\"\n          translate\n        >\n          Update\n        </button>\n\n        <!-- REMOVE SOFTWARE -->\n        <button\n          *ngIf=\"showRemove && !isSoftwareGoingToBeChanged(software)\"\n          title=\"{{ 'Remove`software`' | translate }}\"\n          class=\"showOnHover btn btn-dot pull-right\"\n          (click)=\"remove.emit(software)\"\n        >\n          <i c8yIcon=\"minus-circle\" class=\"text-danger\"></i>\n        </button>\n      </div>\n    </c8y-li-body>\n  </c8y-li>\n</c8y-list-group>\n<!-- NO SEARCH RESULTS STATE -->\n<div class=\"card-block\" *ngIf=\"noSearchResults || emptyList\">\n  <ng-content *ngIf=\"emptyList\" select=\".c8y-empty-state:not(.c8y-no-results-state)\"></ng-content>\n  <ng-content *ngIf=\"noSearchResults\" select=\".c8y-no-results-state\"></ng-content>\n</div>\n"
                },] }
    ];
    DeviceSoftwareListComponent.ctorParameters = function () { return [
        { type: AdvancedSoftwareService }
    ]; };
    DeviceSoftwareListComponent.propDecorators = {
        softwareList: [{ type: core.Input }],
        device: [{ type: core.Input }],
        deviceSoftwareChanges: [{ type: core.Input }],
        filterCriteria$: [{ type: core.Input }],
        update: [{ type: core.Output }],
        remove: [{ type: core.Output }],
        onListEmpty: [{ type: core.Output }]
    };

    var InstalledSoftwareComponent = /** @class */ (function () {
        function InstalledSoftwareComponent(repository, bsModal) {
            this.repository = repository;
            this.bsModal = bsModal;
            this.changes = new core.EventEmitter();
            this.showSoftwareChanges = new core.EventEmitter();
            this.showFilter = false;
            this.supportsSoftwareOperations = false;
            this.textFilter$ = new rxjs.BehaviorSubject('');
            this.softwareTypeFilter$ = new rxjs.BehaviorSubject('');
            this.operationTypes = ['c8y_SoftwareUpdate', 'c8y_SoftwareList', 'c8y_Software'];
            this.filterCriteria$ = rxjs.combineLatest(this.textFilter$, this.softwareTypeFilter$).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), textFilter = _b[0], softwareTypeFilter = _b[1];
                return ({
                    name: textFilter,
                    softwareType: softwareTypeFilter
                });
            }), operators.map(function (filterCriteria) { return !filterCriteria.name && !filterCriteria.softwareType ? null : filterCriteria; }));
        }
        InstalledSoftwareComponent.prototype.ngOnInit = function () {
            var supportedOperations = lodashEs.get(this.device, 'c8y_SupportedOperations', []);
            this.supportsSoftwareOperations = this.operationTypes.some(function (operationType) { return supportedOperations.indexOf(operationType) > -1; });
        };
        InstalledSoftwareComponent.prototype.installSoftware = function () {
            var _this = this;
            this.displaySoftwareSelectModal({
                title: ngxComponents.gettext('Install software'),
                labels: { ok: ngxComponents.gettext('Install') },
                repositoryEntriesWithVersions$: rxjs.of([]),
                repositoryEntriesWithVersionsFn$: function (modal) { return _this.getInstallableSoftwareListWithVersions$(modal.content.searchTerm); }
            }).subscribe(function (softwareToInstall) {
                _this.emitSoftwareInstall(softwareToInstall);
                _this.showSoftwareChanges.emit();
            });
        };
        InstalledSoftwareComponent.prototype.updateSoftware = function (softwareToRemove) {
            var _this = this;
            this.displaySoftwareSelectModal({
                title: ngxComponents.gettext('Update software'),
                labels: { ok: ngxComponents.gettext('Update') },
                showFilter: false,
                repositoryEntriesWithVersions$: this.getSingleSoftwareWithVersions$(softwareToRemove)
            }).subscribe(function (softwareToInstall) {
                _this.emitSoftwareInstall(softwareToInstall);
                _this.showSoftwareChanges.emit();
            });
        };
        InstalledSoftwareComponent.prototype.removeSoftware = function (softwareToRemove) {
            this.emitSoftwareRemoval([softwareToRemove]);
        };
        InstalledSoftwareComponent.prototype.getInstallableSoftwareListWithVersions$ = function (searchTerm$) {
            var _this = this;
            var installedSoftwareNames = (this.softwareList || []).map(function (s) { return s.name; });
            return searchTerm$.pipe(operators.distinctUntilChanged(), operators.switchMap(function (searchTerm) { return _this.repository.listRepositoryEntries(exports.RepositoryType.SOFTWARE, {
                query: _this.deviceTypeQuery,
                partialName: searchTerm,
                params: { pageSize: 100 }
            }); }), operators.map(function (_a) {
                var data = _a.data;
                return data;
            }), operators.map(function (softwareList) {
                return softwareList.filter(function (software) {
                    return !installedSoftwareNames.includes(software.name);
                });
            }), operators.map(function (softwareList) { return _this.attachVersions(softwareList); }), operators.shareReplay(1));
        };
        InstalledSoftwareComponent.prototype.getSingleSoftwareWithVersions$ = function (software) {
            var _this = this;
            return rxjs.from(this.repository.listRepositoryEntries(exports.RepositoryType.SOFTWARE, {
                query: { name: software.name }
            })).pipe(operators.map(function (_a) {
                var data = _a.data;
                return data;
            }), operators.map(function (softwareList) { return _this.attachVersions(softwareList); }), operators.shareReplay(1));
        };
        InstalledSoftwareComponent.prototype.attachVersions = function (softwareList) {
            var _this = this;
            softwareList.forEach(function (software) {
                software.versions = _this.repository.listBaseVersions(software);
            });
            return softwareList;
        };
        InstalledSoftwareComponent.prototype.displaySoftwareSelectModal = function (initialStateOverrides) {
            var initialState = Object.assign({ repositoryType: exports.RepositoryType.SOFTWARE, subTitle: ngxComponents.gettext('Available softwares matching the device type'), mode: ngxComponents.ModalSelectionMode.MULTI, icon: 'c8y-tools', disableSelected: false, selected: this.softwareList }, initialStateOverrides);
            var modal = this.bsModal.show(RepositorySelectModalComponent, {
                ignoreBackdropClick: true,
                class: 'modal-sm',
                initialState: initialState
            });
            if (initialStateOverrides.repositoryEntriesWithVersionsFn$) {
                modal.content.repositoryEntriesWithVersions$ =
                    initialStateOverrides.repositoryEntriesWithVersionsFn$(modal);
            }
            modal.content.load.next();
            return modal.content.resultEmitter;
        };
        InstalledSoftwareComponent.prototype.emitSoftwareInstall = function (items) {
            this.changes.emit(items.map(function (item) {
                return Object.assign(Object.assign({}, item), { action: 'install' });
            }));
        };
        InstalledSoftwareComponent.prototype.emitSoftwareRemoval = function (items) {
            this.changes.emit(items.map(function (item) {
                return Object.assign(Object.assign({}, item), { action: 'delete' });
            }));
        };
        return InstalledSoftwareComponent;
    }());
    InstalledSoftwareComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-installed-software',
                    template: "<div class=\"d-flex d-col flex-grow\">\n  <div class=\"card-header large-padding separator sticky-top\">\n    <h4 class=\"card-title\" translate>Installed software</h4>\n  </div>\n  <div class=\"flex-grow\">\n    <fieldset\n      id=\"operation-block\"\n      *ngIf=\"deviceSoftwareChangesOperation\"\n      class=\"card-block large-padding bg-gray-lighter\"\n    >\n      <c8y-single-operation [operation]=\"deviceSoftwareChangesOperation\"></c8y-single-operation>\n    </fieldset>\n    <fieldset class=\"card-block large-padding overflow-visible\" *ngIf=\"showFilter\">\n      <div class=\"row\">\n        <div class=\"col-xs-6\">\n          <div class=\"input-group input-group-search\">\n            <input\n              class=\"form-control\"\n              type=\"search\"\n              title=\"{{ 'Filter installed software\u2026' | translate }}\"\n              placeholder=\"{{ 'Filter installed software\u2026' | translate }}\"\n              [ngModel]=\"textFilter$ | async\"\n              (ngModelChange)=\"textFilter$.next($event)\"\n            />\n            <span class=\"input-group-addon\">\n              <i c8yIcon=\"search\" *ngIf=\"(textFilter$ | async).length === 0\"></i>\n              <i\n                class=\"text-muted\"\n                c8yIcon=\"times\"\n                *ngIf=\"(textFilter$ | async).length > 0\"\n                (click)=\"textFilter$.next('')\"\n              ></i>\n            </span>\n          </div>\n        </div>\n        <div class=\"col-xs-6\">\n          <c8y-software-type\n            [required]=\"false\"\n            [emitResultsOnly]=\"true\"\n            [showBtnInNotFoundMessage]=\"false\"\n            [allowFreeEntries]=\"false\"\n            [placeholder]=\"'Filter by software type\u2026' | translate\"\n            (onSelectSoftware)=\"softwareTypeFilter$.next($event?.softwareType)\"\n          ></c8y-software-type>\n        </div>\n      </div>\n    </fieldset>\n\n    <fieldset\n      id=\"software-list\"\n      class=\"flex-grow inner-scroll\"\n      [disabled]=\"deviceSoftwareChangesInProgress\"\n    >\n      <!-- NOT EMPTY STATE -->\n      <c8y-device-software-list\n        [device]=\"device\"\n        [filterCriteria$]=\"filterCriteria$\"\n        [softwareList]=\"softwareList\"\n        [deviceSoftwareChanges]=\"deviceSoftwareChanges\"\n        (update)=\"updateSoftware($event)\"\n        (remove)=\"removeSoftware($event)\"\n        (onListEmpty)=\"showFilter = !$event\"\n        class=\"d-block p-l-16 p-r-16\"\n      >\n        <!-- EMPTY STATE -->\n        <div class=\"c8y-empty-state text-center m-t-16\">\n          <h1 class=\"c8y-icon c8y-icon-tools c8y-icon-duocolor\"></h1>\n          <p>\n            <strong translate>No software installed.</strong> <br />\n            <small translate>Click below to install software into this device.</small>\n          </p>\n        </div>\n        <!-- NO SEARCH RESULTS STATE -->\n        <div class=\"c8y-empty-state c8y-no-results-state text-center m-t-16\">\n          <h1 class=\"c8y-icon c8y-icon-tools c8y-icon-duocolor\"></h1>\n          <p>\n            <strong translate>No software matches your filter criteria.</strong> <br />\n            <small translate>Try changing your search criteria.</small>\n          </p>\n        </div>\n      </c8y-device-software-list>\n    </fieldset>\n  </div>\n  <!-- INSTALL SOFTWARE-->\n  <div\n    class=\"card-footer large-padding separator sticky-bottom d-flex j-c-between\"\n    [ngClass]=\"{ 'visible-sm visible-xs': !supportsSoftwareOperations }\"\n  >\n    <button\n      *ngIf=\"supportsSoftwareOperations\"\n      class=\"btn btn-default\"\n      title=\"{{ 'Install software' | translate }}\"\n      (click)=\"installSoftware()\"\n      [disabled]=\"deviceSoftwareChangesInProgress\"\n    >\n      <i c8yIcon=\"plus-circle\"></i>\n      {{ 'Install software' | translate }}\n    </button>\n    <button\n      (click)=\"showSoftwareChanges.emit()\"\n      class=\"btn btn-clean text-primary visible-sm visible-xs\"\n      [title]=\"'Show &quot;Software changes&quot;' | translate\"\n    >\n      <span translate>Show \"Software changes\"</span>\n      <i c8yIcon=\"chevron-right\"></i>\n    </button>\n  </div>\n</div>\n"
                },] }
    ];
    InstalledSoftwareComponent.ctorParameters = function () { return [
        { type: RepositoryService },
        { type: modal.BsModalService }
    ]; };
    InstalledSoftwareComponent.propDecorators = {
        device: [{ type: core.Input }],
        softwareList: [{ type: core.Input }],
        deviceSoftwareChanges: [{ type: core.Input }],
        deviceSoftwareChangesOperation: [{ type: core.Input }],
        deviceSoftwareChangesInProgress: [{ type: core.Input }],
        deviceTypeQuery: [{ type: core.Input }],
        changes: [{ type: core.Output }],
        showSoftwareChanges: [{ type: core.Output }]
    };

    var SoftwareDeviceTabComponent = /** @class */ (function () {
        function SoftwareDeviceTabComponent(route, repository, inventory, advancedSoftwareService) {
            var _this = this;
            this.route = route;
            this.repository = repository;
            this.inventory = inventory;
            this.advancedSoftwareService = advancedSoftwareService;
            this.deviceId = this.route.snapshot.parent.data.contextData.id;
            this.device$ = new rxjs.BehaviorSubject(this.route.snapshot.parent.data.contextData);
            this.deviceTypeQuery$ = this.device$.pipe(operators.map(function (device) { return _this.repository.getDeviceTypeQuery(exports.RepositoryType.SOFTWARE, device); }));
            this.list$ = this.device$.pipe(operators.switchMap(function (device) { return _this.advancedSoftwareService
                .isASMAvailable()
                .then(function (isASMAvailable) { return ({ isASMAvailable: isASMAvailable, device: device }); }); }), operators.map(function (_a) {
                var isASMAvailable = _a.isASMAvailable, device = _a.device;
                // with ASM available software items will be retrieved directly in the
                // device-software-list component
                return isASMAvailable ? undefined : _this.repository.getDeviceSoftwareList(device);
            }));
            this.changes$ = new rxjs.BehaviorSubject([]);
            this.changesOperation$ = new rxjs.BehaviorSubject(null);
            this.changesInProgress$ = this.changesOperation$.pipe(operators.map(function (operation) { return _this.isInProgress(operation); }));
            this.reloading = false;
            this.showSoftwareChanges = false;
        }
        SoftwareDeviceTabComponent.prototype.ngOnInit = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.loadDevice()];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.loadOperation()];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        SoftwareDeviceTabComponent.prototype.addChanges = function (requestedChanges) {
            var _this = this;
            var stagedChanges = __spreadArray([], __read(this.changes$.value));
            requestedChanges.forEach(function (requestedChange) {
                var alreadyStaged = stagedChanges.some(function (stagedChange) { return _this.areSameChanges(stagedChange, requestedChange); });
                if (!alreadyStaged) {
                    stagedChanges = __spreadArray(__spreadArray([], __read(stagedChanges)), [requestedChange]);
                }
            });
            this.changes$.next(stagedChanges);
        };
        SoftwareDeviceTabComponent.prototype.dropChange = function (changeToBeDropped) {
            var _this = this;
            var stagedChanges = __spreadArray([], __read(this.changes$.value));
            stagedChanges = stagedChanges.filter(function (stagedChange) { return !_this.areSameChanges(stagedChange, changeToBeDropped); });
            this.changes$.next(stagedChanges);
        };
        SoftwareDeviceTabComponent.prototype.areSameChanges = function (change1, change2) {
            return change1.name === change2.name &&
                change1.version === change2.version &&
                change1.action === change2.action;
        };
        SoftwareDeviceTabComponent.prototype.clearChanges = function () {
            this.changes$.next([]);
        };
        SoftwareDeviceTabComponent.prototype.loadDevice = function () {
            return __awaiter(this, void 0, void 0, function () {
                var device;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.reloading = true;
                            return [4 /*yield*/, this.inventory.detail(this.deviceId, { withChildren: false })];
                        case 1:
                            device = (_a.sent()).data;
                            this.device$.next(device);
                            this.reloading = false;
                            return [2 /*return*/];
                    }
                });
            });
        };
        SoftwareDeviceTabComponent.prototype.applyChanges = function () {
            return __awaiter(this, void 0, void 0, function () {
                var operation;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.repository.createSoftwareUpdateOperation(this.device$.value, this.changes$.value)];
                        case 1:
                            operation = _a.sent();
                            this.trackOperation(operation);
                            return [2 /*return*/];
                    }
                });
            });
        };
        SoftwareDeviceTabComponent.prototype.loadOperation = function () {
            return __awaiter(this, void 0, void 0, function () {
                var operation;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.repository.getLastSoftwareUpdateOperation(this.deviceId)];
                        case 1:
                            operation = _a.sent();
                            this.trackOperation(operation);
                            return [2 /*return*/];
                    }
                });
            });
        };
        SoftwareDeviceTabComponent.prototype.trackOperation = function (operation) {
            var _this = this;
            this.changesOperation$.next(operation);
            if (this.isInProgress(operation)) {
                this.displayChangesFromOperation(operation);
                this.repository.observeOperation(operation).subscribe(function (operationUpdate) {
                    _this.changesOperation$.next(operationUpdate);
                    if (operationUpdate.status === client.OperationStatus.SUCCESSFUL) {
                        _this.clearChanges();
                        _this.loadDevice();
                    }
                }, function (operationUpdate) {
                    _this.changesOperation$.next(operationUpdate);
                });
            }
        };
        SoftwareDeviceTabComponent.prototype.displayChangesFromOperation = function (operation) {
            var changes = this.repository.getDeviceSoftwareChangesFromOperation(operation, this.device$.value);
            this.changes$.next(changes);
        };
        SoftwareDeviceTabComponent.prototype.isInProgress = function (operation) {
            return (operation && [client.OperationStatus.PENDING, client.OperationStatus.EXECUTING].includes(operation.status));
        };
        return SoftwareDeviceTabComponent;
    }());
    SoftwareDeviceTabComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-software-device-tab',
                    template: "<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\" title=\"{{ 'Reload' | translate }}\" (click)=\"loadDevice()\">\n    <i c8yIcon=\"refresh\" [ngClass]=\"{ 'icon-spin': reloading }\"></i>\n    {{ 'Reload' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<div class=\"card split-view--8-4 m-b-0\">\n  <c8y-installed-software\n    class=\"split-view__list\"\n    [device]=\"device$ | async\"\n    [deviceTypeQuery]=\"deviceTypeQuery$ | async\"\n    [softwareList]=\"list$ | async\"\n    [deviceSoftwareChanges]=\"changes$ | async\"\n    [deviceSoftwareChangesOperation]=\"changesOperation$ | async\"\n    [deviceSoftwareChangesInProgress]=\"changesInProgress$ | async\"\n    (changes)=\"addChanges($event)\"\n    (showSoftwareChanges)=\"showSoftwareChanges = true\"\n  ></c8y-installed-software>\n  <c8y-device-software-changes\n    class=\"bg-gray-white split-view__detail\"\n    [ngClass]=\"{ 'split-view__detail--selected': showSoftwareChanges }\"\n    [changes]=\"changes$ | async\"\n    [changesInProgress]=\"changesInProgress$ | async\"\n    (clear)=\"clearChanges()\"\n    (drop)=\"dropChange($event)\"\n    (apply)=\"applyChanges()\"\n    (hideSoftwareChanges)=\"showSoftwareChanges = false\"\n  ></c8y-device-software-changes>\n</div>\n"
                },] }
    ];
    SoftwareDeviceTabComponent.ctorParameters = function () { return [
        { type: router.ActivatedRoute },
        { type: RepositoryService },
        { type: client.InventoryService },
        { type: AdvancedSoftwareService }
    ]; };

    var SoftwareDeviceTabGuard = /** @class */ (function () {
        function SoftwareDeviceTabGuard() {
            this.operations = ['c8y_SoftwareUpdate', 'c8y_SoftwareList', 'c8y_Software'];
        }
        SoftwareDeviceTabGuard.prototype.canActivate = function (route) {
            var device = lodashEs.get(route, 'data.contextData') || lodashEs.get(route, 'parent.data.contextData');
            return (this.isAnyOperationSupported(device) ||
                lodashEs.has(device, 'c8y_Software') ||
                lodashEs.has(device, 'c8y_SoftwareList') ||
                lodashEs.has(device, 'c8y_SupportedSoftwareTypes'));
        };
        SoftwareDeviceTabGuard.prototype.isAnyOperationSupported = function (device) {
            var supportedOperations = (device === null || device === void 0 ? void 0 : device.c8y_SupportedOperations) || [];
            return this.operations.some(function (operation) { return supportedOperations.indexOf(operation) >= 0; });
        };
        return SoftwareDeviceTabGuard;
    }());
    SoftwareDeviceTabGuard.decorators = [
        { type: core.Injectable }
    ];

    var AddSoftwareModalComponent = /** @class */ (function () {
        function AddSoftwareModalComponent(modal, repositoryService, alert) {
            this.modal = modal;
            this.repositoryService = repositoryService;
            this.alert = alert;
            this.saved = new core.EventEmitter();
            this.onInput = new rxjs.BehaviorSubject('');
            this.model = {
                selected: undefined,
                version: undefined,
                description: undefined,
                deviceType: undefined,
                softwareType: undefined,
                binary: {
                    file: undefined,
                    url: undefined
                }
            };
            this.saving = false;
            this.softwarePreselected = false;
            this.textForSoftwareUrlPopover = ngxComponents.gettext("Path for binaries can vary depending on device agent implementation, e.g.:\n    /software/binaries/software1.bin\n    https://software/binary/123\n    ftp://software/binary/123.tar.gz\n  ");
        }
        AddSoftwareModalComponent.prototype.ngOnInit = function () {
            this.setInitialState();
            this.loadSoftwares();
        };
        AddSoftwareModalComponent.prototype.setInitialState = function () {
            if (this.model.selected) {
                this.softwarePreselected = true;
            }
        };
        AddSoftwareModalComponent.prototype.loadSoftwares = function () {
            var _this = this;
            this.inputSubscription$ = this.onInput
                .pipe(operators.tap(function () {
                if (!_this.softwarePreselected) {
                    _this.model.description = null;
                    if (_this.form) {
                        _this.form.form.get('description').reset();
                    }
                }
            }), operators.debounceTime(300), operators.distinctUntilChanged(), operators.switchMap(function (searchStr) { return _this.getSoftwareResult(searchStr); }))
                .subscribe(function (result) {
                _this.softwaresResult = result;
            });
        };
        AddSoftwareModalComponent.prototype.getSoftwareResult = function (searchStr) {
            return rxjs.from(this.repositoryService.listRepositoryEntries(exports.RepositoryType.SOFTWARE, {
                partialName: searchStr,
                skipLegacy: true
            }));
        };
        AddSoftwareModalComponent.prototype.save = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    this.saving = true;
                    this.repositoryService
                        .create(this.model, exports.RepositoryType.SOFTWARE)
                        .then(function (savedSoftware) {
                        _this.successMsg();
                        _this.saving = false;
                        _this.saved.next(savedSoftware);
                        _this.cancel();
                    })
                        .catch(function (e) {
                        _this.saving = false;
                        _this.saved.error(e);
                        _this.cancel();
                    });
                    return [2 /*return*/];
                });
            });
        };
        AddSoftwareModalComponent.prototype.successMsg = function () {
            var msg = ngxComponents.gettext('Software added.');
            this.alert.success(msg);
        };
        AddSoftwareModalComponent.prototype.cancel = function () {
            this.modal.hide();
            this.saved.complete();
        };
        AddSoftwareModalComponent.prototype.ngOnDestroy = function () {
            this.inputSubscription$.unsubscribe();
        };
        AddSoftwareModalComponent.prototype.onFile = function (dropped) {
            if (!lodashEs.isUndefined(dropped.url)) {
                this.model.binary = {
                    url: dropped.url
                };
                return;
            }
            else if (!lodashEs.isUndefined(dropped.droppedFiles)) {
                this.model.binary = {
                    file: dropped.droppedFiles[0].file
                };
                return;
            }
            else {
                this.model.binary = {
                    file: undefined,
                    url: undefined
                };
            }
        };
        AddSoftwareModalComponent.prototype.onSoftwareSelect = function (software) {
            lodashEs.assign(this.model, {
                selected: software,
                description: software.description,
                deviceType: lodashEs.get(software, 'c8y_Filter.type'),
                softwareType: software
            });
        };
        return AddSoftwareModalComponent;
    }());
    AddSoftwareModalComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-add-software-software-modal',
                    template: "<div class=\"viewport-modal\">\n  <div class=\"modal-header dialog-header\">\n    <i [c8yIcon]=\"'c8y-tools'\"></i>\n    <h4 translate>Add software</h4>\n  </div>\n  <div class=\"p-16 text-center separator-bottom\" *ngIf=\"!softwarePreselected\">\n    <p class=\"lead m-0\" translate>Select or create new software</p>\n  </div>\n  <form\n    class=\"d-contents\"\n    autocomplete=\"off\"\n    #softwareForm=\"ngForm\"\n    (ngSubmit)=\"softwareForm.form.valid && save()\"\n  >\n    <div class=\"modal-inner-scroll\">\n      <div class=\"modal-body\">\n        <div [hidden]=\"softwarePreselected\">\n          <c8y-form-group>\n            <label for=\"softwareName\" translate>Software</label>\n            <c8y-typeahead\n              [(ngModel)]=\"model.selected\"\n              name=\"softwareName\"\n              placeholder=\"{{ 'Select or enter' | translate }}\"\n              (onSearch)=\"onInput.next($event)\"\n              [required]=\"true\"\n            >\n              <c8y-li\n                *c8yFor=\"\n                  let software of softwaresResult;\n                  loadMore: 'auto';\n                  notFound: notFoundTemplate\n                \"\n                class=\"p-l-8 p-r-8 c8y-list__item--link\"\n                (click)=\"onSoftwareSelect(software)\"\n                [active]=\"model.selected === software\"\n              >\n                <c8y-highlight\n                  [text]=\"software.name || '--'\"\n                  [pattern]=\"onInput | async\"\n                ></c8y-highlight>\n              </c8y-li>\n              <ng-template #notFoundTemplate>\n                <c8y-li class=\"bg-gray-lighter p-8\" *ngIf=\"(onInput | async)?.length > 0\">\n                  <span translate>No match found.</span>\n                  <button\n                    title=\"{{ 'Add new`software`' | translate }}\"\n                    type=\"button\"\n                    class=\"btn btn-primary btn-xs m-l-16\"\n                    translate\n                  >\n                    Add new`software`\n                  </button>\n                </c8y-li>\n              </ng-template>\n            </c8y-typeahead>\n          </c8y-form-group>\n\n          <c8y-form-group>\n            <label for=\"softwareDescription\" translate>Description</label>\n            <input\n              id=\"softwareDescription\"\n              class=\"form-control\"\n              autocomplete=\"off\"\n              name=\"description\"\n              [(ngModel)]=\"model.description\"\n              placeholder=\"{{ 'e.g. Cloud connectivity software' | translate }}\"\n              [disabled]=\"model.selected?.id\"\n              [required]=\"true\"\n            />\n          </c8y-form-group>\n\n          <c8y-form-group>\n            <label class=\"control-label\" for=\"softwareDeviceTypeFilter\">\n              {{ 'Device type filter' | translate }}\n              <button\n                class=\"btn btn-clean text-primary\"\n                popover=\"{{\n                  'If the filter is set, the software will show up for installation only for devices of that type. If no filter is set, it will be available for all devices.'\n                    | translate\n                }}\"\n                triggers=\"focus\"\n                container=\"body\"\n                placement=\"right\"\n              >\n                <i [c8yIcon]=\"'question-circle-o'\"></i>\n              </button>\n            </label>\n            <input\n              id=\"softwareDeviceTypeFilter\"\n              class=\"form-control\"\n              name=\"softwareDeviceTypeFilter\"\n              [(ngModel)]=\"model.deviceType\"\n              placeholder=\"{{ 'e.g.' | translate }} c8y_Linux\"\n              [disabled]=\"model.selected?.id\"\n            />\n          </c8y-form-group>\n\n          <c8y-form-group>\n            <label for=\"softwareType\" translate>Software type</label>\n            <c8y-software-type\n              [softwareTypeMO]=\"model.softwareType\"\n              [disabled]=\"model.selected?.id\"\n              (onSelectSoftware)=\"model.softwareType = $event\"\n            >\n            </c8y-software-type>\n          </c8y-form-group>\n        </div>\n\n        <c8y-form-group>\n          <label for=\"softwareVersion\" translate>Version</label>\n          <input\n            id=\"softwareVersion\"\n            class=\"form-control\"\n            autocomplete=\"off\"\n            name=\"version\"\n            [(ngModel)]=\"model.version\"\n            placeholder=\"{{ 'e.g.' | translate }} 1.0.0\"\n            [required]=\"true\"\n          />\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <div class=\"legend form-block m-t-40\" translate>Software file</div>\n          <c8y-file-picker\n            [maxAllowedFiles]=\"1\"\n            (onFilesPicked)=\"onFile($event)\"\n            [fileUrlPopover]=\"textForSoftwareUrlPopover\"\n          >\n          </c8y-file-picker>\n        </c8y-form-group>\n      </div>\n    </div>\n    <div class=\"modal-footer\">\n      <button\n        title=\"{{ 'Cancel' | translate }}\"\n        class=\"btn btn-default\"\n        type=\"button\"\n        (click)=\"cancel()\"\n        [disabled]=\"saving\"\n        translate\n      >\n        Cancel\n      </button>\n\n      <button\n        title=\"{{ 'Add software' | translate }}\"\n        class=\"btn btn-primary\"\n        type=\"submit\"\n        [ngClass]=\"{ 'btn-pending': saving }\"\n        [disabled]=\"\n          !softwareForm.form.valid ||\n          softwareForm.form.pristine ||\n          saving ||\n          (!model.binary?.url && !model.binary?.file)\n        \"\n        translate\n      >\n        Add software\n      </button>\n    </div>\n  </form>\n</div>\n"
                },] }
    ];
    AddSoftwareModalComponent.ctorParameters = function () { return [
        { type: modal.BsModalRef },
        { type: RepositoryService },
        { type: ngxComponents.AlertService }
    ]; };
    AddSoftwareModalComponent.propDecorators = {
        form: [{ type: core.ViewChild, args: ['softwareForm', { static: false },] }],
        saved: [{ type: core.Output }]
    };

    var DeviceTypeCellRendererComponent = /** @class */ (function () {
        function DeviceTypeCellRendererComponent(context) {
            this.context = context;
        }
        return DeviceTypeCellRendererComponent;
    }());
    DeviceTypeCellRendererComponent.decorators = [
        { type: core.Component, args: [{
                    template: "<span *ngIf=\"context.item.c8y_Filter?.type; else emptyText\">\n  {{ context.item.c8y_Filter?.type }}\n</span>\n<ng-template #emptyText>\n  <small class=\"text-muted\">\n    <em translate>Undefined`device type`</em>\n  </small>\n</ng-template>\n"
                },] }
    ];
    DeviceTypeCellRendererComponent.ctorParameters = function () { return [
        { type: ngxComponents.CellRendererContext }
    ]; };

    var NameCellRendererComponent = /** @class */ (function () {
        function NameCellRendererComponent(context) {
            this.context = context;
        }
        return NameCellRendererComponent;
    }());
    NameCellRendererComponent.decorators = [
        { type: core.Component, args: [{
                    template: "\n    <a [routerLink]=\"[context.item.id]\" [title]=\"context.item.name\" class=\"interact\">\n      {{ context.item.name }}\n    </a>\n  "
                },] }
    ];
    NameCellRendererComponent.ctorParameters = function () { return [
        { type: ngxComponents.CellRendererContext }
    ]; };

    var SoftwareTypeCellRendererComponent = /** @class */ (function () {
        function SoftwareTypeCellRendererComponent(context) {
            this.context = context;
        }
        return SoftwareTypeCellRendererComponent;
    }());
    SoftwareTypeCellRendererComponent.decorators = [
        { type: core.Component, args: [{
                    template: "<span *ngIf=\"!!context?.item?.softwareType; else emptyText\" class=\"label label-info\">{{\n  context.item.softwareType\n}}</span>\n<ng-template #emptyText>\n  <small class=\"text-muted\">\n    <em translate>Undefined`software type`</em>\n  </small> </ng-template\n>`\n"
                },] }
    ];
    SoftwareTypeCellRendererComponent.ctorParameters = function () { return [
        { type: ngxComponents.CellRendererContext }
    ]; };

    var SoftwareTypeFilteringFormRendererComponent = /** @class */ (function () {
        function SoftwareTypeFilteringFormRendererComponent(context, changeDetectorRef, repositoryService, elementRef) {
            var _this = this;
            this.context = context;
            this.changeDetectorRef = changeDetectorRef;
            this.repositoryService = repositoryService;
            this.elementRef = elementRef;
            this.softwareWithType$ = rxjs.NEVER;
            this.search$ = new rxjs.BehaviorSubject(null);
            this.filterPipe = rxjs.pipe(operators.tap());
            this.typeaheadPlaceholder = ngxComponents.gettext('Start typing to search, e.g. {{ example }}');
            this.queriesUtil = new client.QueriesUtil();
            this.softwareTypes = new Set();
            this.softwareWithType$ = this.search$.pipe(operators.debounceTime(300), operators.tap(function () { return _this.softwareTypes.clear(); }), operators.switchMap(function (searchString) {
                var query = _this.queriesUtil.prependOrderbys({}, [{ softwareType: 1 }]);
                var filter = !!searchString
                    ? {
                        softwareType: {
                            __eq: "*" + searchString + "*"
                        }
                    }
                    : {
                        __has: 'softwareType'
                    };
                query = _this.queriesUtil.addAndFilter(query, filter);
                return _this.repositoryService.listRepositoryEntries(exports.RepositoryType.SOFTWARE, {
                    skipDefaultOrder: true,
                    query: query,
                    params: {
                        pageSize: 200
                    }
                });
            }));
            this.filterPipe = rxjs.pipe(operators.map(this.removeDuplicatesBySoftwareType.bind(this)), operators.tap(function () { return _this.changeDetectorRef.detectChanges(); }));
        }
        SoftwareTypeFilteringFormRendererComponent.prototype.onEnterKeyDown = function (event) {
            event.stopPropagation();
            this.applyFilter();
        };
        SoftwareTypeFilteringFormRendererComponent.prototype.onEscapeKeyDown = function (event) {
            event.stopPropagation();
            this.context.resetFilter();
        };
        SoftwareTypeFilteringFormRendererComponent.prototype.ngOnInit = function () {
            var column = this.context.property;
            this.selectedType = lodashEs.cloneDeep(column.externalFilterQuery || {});
        };
        SoftwareTypeFilteringFormRendererComponent.prototype.ngAfterViewInit = function () {
            var _a, _b, _c;
            (_c = (_b = (_a = this.typeahead) === null || _a === void 0 ? void 0 : _a.searchControl) === null || _b === void 0 ? void 0 : _b.nativeElement) === null || _c === void 0 ? void 0 : _c.focus();
            try {
                this.elementRef.nativeElement.parentElement.parentElement.style.overflow = 'visible';
            }
            catch (ex) {
                // intentionally empty
            }
        };
        SoftwareTypeFilteringFormRendererComponent.prototype.applyFilter = function () {
            this.context.applyFilter({
                externalFilterQuery: this.selectedType
            });
        };
        SoftwareTypeFilteringFormRendererComponent.prototype.removeDuplicatesBySoftwareType = function (list) {
            var _this = this;
            var uniqueBySoftwareType = lodashEs.uniqBy(list, 'softwareType').filter(function (sw) { return !_this.softwareTypes.has(sw.softwareType); });
            uniqueBySoftwareType.forEach(function (sw) { return _this.softwareTypes.add(sw.softwareType); });
            return uniqueBySoftwareType;
        };
        return SoftwareTypeFilteringFormRendererComponent;
    }());
    SoftwareTypeFilteringFormRendererComponent.decorators = [
        { type: core.Component, args: [{
                    template: "<c8y-form-group>\n  <label translate>Filter by software type</label>\n  <c8y-typeahead\n    [(ngModel)]=\"selectedType\"\n    name=\"softwareType\"\n    placeholder=\"{{ typeaheadPlaceholder | translate: { example: 'yum' } }}\"\n    displayProperty=\"softwareType\"\n    (onSearch)=\"search$.next($event)\"\n  >\n    <c8y-li\n      *c8yFor=\"let software of softwareWithType$; pipe: filterPipe; loadMore: 'auto'\"\n      class=\"p-l-8 p-r-8 c8y-list__item--link\"\n      (click)=\"\n        selectedType = software; typeahead.dropdown.hide(); changeDetectorRef.detectChanges()\n      \"\n      [active]=\"selectedType?.softwareType === software?.softwareType\"\n    >\n      <c8y-highlight\n        [text]=\"software?.softwareType || '--'\"\n        [pattern]=\"search$.value\"\n      ></c8y-highlight>\n    </c8y-li>\n  </c8y-typeahead>\n</c8y-form-group>\n\n<div class=\"data-grid__dropdown__footer d-flex separator-top\">\n  <button\n    class=\"btn btn-default btn-sm m-r-8 flex-grow\"\n    (click)=\"context.resetFilter()\"\n    title=\"{{ 'Reset' | translate }}\"\n    translate\n  >\n    Reset\n  </button>\n\n  <button\n    class=\"btn btn-primary btn-sm flex-grow\"\n    (click)=\"applyFilter()\"\n    title=\"{{ 'Apply' | translate }}\"\n    translate\n  >\n    Apply\n  </button>\n</div>\n",
                    changeDetection: core.ChangeDetectionStrategy.Default
                },] }
    ];
    SoftwareTypeFilteringFormRendererComponent.ctorParameters = function () { return [
        { type: ngxComponents.FilteringFormRendererContext },
        { type: core.ChangeDetectorRef },
        { type: RepositoryService },
        { type: core.ElementRef }
    ]; };
    SoftwareTypeFilteringFormRendererComponent.propDecorators = {
        typeahead: [{ type: core.ViewChild, args: [ngxComponents.TypeaheadComponent, { static: false },] }],
        onEnterKeyDown: [{ type: core.HostListener, args: ['keydown.enter', ['$event'],] }],
        onEscapeKeyDown: [{ type: core.HostListener, args: ['keydown.escape', ['$event'],] }]
    };

    var VersionsCellRendererComponent = /** @class */ (function () {
        function VersionsCellRendererComponent(context, repositoryService) {
            this.context = context;
            this.repositoryService = repositoryService;
            this.isLegacy = this.repositoryService.isLegacyEntry.bind(this.repositoryService);
            this.software = context.item;
        }
        VersionsCellRendererComponent.prototype.getBaseVersionsCount$ = function (software) {
            return this.repositoryService.getBaseVersionsCount$(software).pipe(operators.shareReplay(1));
        };
        return VersionsCellRendererComponent;
    }());
    VersionsCellRendererComponent.decorators = [
        { type: core.Component, args: [{
                    template: "<span class=\"label label-warning flex-item-right-sm\" *ngIf=\"isLegacy(software)\">\n  <span translate> Legacy </span>\n</span>\n<span *ngIf=\"!isLegacy(software)\">\n  <span *ngIf=\"(getBaseVersionsCount$(software) | async) === null\">\n    <span class=\"badge badge-info flex-item-right-sm\">\n      <i class=\"icon-spin\" c8yIcon=\"circle-o-notch\"></i>\n    </span>\n  </span>\n  <span *ngIf=\"(getBaseVersionsCount$(software) | async) !== null\">\n    <span class=\"badge badge-info flex-item-right-sm\">\n      {{ getBaseVersionsCount$(software) | async }}\n    </span>\n  </span>\n</span>\n"
                },] }
    ];
    VersionsCellRendererComponent.ctorParameters = function () { return [
        { type: ngxComponents.CellRendererContext },
        { type: RepositoryService }
    ]; };
    __decorate([
        ngxComponents.memoize(lodashEs.property('id'))
    ], VersionsCellRendererComponent.prototype, "getBaseVersionsCount$", null);

    var SoftwareTypeComponent = /** @class */ (function () {
        function SoftwareTypeComponent(repositoryService, changeDetectorRef, translateService) {
            var _this = this;
            this.repositoryService = repositoryService;
            this.changeDetectorRef = changeDetectorRef;
            this.translateService = translateService;
            this.required = true;
            this.placeholder = this.translateService.instant(ngxComponents.gettext('e.g. {{ example }}'), { example: 'yum' });
            this.emitResultsOnly = false;
            this.showBtnInNotFoundMessage = true;
            this.allowFreeEntries = true;
            this.onSelectSoftware = new core.EventEmitter();
            this.filterPipe = rxjs.pipe(operators.tap());
            this.search$ = new rxjs.BehaviorSubject(null);
            this.queriesUtil = new client.QueriesUtil();
            this.softwareTypes = new Set();
            this.softwaresResult$ = this.search$.pipe(operators.debounceTime(300), operators.tap(function () { return _this.softwareTypes.clear(); }), operators.switchMap(function (searchString) {
                if (!_this.emitResultsOnly || !searchString) {
                    _this.onSelectSoftware.emit(_this.softwareTypeMO);
                }
                return _this.getSoftwareByTypeResult(searchString);
            }));
            this.filterPipe = rxjs.pipe(operators.map(this.removeDuplicatesBySoftwareType.bind(this)));
        }
        SoftwareTypeComponent.prototype.ngOnInit = function () {
            this.notFoundTemplateToUse = this.showBtnInNotFoundMessage
                ? this.notFoundTypeAddNewTemplate
                : this.notFoundTypeTemplate;
        };
        SoftwareTypeComponent.prototype.getSoftwareByTypeResult = function (searchString) {
            var query = this.queriesUtil.prependOrderbys({}, [{ softwareType: 1 }]);
            var filter = !!searchString
                ? {
                    softwareType: {
                        __eq: "*" + searchString + "*"
                    }
                }
                : {
                    __has: 'softwareType'
                };
            query = this.queriesUtil.addAndFilter(query, filter);
            return this.repositoryService.listRepositoryEntries(exports.RepositoryType.SOFTWARE, {
                query: query,
                params: {
                    pageSize: 200
                }
            });
        };
        SoftwareTypeComponent.prototype.selectSoftware = function (software) {
            this.softwareTypeMO = software;
            this.onSelectSoftware.emit(software);
            this.deviceSoftwareTypeModel.searchControlModel.control.markAsDirty();
        };
        SoftwareTypeComponent.prototype.resetInput = function () {
            this.deviceSoftwareTypeModel.reset();
        };
        SoftwareTypeComponent.prototype.removeDuplicatesBySoftwareType = function (list) {
            var _this = this;
            var uniqueBySoftwareType = lodashEs.uniqBy(list, 'softwareType').filter(function (sw) { return !_this.softwareTypes.has(sw.softwareType); });
            uniqueBySoftwareType.forEach(function (sw) { return _this.softwareTypes.add(sw.softwareType); });
            return uniqueBySoftwareType;
        };
        return SoftwareTypeComponent;
    }());
    SoftwareTypeComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-software-type',
                    template: "<c8y-typeahead\n  [(ngModel)]=\"softwareTypeMO\"\n  [required]=\"required\"\n  [disabled]=\"disabled\"\n  name=\"softwareType\"\n  [placeholder]=\"placeholder\"\n  [allowFreeEntries]=\"allowFreeEntries\"\n  #deviceSoftwareTypeModel\n  (onSearch)=\"search$.next($event)\"\n  displayProperty=\"softwareType\"\n  [ngStyle]=\"style\"\n>\n  <c8y-li\n    *c8yFor=\"\n      let software of softwaresResult$;\n      pipe: filterPipe;\n      loadMore: 'auto';\n      notFound: notFoundTemplateToUse\n    \"\n    class=\"p-l-8 p-r-8 c8y-list__item--link\"\n    (click)=\"selectSoftware(software)\"\n    [active]=\"softwareTypeMO?.softwareType === software.softwareType\"\n  >\n    <c8y-highlight\n      [text]=\"software.softwareType || '--'\"\n      [pattern]=\"search$ | async\"\n    ></c8y-highlight>\n  </c8y-li>\n  <ng-template #notFoundTypeAddNewTemplate>\n    <c8y-li class=\"bg-gray-lighter p-8\" *ngIf=\"(search$ | async)?.length > 0\">\n      <span translate>No match found.</span>\n      <button\n        title=\"{{ 'Add new`software type`' | translate }}\"\n        type=\"button\"\n        class=\"btn btn-primary btn-xs m-l-16\"\n        translate\n      >\n        Add new`software type`\n      </button>\n    </c8y-li>\n  </ng-template>\n  <ng-template #notFoundTypeTemplate>\n    <c8y-li\n      class=\"bg-gray-lighter p-8\"\n      *ngIf=\"(search$ | async)?.length > 0 && (softwaresResult$ | async)?.data?.length === 0\"\n    >\n      <span translate>No match found. Refine your search terms or check your spelling.</span>\n    </c8y-li>\n  </ng-template>\n</c8y-typeahead>\n"
                },] }
    ];
    SoftwareTypeComponent.ctorParameters = function () { return [
        { type: RepositoryService },
        { type: core.ChangeDetectorRef },
        { type: core$1.TranslateService }
    ]; };
    SoftwareTypeComponent.propDecorators = {
        softwareTypeMO: [{ type: core.Input }],
        disabled: [{ type: core.Input }],
        style: [{ type: core.Input }],
        required: [{ type: core.Input }],
        placeholder: [{ type: core.Input }],
        emitResultsOnly: [{ type: core.Input }],
        showBtnInNotFoundMessage: [{ type: core.Input }],
        allowFreeEntries: [{ type: core.Input }],
        deviceSoftwareTypeModel: [{ type: core.ViewChild, args: ['deviceSoftwareTypeModel',] }],
        notFoundTypeAddNewTemplate: [{ type: core.ViewChild, args: ['notFoundTypeAddNewTemplate', { static: true },] }],
        notFoundTypeTemplate: [{ type: core.ViewChild, args: ['notFoundTypeTemplate', { static: true },] }],
        onSelectSoftware: [{ type: core.Output }]
    };

    var SoftwareDetailsComponent = /** @class */ (function () {
        function SoftwareDetailsComponent(activatedRoute, inventoryService, repositoryService, alertService, translateService, modalService, bsModalService) {
            var _this = this;
            this.activatedRoute = activatedRoute;
            this.inventoryService = inventoryService;
            this.repositoryService = repositoryService;
            this.alertService = alertService;
            this.translateService = translateService;
            this.modalService = modalService;
            this.bsModalService = bsModalService;
            this.reload$ = new rxjs.Subject();
            this.reloading$ = new rxjs.BehaviorSubject(false);
            this.isSoftwareTypeChanged = false;
            this.updateSoftware$ = new rxjs.Subject();
            this.softwareUpdated$ = new rxjs.Subject();
            this.baseVersionsUpdated$ = new rxjs.Subject();
            this.software$ = rxjs.merge(this.activatedRoute.params.pipe(operators.map(function (params) { return params.id; }), operators.switchMap(function (id) { return rxjs.from(_this.inventoryService.detail(id).then(function (result) { return result.data; })); })), this.reload$.pipe(operators.tap(function () { return _this.reloading$.next(true); }), operators.switchMap(function () { return _this.activatedRoute.params; }), operators.map(function (params) { return params.id; }), operators.switchMap(function (id) { return rxjs.from(_this.inventoryService.detail(id).then(function (result) { return result.data; })); }), operators.tap(function () { return _this.reloading$.next(false); })), this.softwareUpdated$).pipe(operators.shareReplay(1));
            this.baseVersions$ = rxjs.merge(this.software$.pipe(operators.distinctUntilKeyChanged('id')), this.baseVersionsUpdated$, this.reload$).pipe(operators.switchMap(function () { return _this.software$; }), operators.switchMap(function (software) { return _this.repositoryService.listBaseVersions(software); }), operators.shareReplay(1));
            this.isLegacy$ = this.software$.pipe(operators.map(function (software) { return _this.repositoryService.isLegacyEntry(software); }), operators.shareReplay(1));
            this.destroy$ = new rxjs.Subject();
        }
        SoftwareDetailsComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.updateSoftware$
                .pipe(operators.withLatestFrom(this.software$), operators.switchMap(function (_b) {
                var _c = __read(_b, 2), softwarePartial = _c[0], software = _c[1];
                return _this.inventoryService.update(Object.assign({ id: software.id }, softwarePartial));
            }), operators.map(function (_b) {
                var data = _b.data;
                return data;
            }), operators.tap(function (software) { return _this.softwareUpdated$.next(software); }), operators.tap(function () { return _this.alertService.success(ngxComponents.gettext('Saved.')); }), operators.takeUntil(this.destroy$))
                .subscribe();
            this.software$.subscribe(function (software) {
                _this.softwareTypeObject = software;
            });
        };
        SoftwareDetailsComponent.prototype.getBinaryName$ = function (binaryUrl) {
            return this.repositoryService.getBinaryName$(binaryUrl);
        };
        SoftwareDetailsComponent.prototype.addBaseVersion = function () {
            var _this = this;
            this.software$
                .pipe(operators.take(1), operators.switchMap(function (software) {
                var initialState = {
                    model: {
                        selected: software,
                        description: software.description
                    }
                };
                var config = {
                    class: 'modal-sm',
                    ignoreBackdropClick: true,
                    initialState: initialState
                };
                var modalRef = _this.bsModalService.show(AddSoftwareModalComponent, config);
                return modalRef.content.saved;
            }))
                .subscribe(function () { return _this.baseVersionsUpdated$.next(); });
        };
        SoftwareDetailsComponent.prototype.deleteBaseVersion = function (baseVersion) {
            return __awaiter(this, void 0, void 0, function () {
                var title, body, labels, ex_1;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 3, , 4]);
                            title = ngxComponents.gettext('Delete software');
                            body = "\n        " + this.translateService.instant(ngxComponents.gettext('You are about to delete software {{ version }}.'), { version: baseVersion.c8y_Software.version }) + "\n        " + this.translateService.instant(ngxComponents.gettext('This operation is irreversible.')) + "\n        " + this.translateService.instant(ngxComponents.gettext('Do you want to proceed?')) + "\n      ";
                            labels = {
                                ok: ngxComponents.gettext('Delete')
                            };
                            return [4 /*yield*/, this.modalService.confirm(title, body, ngxComponents.Status.DANGER, labels)];
                        case 1:
                            _b.sent();
                            return [4 /*yield*/, this.repositoryService.delete(baseVersion)];
                        case 2:
                            _b.sent();
                            this.alertService.success(ngxComponents.gettext('Software deleted.'));
                            this.baseVersionsUpdated$.next();
                            return [3 /*break*/, 4];
                        case 3:
                            ex_1 = _b.sent();
                            // only if not cancel from modal
                            if (ex_1) {
                                this.alertService.addServerFailure(ex_1);
                            }
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        SoftwareDetailsComponent.prototype.onSelectSoftwareType = function (software) {
            var _a;
            this.isSoftwareTypeChanged = !(((_a = this.softwareTypeObject) === null || _a === void 0 ? void 0 : _a.softwareType) === (software === null || software === void 0 ? void 0 : software.softwareType));
            this.softwareTypeObject = software;
        };
        SoftwareDetailsComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.unsubscribe();
        };
        return SoftwareDetailsComponent;
    }());
    SoftwareDetailsComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-software-details',
                    template: "<c8y-title>\n  {{ (software$ | async)?.name }}\n</c8y-title>\n\n<c8y-breadcrumb>\n  <c8y-breadcrumb-item\n    path=\"#/software\"\n    label=\"{{ 'Software repository' | translate }}\"\n    icon=\"c8y-tools\"\n  >\n  </c8y-breadcrumb-item>\n</c8y-breadcrumb>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button\n    *ngIf=\"!(isLegacy$ | async)\"\n    class=\"btn btn-link\"\n    title=\"{{ 'Add software' | translate }}\"\n    (click)=\"addBaseVersion()\"\n  >\n    <i c8yIcon=\"plus-circle\"></i>\n    {{ 'Add software' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\" title=\"{{ 'Reload' | translate }}\" (click)=\"reload$.next()\">\n    <i c8yIcon=\"refresh\" [ngClass]=\"{ 'icon-spin': reloading$ | async }\"></i>\n    {{ 'Reload' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<div class=\"row\">\n  <div class=\"col-lg-12 col-lg-max\">\n    <div class=\"card m-b-4\">\n      <div class=\"card-header separator\">\n        <h4 class=\"card-title\" translate>Software info</h4>\n      </div>\n      <div class=\"card-block overflow-visible\">\n        <div class=\"row\">\n          <div class=\"col-sm-6\">\n            <c8y-form-group>\n              <label class=\"control-label\">\n                {{ 'Name' | translate }}\n              </label>\n              <div class=\"input-group input-group-editable\">\n                <input\n                  #nameInput\n                  type=\"text\"\n                  class=\"form-control\"\n                  [ngModel]=\"(software$ | async)?.name\"\n                  #nameModel=\"ngModel\"\n                  placeholder=\"{{ 'e.g. My software' | translate }}\"\n                  [ngStyle]=\"{ 'width.ch': (software$ | async)?.name?.length + 2 || 31 }\"\n                  required\n                />\n                <span></span>\n                <div class=\"input-group-btn\">\n                  <button\n                    class=\"btn btn-primary\"\n                    title=\"{{ 'Save' | translate }}\"\n                    (click)=\"updateSoftware$.next({ name: nameInput.value }); nameModel.reset()\"\n                    [disabled]=\"nameInput.value.length === 0\"\n                  >\n                    {{ 'Save' | translate }}\n                  </button>\n                </div>\n              </div>\n            </c8y-form-group>\n          </div>\n          <div class=\"col-sm-6\">\n            <c8y-form-group>\n              <label class=\"control-label\">\n                {{ 'Description' | translate }}\n              </label>\n              <div class=\"input-group input-group-editable\">\n                <input\n                  #descriptionInput\n                  type=\"text\"\n                  class=\"form-control\"\n                  [ngModel]=\"(software$ | async)?.description\"\n                  #descriptionModel=\"ngModel\"\n                  placeholder=\"{{ 'e.g. Cloud connectivity software' | translate }}\"\n                  [ngStyle]=\"{ 'width.ch': (software$ | async)?.description?.length + 2 || 31 }\"\n                />\n                <span></span>\n                <div class=\"input-group-btn\">\n                  <button\n                    class=\"btn btn-primary\"\n                    title=\"{{ 'Save' | translate }}\"\n                    (click)=\"\n                      updateSoftware$.next({ description: descriptionInput.value });\n                      descriptionModel.reset()\n                    \"\n                  >\n                    {{ 'Save' | translate }}\n                  </button>\n                </div>\n              </div>\n            </c8y-form-group>\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"col-sm-6\">\n            <c8y-form-group>\n              <label class=\"control-label\">\n                {{ 'Device type' | translate }}\n                <button\n                  class=\"btn-clean\"\n                  popover=\"{{\n                    'If the filter is set, the software will show up for installation only for devices of that type. If no filter is set, it will be available for all devices.'\n                      | translate\n                  }}\"\n                  [outsideClick]=\"true\"\n                  container=\"body\"\n                >\n                  <i c8yIcon=\"question-circle-o\" class=\"text-info\"></i>\n                </button>\n              </label>\n              <div class=\"input-group input-group-editable\">\n                <input\n                  #deviceTypeInput\n                  type=\"text\"\n                  class=\"form-control\"\n                  [ngModel]=\"(software$ | async)?.c8y_Filter?.type\"\n                  #deviceTypeModel=\"ngModel\"\n                  placeholder=\"{{ 'e.g.' | translate }} c8y_Linux\"\n                  [ngStyle]=\"{ 'width.ch': (software$ | async)?.type?.length + 2 || 31 }\"\n                />\n                <span></span>\n                <div class=\"input-group-btn\">\n                  <button\n                    class=\"btn btn-primary\"\n                    title=\"{{ 'Save' | translate }}\"\n                    (click)=\"\n                      updateSoftware$.next({ c8y_Filter: { type: deviceTypeInput.value } });\n                      deviceTypeModel.reset()\n                    \"\n                  >\n                    {{ 'Save' | translate }}\n                  </button>\n                </div>\n              </div>\n            </c8y-form-group>\n          </div>\n          <div class=\"col-sm-6\">\n            <c8y-form-group>\n              <label class=\"control-label\">\n                {{ 'Software type' | translate }}\n              </label>\n              <div class=\"input-group input-group-editable\">\n                <c8y-software-type\n                  [softwareTypeMO]=\"softwareTypeObject\"\n                  [style]=\"{ 'width.ch': softwareTypeObject?.softwareType?.length + 2 || 31 }\"\n                  (onSelectSoftware)=\"onSelectSoftwareType($event)\"\n                >\n                </c8y-software-type>\n                <div class=\"input-group-btn\">\n                  <button\n                    class=\"btn btn-primary\"\n                    [ngClass]=\"isSoftwareTypeChanged ? '' : 'hidden'\"\n                    title=\"{{ 'Save' | translate }}\"\n                    [disabled]=\"softwareTypeObject?.softwareType === ''\"\n                    (click)=\"\n                      updateSoftware$.next({ softwareType: softwareTypeObject.softwareType });\n                      softwareType.resetInput();\n                      isSoftwareTypeChanged = false\n                    \"\n                  >\n                    {{ 'Save' | translate }}\n                  </button>\n                </div>\n              </div>\n            </c8y-form-group>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class=\"row\">\n  <div class=\"col-lg-12 col-lg-max\">\n    <div class=\"card\">\n      <div class=\"card-header separator\">\n        <h4 class=\"card-title\" translate>Versions</h4>\n      </div>\n\n      <div class=\"card-block p-t-0 p-b-24\">\n        <div *ngIf=\"(baseVersions$ | async)?.data.length === 0\">\n          <div class=\"c8y-empty-state text-center\">\n            <h1 c8yIcon=\"c8y-tools\" class=\"c8y-icon-duocolor\"></h1>\n            <h3 translate>No versions to display.</h3>\n            <p translate>Add a new version by clicking below.</p>\n            <p>\n              <button\n                class=\"btn btn-primary\"\n                title=\"{{ 'Add software' | translate }}\"\n                (click)=\"addBaseVersion()\"\n              >\n                {{ 'Add software' | translate }}\n              </button>\n            </p>\n          </div>\n        </div>\n\n        <c8y-list-group\n          [ngClass]=\"{ 'dd-low': (baseVersions$ | async)?.data.length < 10 }\"\n          *ngIf=\"(baseVersions$ | async)?.data.length > 0\"\n        >\n          <c8y-li\n            *c8yFor=\"let baseVersion of baseVersions$ | async; let i = index; loadMore: 'auto'\"\n          >\n            <c8y-li-icon>\n              <i c8yIcon=\"c8y-tools\"></i>\n            </c8y-li-icon>\n\n            <c8y-li-body class=\"content-flex-50\">\n              <div class=\"col-4\">\n                <p class=\"text-truncate-wrap\" title=\"{{ baseVersion.c8y_Software.version }}\">\n                  {{ baseVersion.c8y_Software.version }}\n                </p>\n              </div>\n              <div class=\"col-5\">\n                <p class=\"text-truncate-wrap\">\n                  <span class=\"text-label-small m-r-8\" translate> File </span>\n                  <span title=\" {{ getBinaryName$(baseVersion.c8y_Software.url) | async }}\">\n                    <c8y-file-download url=\"{{ baseVersion.c8y_Software.url }}\"></c8y-file-download>\n                  </span>\n                </p>\n              </div>\n              <div class=\"col-2 flex-row a-i-start\">\n                <span *ngIf=\"isLegacy$ | async\" class=\"label label-warning flex-item-right-sm\">\n                  {{ 'Legacy' | translate }}\n                </span>\n\n                <div class=\"fit-h-20\" *ngIf=\"!(isLegacy$ | async)\">\n                  <button\n                    class=\"btn btn-danger btn-xs visible-xs flex-item-right m-r-8 m-t-8\"\n                    (click)=\"deleteBaseVersion(baseVersion)\"\n                    title=\"{{ 'Delete' | translate }}\"\n                  >\n                    <i c8yIcon=\"minus-circle\"></i>\n                    {{ 'Delete' | translate }}\n                  </button>\n                </div>\n              </div>\n              <div *ngIf=\"!(isLegacy$ | async)\" class=\"flex-item-right fit-h-20 p-r-8 hidden-xs\">\n                <button\n                  class=\"btn btn-dot text-danger showOnHover\"\n                  (click)=\"deleteBaseVersion(baseVersion)\"\n                  title=\"{{ 'Delete' | translate }}\"\n                >\n                  <i c8yIcon=\"minus-circle\"></i>\n                </button>\n              </div>\n            </c8y-li-body>\n          </c8y-li>\n        </c8y-list-group>\n      </div>\n    </div>\n  </div>\n</div>\n"
                },] }
    ];
    SoftwareDetailsComponent.ctorParameters = function () { return [
        { type: router.ActivatedRoute },
        { type: client.InventoryService },
        { type: RepositoryService },
        { type: ngxComponents.AlertService },
        { type: core$1.TranslateService },
        { type: ngxComponents.ModalService },
        { type: modal.BsModalService }
    ]; };
    SoftwareDetailsComponent.propDecorators = {
        softwareType: [{ type: core.ViewChild, args: [SoftwareTypeComponent, { static: true },] }]
    };
    __decorate([
        ngxComponents.memoize()
    ], SoftwareDetailsComponent.prototype, "getBinaryName$", null);

    var DescriptionGridColumn = /** @class */ (function (_super) {
        __extends(DescriptionGridColumn, _super);
        function DescriptionGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            _this.name = 'description';
            _this.path = 'description';
            _this.header = ngxComponents.gettext('Description');
            _this.filterable = true;
            _this.filteringConfig = {
                schema: {
                    type: 'object',
                    properties: {
                        descriptions: {
                            type: 'array',
                            items: {
                                type: 'string'
                            }
                        }
                    }
                },
                form: [
                    {
                        type: 'template',
                        template: _this.getLabelTemplate(ngxComponents.gettext('Filter software by description'), {
                            showWildcardTooltip: true
                        })
                    },
                    {
                        key: 'descriptions',
                        notitle: true,
                        add: ngxComponents.gettext('Or'),
                        items: [
                            {
                                key: 'descriptions[]',
                                notitle: true,
                                placeholder: ngxComponents.gettext('e.g. Cloud connectivity')
                            }
                        ]
                    }
                ],
                getFilter: function (model) {
                    var filter = {};
                    if (model.descriptions.length) {
                        filter.description = { __in: model.descriptions };
                    }
                    return filter;
                }
            };
            _this.sortable = true;
            _this.sortingConfig = {
                pathSortingConfigs: [{ path: _this.path }]
            };
            return _this;
        }
        return DescriptionGridColumn;
    }(deviceGrid.BaseDeviceGridColumn));

    var DeviceTypeGridColumn = /** @class */ (function (_super) {
        __extends(DeviceTypeGridColumn, _super);
        function DeviceTypeGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            _this.name = 'deviceType';
            _this.path = 'c8yFilter.type';
            _this.header = ngxComponents.gettext('Device type');
            _this.cellRendererComponent = DeviceTypeCellRendererComponent;
            _this.filterable = true;
            _this.filteringConfig = {
                schema: {
                    type: 'object',
                    properties: {
                        types: {
                            type: 'array',
                            items: {
                                type: 'string'
                            }
                        }
                    }
                },
                form: [
                    {
                        type: 'template',
                        template: _this.getLabelTemplate(ngxComponents.gettext('Filter software by device type'), {
                            showWildcardTooltip: true
                        })
                    },
                    {
                        key: 'types',
                        notitle: true,
                        add: ngxComponents.gettext('Or'),
                        items: [
                            {
                                key: 'types[]',
                                notitle: true,
                                placeholder: ngxComponents.gettext('e.g. c8y_Linux')
                            }
                        ]
                    }
                ],
                getFilter: function (model) {
                    var filter = {};
                    if (model.types.length) {
                        filter['c8y_Filter.type'] = { __in: model.types };
                    }
                    return filter;
                }
            };
            _this.sortable = true;
            _this.sortingConfig = {
                pathSortingConfigs: [{ path: _this.path }]
            };
            return _this;
        }
        return DeviceTypeGridColumn;
    }(deviceGrid.BaseDeviceGridColumn));

    var SoftwareNameGridColumn = /** @class */ (function (_super) {
        __extends(SoftwareNameGridColumn, _super);
        function SoftwareNameGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            _this.name = 'name';
            _this.path = 'name';
            _this.header = ngxComponents.gettext('Name');
            _this.cellRendererComponent = NameCellRendererComponent;
            _this.filterable = true;
            _this.filteringConfig = {
                schema: {
                    type: 'object',
                    properties: {
                        names: {
                            type: 'array',
                            items: {
                                type: 'string'
                            }
                        }
                    }
                },
                form: [
                    {
                        type: 'template',
                        template: _this.getLabelTemplate(ngxComponents.gettext('Filter software by name'), {
                            showWildcardTooltip: true
                        })
                    },
                    {
                        key: 'names',
                        notitle: true,
                        add: ngxComponents.gettext('Or'),
                        items: [
                            {
                                key: 'names[]',
                                notitle: true,
                                placeholder: ngxComponents.gettext('e.g. Cloud connectivity')
                            }
                        ]
                    }
                ],
                getFilter: function (model) {
                    var filter = {};
                    if (model.names.length) {
                        filter.name = { __in: model.names };
                    }
                    return filter;
                }
            };
            _this.sortable = true;
            _this.sortingConfig = {
                pathSortingConfigs: [{ path: _this.path }]
            };
            return _this;
        }
        return SoftwareNameGridColumn;
    }(deviceGrid.BaseDeviceGridColumn));

    var SoftwareTypeGridColumn = /** @class */ (function (_super) {
        __extends(SoftwareTypeGridColumn, _super);
        function SoftwareTypeGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            _this.name = 'type';
            _this.path = 'softwareType';
            _this.header = ngxComponents.gettext('Software type');
            _this.cellRendererComponent = SoftwareTypeCellRendererComponent;
            _this.filterable = true;
            _this.filteringFormRendererComponent = SoftwareTypeFilteringFormRendererComponent;
            _this.filteringConfig = {
                getFilter: function (model) {
                    var filter = {};
                    if (model.softwareType) {
                        filter.softwareType = { __eq: model.softwareType };
                    }
                    return filter;
                }
            };
            _this.sortable = true;
            _this.sortingConfig = {
                pathSortingConfigs: [{ path: _this.path }]
            };
            return _this;
        }
        return SoftwareTypeGridColumn;
    }(deviceGrid.BaseDeviceGridColumn));

    var VersionsGridColumn = /** @class */ (function (_super) {
        __extends(VersionsGridColumn, _super);
        function VersionsGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            _this.name = 'versions';
            _this.header = ngxComponents.gettext('Versions');
            _this.cellRendererComponent = VersionsCellRendererComponent;
            _this.sortable = false;
            return _this;
        }
        return VersionsGridColumn;
    }(deviceGrid.BaseDeviceGridColumn));

    var SoftwareListComponent = /** @class */ (function () {
        function SoftwareListComponent(repositoryService, gridService, modalService, bsModalService, translateService, alertService, router, activatedRoute) {
            var _this = this;
            this.repositoryService = repositoryService;
            this.gridService = gridService;
            this.modalService = modalService;
            this.bsModalService = bsModalService;
            this.translateService = translateService;
            this.alertService = alertService;
            this.router = router;
            this.activatedRoute = activatedRoute;
            this.sizeRequestDone = false;
            this.refresh$ = new core.EventEmitter();
            this.columns = [
                new SoftwareNameGridColumn(),
                new DescriptionGridColumn(),
                new DeviceTypeGridColumn(),
                new SoftwareTypeGridColumn(),
                new VersionsGridColumn()
            ];
            this.actionControls = [];
            this.pagination = {
                pageSize: 50,
                currentPage: 1
            };
            this.serverSideDataCallback = this.onDataSourceModifier.bind(this);
            this.sizeRequest = this.repositoryService
                .listRepositoryEntries(exports.RepositoryType.SOFTWARE, {
                skipDefaultOrder: true,
                params: { pageSize: 1 }
            })
                .then(function (response) {
                var _a;
                _this.sizeRequestDone = true;
                return (_a = response === null || response === void 0 ? void 0 : response.paging) === null || _a === void 0 ? void 0 : _a.totalPages;
            });
        }
        SoftwareListComponent.prototype.ngOnInit = function () {
            this.actionControls.push({
                type: "EDIT" /* Edit */,
                callback: this.editSoftware.bind(this)
            });
            this.actionControls.push({
                type: "DELETE" /* Delete */,
                callback: this.deleteSoftware.bind(this)
            });
        };
        SoftwareListComponent.prototype.onDataSourceModifier = function (dataSourceModifier) {
            return __awaiter(this, void 0, void 0, function () {
                var serverSideDataResult, dataRequest, filtererdSizeRequest, _b, dataResponse, size, filteredSize, res, data, paging;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            dataRequest = this.repositoryService.listRepositoryEntries(exports.RepositoryType.SOFTWARE, {
                                query: this.gridService.getQueryObj(dataSourceModifier.columns),
                                skipDefaultOrder: true,
                                params: {
                                    pageSize: dataSourceModifier.pagination.pageSize,
                                    currentPage: dataSourceModifier.pagination.currentPage
                                }
                            });
                            filtererdSizeRequest = this.repositoryService
                                .listRepositoryEntries(exports.RepositoryType.SOFTWARE, {
                                skipDefaultOrder: true,
                                query: this.gridService.getQueryObj(dataSourceModifier.columns),
                                params: { pageSize: 1 }
                            })
                                .then(function (response) { var _a; return (_a = response === null || response === void 0 ? void 0 : response.paging) === null || _a === void 0 ? void 0 : _a.totalPages; });
                            return [4 /*yield*/, Promise.all([
                                    dataRequest,
                                    this.sizeRequest,
                                    filtererdSizeRequest
                                ])];
                        case 1:
                            _b = __read.apply(void 0, [_c.sent(), 3]), dataResponse = _b[0], size = _b[1], filteredSize = _b[2];
                            res = dataResponse.res, data = dataResponse.data, paging = dataResponse.paging;
                            serverSideDataResult = {
                                res: res,
                                data: data,
                                paging: paging,
                                filteredSize: filteredSize,
                                size: size
                            };
                            return [2 /*return*/, serverSideDataResult];
                    }
                });
            });
        };
        SoftwareListComponent.prototype.addSoftware = function () {
            var _this = this;
            var config = {
                class: 'modal-sm',
                ignoreBackdropClick: true
            };
            var modalRef = this.bsModalService.show(AddSoftwareModalComponent, config);
            modalRef.content.saved.subscribe(function (savedSoftware) { return _this.editSoftware(savedSoftware); });
        };
        SoftwareListComponent.prototype.editSoftware = function (software) {
            this.router.navigate([software.id], { relativeTo: this.activatedRoute });
        };
        SoftwareListComponent.prototype.deleteSoftware = function (software) {
            return __awaiter(this, void 0, void 0, function () {
                var title, body, labels, ex_1;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 3, , 4]);
                            title = ngxComponents.gettext('Delete software');
                            body = "\n        " + this.translateService.instant(ngxComponents.gettext('You are about to delete software "{{ name }}" with all its versions.'), { name: software.name }) + "\n        " + this.translateService.instant(ngxComponents.gettext('This operation is irreversible.')) + "\n        " + this.translateService.instant(ngxComponents.gettext('Do you want to proceed?')) + "\n      ";
                            labels = {
                                ok: ngxComponents.gettext('Delete')
                            };
                            return [4 /*yield*/, this.modalService.confirm(title, body, ngxComponents.Status.DANGER, labels)];
                        case 1:
                            _b.sent();
                            return [4 /*yield*/, this.repositoryService.delete(software)];
                        case 2:
                            _b.sent();
                            this.alertService.success(ngxComponents.gettext('Software deleted.'));
                            this.refresh$.next();
                            return [3 /*break*/, 4];
                        case 3:
                            ex_1 = _b.sent();
                            // only if not cancel from modal
                            if (ex_1) {
                                this.alertService.addServerFailure(ex_1);
                            }
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        SoftwareListComponent.prototype.trackByName = function (_index, column) {
            return column.name;
        };
        return SoftwareListComponent;
    }());
    SoftwareListComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-software-list',
                    template: "<c8y-title>\n  {{ 'Software repository' | translate }}\n</c8y-title>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\" title=\"{{ 'Add software' | translate }}\" (click)=\"addSoftware()\">\n    <i c8yIcon=\"plus-circle\"></i>\n    {{ 'Add software' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<div class=\"content-fullpage\">\n  <c8y-data-grid\n    [title]=\"'Software' | translate\"\n    [refresh]=\"refresh$\"\n    [actionControls]=\"[]\"\n    [pagination]=\"pagination\"\n    [columns]=\"columns\"\n    [actionControls]=\"actionControls\"\n    [infiniteScroll]=\"'auto'\"\n    [serverSideDataCallback]=\"serverSideDataCallback\"\n  >\n    <div class=\"c8y-empty-state\">\n      <ng-container *ngIf=\"!sizeRequestDone\">\n        <c8y-loading></c8y-loading>\n      </ng-container>\n      <ng-container *ngIf=\"sizeRequestDone\">\n        <ng-container *ngIf=\"(sizeRequest | async) === 0; else noResults\">\n          <div class=\"text-center\">\n            <h1 class=\"c8y-icon-duocolor\" c8yIcon=\"c8y-tools\"></h1>\n            <h3 translate>No software to display.</h3>\n            <p translate>Add a new software by clicking below.</p>\n            <p>\n              <button\n                class=\"btn btn-primary\"\n                title=\"{{ 'Add software' | translate }}\"\n                (click)=\"addSoftware()\"\n                translate\n              >\n                Add software\n              </button>\n            </p>\n          </div>\n        </ng-container>\n        <ng-template #noResults>\n          <h1 c8yIcon=\"search\"></h1>\n          <div>\n            <p>\n              <strong>{{ 'No results to display.' | translate }}</strong>\n            </p>\n            <small>{{ 'Refine your search terms or check your spelling.' | translate }}</small>\n          </div>\n        </ng-template>\n      </ng-container>\n    </div>\n    <ng-container *ngFor=\"let column of columns; trackBy: trackByName\">\n      <c8y-column [name]=\"column.name\"></c8y-column>\n    </ng-container>\n  </c8y-data-grid>\n</div>\n"
                },] }
    ];
    SoftwareListComponent.ctorParameters = function () { return [
        { type: RepositoryService },
        { type: deviceGrid.DeviceGridService },
        { type: ngxComponents.ModalService },
        { type: modal.BsModalService },
        { type: core$1.TranslateService },
        { type: ngxComponents.AlertService },
        { type: router.Router },
        { type: router.ActivatedRoute }
    ]; };

    var 0 = [
        {
            path: 'firmware',
            component: FirmwareListComponent
        },
        {
            path: 'firmware/:id',
            component: FirmwareDetailsComponent
        },
        {
            context: ngxComponents.ViewContext.Device,
            path: 'firmware',
            component: FirmwareDeviceTabComponent,
            label: ngxComponents.gettext('Firmware'),
            icon: 'c8y-firmware',
            priority: 500,
            canActivate: [FirmwareDeviceTabGuard]
        },
        {
            path: 'software',
            component: SoftwareListComponent
        },
        {
            path: 'software/:id',
            component: SoftwareDetailsComponent
        },
        {
            context: ngxComponents.ViewContext.Device,
            path: 'software',
            component: SoftwareDeviceTabComponent,
            label: ngxComponents.gettext('Software'),
            icon: 'c8y-tools',
            priority: 499,
            canActivate: [SoftwareDeviceTabGuard]
        },
        {
            path: 'configuration',
            component: ConfigurationListComponent
        },
        {
            context: ngxComponents.ViewContext.Device,
            path: 'device-configuration',
            component: DeviceConfigurationComponent,
            label: ngxComponents.gettext('Configuration'),
            icon: 'gears',
            priority: 600,
            canActivate: [DeviceConfigurationGuard]
        }
    ];
    var RepositoryModule = /** @class */ (function () {
        function RepositoryModule() {
        }
        return RepositoryModule;
    }());
    RepositoryModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        ngxComponents.CoreModule,
                        ngxComponents.FormsModule,
                        router.RouterModule,
                        singleOperationDetails.SingleOperationDetailsModule,
                        dropdown.BsDropdownModule.forRoot(),
                        tooltip.TooltipModule,
                        popover.PopoverModule,
                        tabs.TabsModule.forRoot()
                    ],
                    exports: [SoftwareTypeComponent, FileDownloadComponent],
                    declarations: [
                        FirmwareListComponent,
                        FirmwareDetailsComponent,
                        AddFirmwareModalComponent,
                        AddFirmwarePatchModalComponent,
                        SoftwareListComponent,
                        SoftwareDetailsComponent,
                        AddSoftwareModalComponent,
                        SoftwareTypeComponent,
                        FirmwareDeviceTabComponent,
                        SoftwareDeviceTabComponent,
                        InstalledSoftwareComponent,
                        RepositorySelectModalComponent,
                        DeviceSoftwareListComponent,
                        DeviceSoftwareChangesComponent,
                        ConfigurationListComponent,
                        ConfigurationDetailComponent,
                        DeviceConfigurationComponent,
                        DeviceConfigurationListComponent,
                        SourceCodePreviewComponent,
                        ConfigurationPreviewComponent,
                        ConfigurationFilterPipe,
                        SaveToRepositoryComponent,
                        TextBasedConfigurationComponent,
                        FileDownloadComponent,
                        NameCellRendererComponent,
                        SoftwareTypeCellRendererComponent,
                        SoftwareTypeFilteringFormRendererComponent,
                        DeviceTypeCellRendererComponent,
                        VersionsCellRendererComponent
                    ],
                    entryComponents: [
                        FirmwareListComponent,
                        FirmwareDetailsComponent,
                        AddFirmwareModalComponent,
                        AddFirmwarePatchModalComponent,
                        SoftwareListComponent,
                        SoftwareDetailsComponent,
                        AddSoftwareModalComponent,
                        FirmwareDeviceTabComponent,
                        SoftwareDeviceTabComponent,
                        DeviceSoftwareListComponent,
                        RepositorySelectModalComponent,
                        DeviceSoftwareChangesComponent,
                        ConfigurationListComponent,
                        ConfigurationDetailComponent,
                        DeviceConfigurationComponent,
                        SaveToRepositoryComponent,
                        TextBasedConfigurationComponent
                    ],
                    providers: [
                        RepositoryService,
                        ngxComponents.OperationRealtimeService,
                        DeviceConfigurationService,
                        FirmwareDeviceTabGuard,
                        SoftwareDeviceTabGuard,
                        DeviceConfigurationGuard,
                        AdvancedSoftwareService,
                        {
                            provide: ngxComponents.HOOK_NAVIGATOR_NODES,
                            useClass: RepositoryNavigationFactory,
                            multi: true
                        },
                        {
                            provide: ngxComponents.HOOK_ROUTE,
                            useValue: 0,
                            multi: true
                        }
                    ]
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AddFirmwareModalComponent = AddFirmwareModalComponent;
    exports.AddFirmwarePatchModalComponent = AddFirmwarePatchModalComponent;
    exports.AddSoftwareModalComponent = AddSoftwareModalComponent;
    exports.ConfigurationDetailComponent = ConfigurationDetailComponent;
    exports.ConfigurationFilterPipe = ConfigurationFilterPipe;
    exports.ConfigurationListComponent = ConfigurationListComponent;
    exports.ConfigurationPreviewComponent = ConfigurationPreviewComponent;
    exports.DeviceConfigurationComponent = DeviceConfigurationComponent;
    exports.DeviceConfigurationGuard = DeviceConfigurationGuard;
    exports.DeviceConfigurationListComponent = DeviceConfigurationListComponent;
    exports.DeviceConfigurationService = DeviceConfigurationService;
    exports.DeviceSoftwareChangesComponent = DeviceSoftwareChangesComponent;
    exports.DeviceSoftwareListComponent = DeviceSoftwareListComponent;
    exports.FirmwareDetailsComponent = FirmwareDetailsComponent;
    exports.FirmwareDeviceTabComponent = FirmwareDeviceTabComponent;
    exports.FirmwareDeviceTabGuard = FirmwareDeviceTabGuard;
    exports.FirmwareListComponent = FirmwareListComponent;
    exports.InstalledSoftwareComponent = InstalledSoftwareComponent;
    exports.REPOSITORY_BINARY_TYPES = REPOSITORY_BINARY_TYPES;
    exports.RepositoryModule = RepositoryModule;
    exports.RepositoryNavigationFactory = RepositoryNavigationFactory;
    exports.RepositorySelectModalComponent = RepositorySelectModalComponent;
    exports.RepositoryService = RepositoryService;
    exports.SaveToRepositoryComponent = SaveToRepositoryComponent;
    exports.SoftwareDetailsComponent = SoftwareDetailsComponent;
    exports.SoftwareDeviceTabComponent = SoftwareDeviceTabComponent;
    exports.SoftwareDeviceTabGuard = SoftwareDeviceTabGuard;
    exports.SoftwareListComponent = SoftwareListComponent;
    exports.SourceCodePreviewComponent = SourceCodePreviewComponent;
    exports.TextBasedConfigurationComponent = TextBasedConfigurationComponent;
    exports["0"] = 0;
    exports["a"] = SoftwareTypeComponent;
    exports["b"] = FileDownloadComponent;
    exports["c"] = AdvancedSoftwareService;
    exports["d"] = NameCellRendererComponent;
    exports["e"] = SoftwareTypeCellRendererComponent;
    exports["f"] = SoftwareTypeFilteringFormRendererComponent;
    exports["g"] = DeviceTypeCellRendererComponent;
    exports["h"] = VersionsCellRendererComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=c8y-ngx-components-repository.umd.js.map
