import { ViewContext, EmptyComponent, gettext, AppStateService, RouterService, ActionService, TabsService, TenantUiService, DatePipe, RouterModule, HOOK_NAVIGATOR_NODES, HOOK_TABS, HOOK_ACTION_BAR, HOOK_ACTION, HOOK_BREADCRUMB, HOOK_DOCS, BootstrapComponent, UserTotpRevokeComponent, DataGridComponent, LoadingComponent, RangeDisplayComponent, HelpComponent, HighlightComponent, HOOK_PATTERN_MESSAGES, HeaderService, AlertService, UserMenuService, DocsService, PasswordService, CachedLocaleDictionaryService, ModalService, NavigatorNodeRoot, getActivatedRoute, ActionBarService, WidgetsDashboardComponent, C8yTranslateModule, HOOK_COMPONENTS } from '@c8y/ngx-components';
import { ReplaySubject, BehaviorSubject, of, combineLatest, from, fromEventPattern, Subject, defer } from 'rxjs';
import { filter, merge, debounceTime, switchMap, startWith, map as map$1 } from 'rxjs/operators';
import { map, unary, find, forEach, startsWith, isArray, assign, pick, property, some, every, get } from 'lodash-es';
import { ActivationEnd, Router } from '@angular/router';
import { NgZone, Injectable, NgModule, Inject, Component, ChangeDetectionStrategy, Optional, ElementRef, ViewContainerRef, ViewChild, TemplateRef } from '@angular/core';
import { BasicAuth, FetchClient, QueriesUtil } from '@c8y/client';
import * as angular from 'angular';
import { setAngularJSGlobal, downgradeComponent, downgradeInjectable } from '@angular/upgrade/static';
import { AppLogsAutoRefreshComponent } from '@c8y/ngx-components/app-logs';
import { ApiService } from '@c8y/ngx-components/api';
import { BulkOperationDetailsService } from '@c8y/ngx-components/operations/bulk-operations-list';
import { TranslateService } from '@ngx-translate/core';
import { __awaiter } from 'tslib';
import { ContextDashboardService } from '@c8y/ngx-components/context-dashboard';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@c8y/ngx-components';
import * as ɵngcc2 from '@ngx-translate/core';
import * as ɵngcc3 from '@angular/router';
import * as ɵngcc4 from '@c8y/ngx-components/context-dashboard';

const _c0 = ["templateCopy"];
function CopyActionComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li");
    ɵngcc0.ɵɵelementStart(1, "button", 1);
    ɵngcc0.ɵɵlistener("click", function CopyActionComponent_ng_template_0_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.copyDashboard(); });
    ɵngcc0.ɵɵpipe(2, "translate");
    ɵngcc0.ɵɵelement(3, "i", 2);
    ɵngcc0.ɵɵelementStart(4, "span", 3);
    ɵngcc0.ɵɵtext(5, "Copy dashboard");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵpropertyInterpolate("title", ɵngcc0.ɵɵpipeBind1(2, 1, "Copy dashboard"));
} }
const _c1 = ["templatePaste"];
function PasteActionComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li");
    ɵngcc0.ɵɵelementStart(1, "button", 1);
    ɵngcc0.ɵɵlistener("click", function PasteActionComponent_ng_template_0_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.pasteDashboard(); });
    ɵngcc0.ɵɵpipe(2, "translate");
    ɵngcc0.ɵɵelement(3, "i", 2);
    ɵngcc0.ɵɵelementStart(4, "span", 3);
    ɵngcc0.ɵɵtext(5, "Paste dashboard");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtext(6, "\u00A0");
    ɵngcc0.ɵɵelementStart(7, "span");
    ɵngcc0.ɵɵtext(8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵpropertyInterpolate("title", ɵngcc0.ɵɵpipeBind1(2, 2, "Paste dashboard"));
    ɵngcc0.ɵɵadvance(7);
    ɵngcc0.ɵɵtextInterpolate1("\"", ctx_r1.dashboardName, "\"");
} }
var ViewContextLegacyParameter;
(function (ViewContextLegacyParameter) {
    ViewContextLegacyParameter["Device"] = "deviceId";
    ViewContextLegacyParameter["Group"] = "groupId";
    ViewContextLegacyParameter["User"] = "userId";
    ViewContextLegacyParameter["Application"] = "applicationId";
    ViewContextLegacyParameter["Microservice"] = "applicationId";
    ViewContextLegacyParameter["SubscribedApplications"] = "applicationId";
    ViewContextLegacyParameter["Tenant"] = "tenantId";
})(ViewContextLegacyParameter || (ViewContextLegacyParameter = {}));
function c8yViewsProvider($routeProvider, c8yTabsProvider, c8yPathUtils) {
    'ngInject';
    const viewMap = {};
    const contextViews = new ReplaySubject();
    return {
        when,
        $get() {
            return {
                contextViews,
                when(path, cfg) {
                    return when(path, cfg, true);
                },
                getByPath,
                prefixWithSlash
            };
        }
    };
    /**
     * @ngdoc function
     * @name when
     * @methodOf c8y.ui.provider:c8yViewsProvider
     *
     * @description
     * Defines a view for given route.
     * If multiple views are defined for a single route then there will be a separate tab for each view available when user visits that route.
     *
     * @param path Target route.
     * @param cfg View configuration object with the following properties:
     *
     * - **name** - `string` - View's name (in case of multiple views at single route this will be displayed as tab's title).
     * - **priority** - `integer` - View's priority (in case of multiple views at single route this will determine the position of view's tab in the tabs stack).
     * - **icon** - `string` - Font Awesome icon name for the view (displayed on the tab's header).
     * - **showIf** - `function` - Function returning boolean value indicating whether to show a tab for the view or not.
     * - **templateUrl** - `string` - Path to the template to use for displaying the view.
     *
     * You can also provide other view options - the same as available for standard {@link https://docs.angularjs.org/api/ngRoute/provider/$routeProvider $routeProvider} in AngularJS.
     *
     * @example
     * The following example demonstrates how to add a new view to device details route
     * (which will be displayed as a tab if other views are assigned to the same route):
     * <pre>
     *   c8yViewsProvider.when('/device/:deviceId', {
     *     name: 'Tracking',
     *     templateUrl: ':::PLUGIN_PATH:::/views/index.html',
     *     icon: 'crosshairs',
     *     showIf: ['$routeParams', 'c8yDevices', function ($routeParams, c8yDevices) {
     *       var deviceId = $routeParams.deviceId;
     *       return c8yDevices.detailCached(deviceId).then(function (res) {
     *         var device = res.data;
     *         return device && (device.c8y_MotionTracking || device.c8y_Geofence);
     *       });
     *     }]
     *   });
     * </pre>
     */
    function when(path, cfg, runPhase) {
        const newPath = prefixWithSlash(path);
        cfg.resolve = cfg.resolve || {};
        // eslint-disable-next-line no-underscore-dangle
        cfg.resolve.__c8y_locales = [
            'c8yLocales',
            c8yLocales => {
                return c8yLocales.initDone;
            }
        ];
        let currentCfg = viewMap[newPath];
        const originalPath = newPath;
        if (!cfg.name) {
            // console.warn('View name not defined');
        }
        if (!currentCfg) {
            viewMap[newPath] = [];
            currentCfg = viewMap[newPath];
        }
        const upgradedContext = Object.keys(ViewContext)
            .map(key => ({
            key,
            isUpgrade: prefixWithSlash(ViewContext[key].replace('id', ViewContextLegacyParameter[key])) === path
        }))
            .find(({ isUpgrade }) => isUpgrade);
        if (upgradedContext) {
            currentCfg.push(cfg);
            cfg.path = newPath;
            const p = c8yPathUtils.appendSegment(originalPath.replace(path, ''), cfg.name);
            contextViews.next(Object.assign(Object.assign({}, cfg), { path: cfg.name ? p.substring(1) : '', contextKey: upgradedContext.key, runPhase }));
            cfg.showIf = undefined;
            if (cfg.name) {
                cfg.path = c8yPathUtils.appendSegment(originalPath, cfg.name);
            }
        }
        else {
            if (currentCfg.length === 1) {
                const [existingConfig] = currentCfg;
                existingConfig.path = c8yPathUtils.appendSegment(originalPath, existingConfig.name);
                existingConfig.tab = createTab(originalPath, existingConfig);
                $routeProvider.when(existingConfig.path, existingConfig);
            }
            currentCfg.push(cfg);
            cfg.path = newPath;
            if (currentCfg.length > 1) {
                cfg.path = c8yPathUtils.appendSegment(originalPath, cfg.name);
                createTab(originalPath, cfg);
                $routeProvider.when(prefixWithSlash(originalPath), {
                    resolveRedirectTo($route, $q, c8yUiUtil, c8yTabs, gettextCatalog) {
                        'ngInject';
                        const sortedCurrentCfg = c8yTabsProvider.sortTabsViews(currentCfg, gettextCatalog);
                        const params = $route.current.pathParams;
                        return $q
                            .all(map(sortedCurrentCfg, unary(c8yUiUtil.configureVisibility)))
                            .then(views => {
                            const first = find(views, 'show');
                            let url = first.path;
                            forEach(params, (val, key) => {
                                url = url.replace(`:${key}`, val);
                            });
                            c8yTabs.redirectedViewPath = url;
                            return url;
                        });
                    }
                });
            }
        }
        return $routeProvider.when(prefixWithSlash(cfg.path), cfg);
    }
    function getByPath(path) {
        return viewMap[prefixWithSlash(path)];
    }
    function createTab(path, cfg) {
        c8yTabsProvider.addTab(path, cfg);
    }
    function prefixWithSlash(path) {
        const prefix = startsWith(path, '/') ? '' : '/';
        return prefix + path;
    }
}

class BridgeService {
    constructor(injector, appState, router, ngZone, routerService, actionService) {
        this.injector = injector;
        this.appState = appState;
        this.router = router;
        this.ngZone = ngZone;
        this.routerService = routerService;
        this.actionService = actionService;
        this.$liveTabs = new BehaviorSubject([]);
        this.fixE2eIssues();
        this.$ng1RouteChangeSuccess = this.fromNg1Event(this.injector.get('$rootScope'), '$routeChangeSuccess');
        this.$ng1RouteChangeStart = this.fromNg1Event(this.injector.get('$rootScope'), '$routeChangeStart');
        this.hookLanguage();
        this.hookTabs();
        this.hookNavigator();
        this.hookUserMenu();
        this.hookViewProvider();
        this.router.initialNavigation();
        this.ng1Routes();
    }
    hookViewProvider() {
        const c8yViews = this.injector.get('c8yViews');
        // fix to trigger an angularjs route change success
        // event on context route match to make legacy
        // view-providers resolve.
        c8yViews.when('/device/:id', {
            template: ''
        });
        c8yViews.when('/group/:id', {
            template: ''
        });
        c8yViews.contextViews.subscribe(cfg => this.addRoute(cfg));
    }
    addRoute(cfg) {
        this.routerService.addRoute({
            label: cfg.label || cfg.name,
            path: cfg.path,
            icon: cfg.icon,
            context: ViewContext[cfg.contextKey],
            priority: cfg.priority,
            component: EmptyComponent,
            data: {
                showIf: cfg.showIf
                    ? ngxRoute => {
                        const params = Object.assign(Object.assign({}, ngxRoute.params), { [ViewContextLegacyParameter[cfg.contextKey]]: ngxRoute.params.id });
                        const showIfResult = this.injector.invoke(cfg.showIf, undefined, {
                            $routeParams: params
                        });
                        // make sure showIf result is a promise with boolean result:
                        return this.injector.get('$q').when(showIfResult).then(Boolean);
                    }
                    : undefined
            }
        });
        if (cfg.runPhase) {
            this.routerService.refresh();
        }
    }
    ng1Routes() {
        const template = '';
        const fallbackRoutes = [];
        // tslint:disable-next-line: forin
        for (const context in ViewContext) {
            const path = ViewContext[context].match(/(\w+)\//)[1];
            const regexp = new RegExp(`^/${path}/(?:([^/]+)).*$`);
            fallbackRoutes.push({
                keys: [{ name: ViewContextLegacyParameter[context], optional: false }],
                regexp,
                template
            });
        }
        /**
         * When asset detail routes (/device/:id,  /group/:id) are matched in Angular Router, ngRoute in
         * angular.js must also have matching generic routes so that the ids can be extracted from the paths and
         * injected in multiple calls (showIf, c8yActions, etc) as properties of $routeParams.
         *
         * The function in src/ngRoute/route.js (angular.js) where the routes are matched is called parseRoute(). This
         * function calls angular.forEach and in turn this function checks for the presence of a forEach method before
         * trying object key iteration.
         * By attaching a non enumerable forEach method to the routes object we guarantee that the fallback generic routes
         * are only matched after any other registered through $routeProvider.when.
         */
        const $route = this.injector.get('$route');
        Object.defineProperty($route.routes, 'forEach', {
            // make non enumerable
            value: function forEach(iterator, context) {
                // tslint:disable-next-line: forin
                for (const key in this) {
                    iterator.call(context, this[key], key, this);
                }
                fallbackRoutes.forEach(r => iterator.call(context, r));
            }
        });
        /**
         * Some functions use the current context. As some parts are upgraded and some not, the following updates the
         * angularjs getContext function to resolve always the right context.
         */
        const c8yUiUtil = this.injector.get('c8yUiUtil');
        const _getContext = c8yUiUtil.getContext;
        this.router.events
            .pipe(filter(event => event instanceof ActivationEnd))
            .subscribe((event) => {
            if (event.snapshot.routeConfig.path === '**') {
                c8yUiUtil.getContext = _getContext;
            }
            else if (event.snapshot.data && event.snapshot.data.context) {
                c8yUiUtil.getContext = () => {
                    return {
                        context: event.snapshot.data.context.replace('/:id', ''),
                        id: event.snapshot.data.contextData.id
                    };
                };
            }
            else {
                c8yUiUtil.getContext = () => ({ context: null, id: null });
            }
        });
    }
    fixE2eIssues() {
        try {
            const { ngZone } = this;
            const { Utils } = window.org.cometd;
            const timeoutFn = Utils.setTimeout;
            // tslint:disable-next-line:only-arrow-functions
            Utils.setTimeout = function (...args) {
                return ngZone.runOutsideAngular(() => timeoutFn.apply(Utils, args));
            };
        }
        catch (e) {
            // do nothing
        }
        try {
            const { ace } = window;
            const editFn = ace.edit;
            const { ngZone } = this;
            // tslint:disable-next-line:only-arrow-functions
            ace.edit = function (...args) {
                return ngZone.runOutsideAngular(() => editFn.apply(ace, args));
            };
        }
        catch (e) {
            // do nothing
        }
    }
    hookLanguage() {
        let first = true;
        this.appState
            .map(store => store.lang)
            .subscribe(lang => {
            this.injector.get('c8yLocales').switchToLanguage(lang);
            if (!first) {
                this.injector.get('$rootScope').$apply();
            }
            first = false;
        });
    }
    hookTabs() {
        // Just for instantiation of the c8yAction service
        this.injector.get('c8yActions');
        const $location = this.injector.get('$location');
        const c8yTabs = this.injector.get('c8yTabs');
        let liveTabs = [];
        c8yTabs.addTab = tab => {
            liveTabs.push(Object.assign(Object.assign({}, tab), { label: tab.label || tab.name, path: decodeURIComponent(tab.path) }));
            this.$liveTabs.next(liveTabs);
        };
        this.$ng1RouteChangeStart.subscribe(e => {
            liveTabs = [];
            this.$liveTabs.next(liveTabs);
        });
        this.$ng1RouteChangeSuccess.subscribe(e => {
            const path = $location.path();
            if (this.router.url !== path) {
                this.router.navigate(path === '/' ? '' : path.split('/'), {
                    queryParams: $location.search(),
                    skipLocationChange: true
                });
            }
            if (this.actionService) {
                this.actionService.refresh();
            }
        });
        this.$routeChanges = this.$ng1RouteChangeSuccess.pipe(merge(this.fromNg1Event(c8yTabs, c8yTabs.EVENT_UPDATE), of(1)), debounceTime(100));
    }
    hookNavigator() {
        this.navigationNodes$ = this.injector.get('c8yNavigator').rootNodes$;
    }
    getTabs() {
        const onlyVisible = ({ show }) => show;
        const upgradeTab = tab => (Object.assign(Object.assign({}, tab), { label: tab.label || tab.name, path: decodeURIComponent(tab.path) }));
        const routeTabs = this.$routeChanges.pipe(switchMap(() => {
            const routes = this.injector.get('c8yTabs').routeTabs;
            const visibilityPromise = Promise.all(routes.map(({ checkingVisibility }) => checkingVisibility));
            return visibilityPromise.then(() => routes.filter(onlyVisible).map(upgradeTab));
        }), startWith([]));
        return combineLatest(routeTabs, this.$liveTabs).pipe(map$1(([route, live]) => route.concat(live)));
    }
    getQuickLinks() {
        const c8yQuickLinks = this.injector.get('c8yQuickLinks');
        return c8yQuickLinks.list();
    }
    getActionBarItems() {
        const c8yActionBar = this.injector.get('c8yActionBar');
        const $rootScope = this.injector.get('$rootScope');
        const getActionBarElements = () => c8yActionBar.elements.map(element => ({
            priority: element.getAttribute('action-bar-priority') || 0,
            template: element,
            placement: element.getAttribute('action-bar-position') || 'right'
        }));
        return this.fromNg1Event($rootScope, 'c8yActionBarChanged').pipe(startWith(1), map$1(getActionBarElements));
    }
    getBreadcrumbs() {
        const $location = this.injector.get('$location');
        const path = $location.path();
        const c8yBreadcrumbs = this.injector.get('c8yBreadcrumbs');
        const breadcrumbs = c8yBreadcrumbs.get(path) || {};
        const breadcrumbsData = this.resolveBreadcrumbsData(breadcrumbs.data);
        return from(breadcrumbsData).pipe(map$1((value) => {
            const liveBreadcrumbs = c8yBreadcrumbs.getLiveBreadcrumbs();
            value = value.concat(liveBreadcrumbs);
            return value.map(items => ({ items: items }));
        }));
    }
    resolveBreadcrumbsData(data) {
        try {
            return this.injector.invoke(data);
        }
        catch (ex) {
            // empty
        }
        if (isArray(data)) {
            return of([data]);
        }
        return of([]);
    }
    getSearch() {
        const c8ySearch = this.injector.get('c8ySearch');
        return c8ySearch.list().map(item => {
            return {
                icon: 'search',
                name: item.name,
                term: '',
                onSearch() {
                    if (this.term) {
                        c8ySearch.search(this.term);
                    }
                }
            };
        });
    }
    getActions() {
        const registeredActions = this.injector.get('c8yActions').registeredActions;
        return of(registeredActions
            .filter(action => !action.hidden)
            .map(action => ({
            // The priority was reversed: Aligned it to dashboard, high first, low last.
            priority: (action.priority || 0) * -1,
            label: action.text,
            icon: action.icon,
            disabled: action.disabled,
            action: () => {
                this.injector.invoke(action.action, action);
            }
        })));
    }
    fromNg1Event(obj, evt) {
        let stopListening;
        function add(handler) {
            stopListening = obj.$on(evt, handler);
        }
        return fromEventPattern(add, () => stopListening());
    }
    hookUserMenu() {
        const userMenuService = this.injector.get('c8yUserMenuService');
        const c8yAccessDenied = this.injector.get('c8yAccessDenied');
        userMenuService.add({
            icon: 'access',
            priority: 10,
            label: gettext('Access denied requests'),
            click: c8yAccessDenied.showAccessDeniedRequestsList
        });
    }
}
function bridgeServiceFactory(injector, appState, router, ngZone, routerService, actionService) {
    return new BridgeService(injector, appState, router, ngZone, routerService, actionService);
}
const bridgeServiceProvider = {
    provide: BridgeService,
    useFactory: bridgeServiceFactory,
    deps: ['$injector', AppStateService, Router, NgZone, RouterService, ActionService]
};

class Ng1ActionBarFactoryService {
    constructor(bridge) {
        this.bridge = bridge;
        this.routeChanges$ = bridge.$routeChanges;
        this.$ng1RouteChangeSuccess = bridge.$ng1RouteChangeSuccess;
    }
    get() {
        return this.routeChanges$.pipe(switchMap(e => {
            return this.bridge.getActionBarItems();
        }));
    }
}
Ng1ActionBarFactoryService.ɵfac = function Ng1ActionBarFactoryService_Factory(t) { return new (t || Ng1ActionBarFactoryService)(ɵngcc0.ɵɵinject(BridgeService)); };
Ng1ActionBarFactoryService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Ng1ActionBarFactoryService, factory: Ng1ActionBarFactoryService.ɵfac });
Ng1ActionBarFactoryService.ctorParameters = () => [
    { type: BridgeService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Ng1ActionBarFactoryService, [{
        type: Injectable
    }], function () { return [{ type: BridgeService }]; }, null); })();

class Ng1ActionFactoryService {
    constructor(bridge, tabs) {
        this.bridge = bridge;
        this.tabs = tabs;
        this.routeChanges$ = bridge.$routeChanges;
        this.$location = bridge.injector.get('$location');
        this.tabs.items$.subscribe((newTabs) => this.handleTabsRedirect(newTabs));
    }
    handleTabsRedirect(tabs) {
        /**
         * This function is doing the same process as function redirect in the file
         * modules/core/ui/navigation/tabs.provider.js
         * That function  is not run because bridge.service.ts overrides the method addTab where the redirect() was called.
         */
        const redirectedTab = tabs.find((tab) => tab.redirectedTo);
        const [topPriorityTab] = tabs;
        if (redirectedTab && !topPriorityTab.redirectedTo) {
            this.$location.replace();
            this.$location.path(topPriorityTab.path);
            topPriorityTab.redirectedTo = true;
            redirectedTab.redirectedTo = false;
        }
    }
    get() {
        return this.bridge.getActions();
    }
}
Ng1ActionFactoryService.ɵfac = function Ng1ActionFactoryService_Factory(t) { return new (t || Ng1ActionFactoryService)(ɵngcc0.ɵɵinject(BridgeService), ɵngcc0.ɵɵinject(ɵngcc1.TabsService)); };
Ng1ActionFactoryService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Ng1ActionFactoryService, factory: Ng1ActionFactoryService.ɵfac });
Ng1ActionFactoryService.ctorParameters = () => [
    { type: BridgeService },
    { type: TabsService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Ng1ActionFactoryService, [{
        type: Injectable
    }], function () { return [{ type: BridgeService }, { type: ɵngcc1.TabsService }]; }, null); })();

class Ng1BreadcrumbFactoryService {
    constructor(bridge) {
        this.bridge = bridge;
        this.trigger = new ReplaySubject(1);
        this.breadcrumbs = this.trigger.pipe(debounceTime(100), switchMap(() => {
            return this.bridge.getBreadcrumbs();
        }));
    }
    get() {
        this.trigger.next();
        return this.breadcrumbs;
    }
}
Ng1BreadcrumbFactoryService.ɵfac = function Ng1BreadcrumbFactoryService_Factory(t) { return new (t || Ng1BreadcrumbFactoryService)(ɵngcc0.ɵɵinject(BridgeService)); };
Ng1BreadcrumbFactoryService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Ng1BreadcrumbFactoryService, factory: Ng1BreadcrumbFactoryService.ɵfac });
Ng1BreadcrumbFactoryService.ctorParameters = () => [
    { type: BridgeService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Ng1BreadcrumbFactoryService, [{
        type: Injectable
    }], function () { return [{ type: BridgeService }]; }, null); })();

class Ng1NodesFactoryService {
    constructor(bridge) {
        this.bridge = bridge;
    }
    get() {
        return this.bridge.navigationNodes$;
    }
}
Ng1NodesFactoryService.ɵfac = function Ng1NodesFactoryService_Factory(t) { return new (t || Ng1NodesFactoryService)(ɵngcc0.ɵɵinject(BridgeService)); };
Ng1NodesFactoryService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Ng1NodesFactoryService, factory: Ng1NodesFactoryService.ɵfac });
Ng1NodesFactoryService.ctorParameters = () => [
    { type: BridgeService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Ng1NodesFactoryService, [{
        type: Injectable
    }], function () { return [{ type: BridgeService }]; }, null); })();

class Ng1TabsFactoryService {
    constructor(bridge) {
        this.bridge = bridge;
        this.tabsObservable = bridge.getTabs();
    }
    get() {
        return this.tabsObservable;
    }
}
Ng1TabsFactoryService.ɵfac = function Ng1TabsFactoryService_Factory(t) { return new (t || Ng1TabsFactoryService)(ɵngcc0.ɵɵinject(BridgeService)); };
Ng1TabsFactoryService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Ng1TabsFactoryService, factory: Ng1TabsFactoryService.ɵfac });
Ng1TabsFactoryService.ctorParameters = () => [
    { type: BridgeService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Ng1TabsFactoryService, [{
        type: Injectable
    }], function () { return [{ type: BridgeService }]; }, null); })();

class Ng1DocsFactoryService {
    constructor(bridge) {
        this.bridge = bridge;
        this.links = this.bridge.getQuickLinks();
        this.links.then(list => {
            list.map(el => {
                el.type = el.type || 'quicklink';
                return el;
            });
        });
    }
    get() {
        return this.links;
    }
}
Ng1DocsFactoryService.ɵfac = function Ng1DocsFactoryService_Factory(t) { return new (t || Ng1DocsFactoryService)(ɵngcc0.ɵɵinject(BridgeService)); };
Ng1DocsFactoryService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Ng1DocsFactoryService, factory: Ng1DocsFactoryService.ɵfac });
Ng1DocsFactoryService.ctorParameters = () => [
    { type: BridgeService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Ng1DocsFactoryService, [{
        type: Injectable
    }], function () { return [{ type: BridgeService }]; }, null); })();

class AuthBridgeService {
    constructor(injector, basicAuth, fetchClient, appState, tenantUiService) {
        this.injector = injector;
        this.basicAuth = basicAuth;
        this.fetchClient = fetchClient;
        this.appState = appState;
        this.tenantUiService = tenantUiService;
        this.hookAuth();
    }
    updateBasicAuth(credentials) {
        const { headers } = this.fetchClient.getFetchOptions({});
        if (headers.Authorization) {
            const token = headers.Authorization.match(/basic\s(.*)$/i)[1];
            if (token) {
                this.basicAuth.updateCredentials(credentials);
                this.fetchClient.setAuth(this.basicAuth);
            }
        }
    }
    hookAuth() {
        this.appState.currentUser.subscribe(u => {
            if (u) {
                this.injector.get('c8yAuth').headers = () => this.fetchClient.getFetchOptions({}).headers;
                const { headers } = this.fetchClient.getFetchOptions({});
                if (headers.Authorization) {
                    const token = headers.Authorization.match(/basic\s(.*)$/i)[1];
                    if (token) {
                        this.setToken(token, headers.tfatoken);
                    }
                }
                else {
                    this.setToken(undefined, headers.tfatoken, 'Oauth');
                }
                this.injector.get('$rootScope').$emit('authStateChange', { hasAuth: true });
            }
            else {
                this.injector.get('$rootScope').$emit('authStateChange', { hasAuth: false });
            }
        });
    }
    setToken(token, tfa, type = 'Basic') {
        const c8yAuth = this.injector.get('c8yAuth');
        if (type === 'Basic') {
            c8yAuth.onSetToken({ token, type });
            if (tfa) {
                c8yAuth.setTFAToken(tfa);
            }
        }
        else {
            c8yAuth.authReady();
        }
    }
    getPreferredLoginOption() {
        return this.tenantUiService.getPreferredLoginOption(this.appState.state.loginOptions);
    }
}
function authBridgeServiceFactory(injector, basicAuth, fetchClient, appState, tenantUiService) {
    return new AuthBridgeService(injector, basicAuth, fetchClient, appState, tenantUiService);
}
const authBridgeServiceProvider = {
    provide: AuthBridgeService,
    useFactory: authBridgeServiceFactory,
    deps: ['$injector', BasicAuth, FetchClient, AppStateService, TenantUiService]
};

class AbsoluteDateService {
    constructor(datePipe) {
        this.datePipe = datePipe;
    }
    getFilter() {
        return (value) => this.datePipe.transform(value);
    }
}
function absoluteDateServiceFactory(datePipe) {
    return new AbsoluteDateService(datePipe).getFilter();
}
const absoluteDateServiceProvider = {
    provide: AbsoluteDateService,
    useFactory: absoluteDateServiceFactory,
    deps: [DatePipe]
};

setAngularJSGlobal(angular);
class UpgradeModule {
}
UpgradeModule.ɵfac = function UpgradeModule_Factory(t) { return new (t || UpgradeModule)(); };
UpgradeModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: UpgradeModule });
UpgradeModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [
        absoluteDateServiceProvider,
        bridgeServiceProvider,
        authBridgeServiceProvider,
        { provide: HOOK_NAVIGATOR_NODES, useClass: Ng1NodesFactoryService, multi: true },
        { provide: HOOK_TABS, useClass: Ng1TabsFactoryService, multi: true },
        { provide: HOOK_ACTION_BAR, useClass: Ng1ActionBarFactoryService, multi: true },
        { provide: HOOK_ACTION, useClass: Ng1ActionFactoryService, multi: true },
        { provide: HOOK_BREADCRUMB, useClass: Ng1BreadcrumbFactoryService, multi: true },
        { provide: HOOK_DOCS, useClass: Ng1DocsFactoryService, multi: true }
    ], imports: [[RouterModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(UpgradeModule, [{
        type: NgModule,
        args: [{
                imports: [RouterModule],
                exports: [],
                providers: [
                    absoluteDateServiceProvider,
                    bridgeServiceProvider,
                    authBridgeServiceProvider,
                    { provide: HOOK_NAVIGATOR_NODES, useClass: Ng1NodesFactoryService, multi: true },
                    { provide: HOOK_TABS, useClass: Ng1TabsFactoryService, multi: true },
                    { provide: HOOK_ACTION_BAR, useClass: Ng1ActionBarFactoryService, multi: true },
                    { provide: HOOK_ACTION, useClass: Ng1ActionFactoryService, multi: true },
                    { provide: HOOK_BREADCRUMB, useClass: Ng1BreadcrumbFactoryService, multi: true },
                    { provide: HOOK_DOCS, useClass: Ng1DocsFactoryService, multi: true }
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(UpgradeModule, { imports: function () { return [RouterModule]; } }); })();

function c8yAlertDecorator($delegate, $rootScope, $injector) {
    'ngInject';
    $delegate.add = alert => {
        $delegate.addAlert(transformAlert(alert));
    };
    $rootScope.$on('alert', (evt, alert) => {
        $delegate.addAlert(transformAlert(alert));
    });
    $rootScope.$on('message', (evt, alert) => {
        $delegate.addAlert(transformAlert(alert));
    });
    /**
     * Solution based on the: https://stackoverflow.com/questions/40102148/how-to-iterate-over-all-properties-in-objects-prototype-chain.
     * Problem came after switching to ES6, as all prototype properties of classes are non-enumerable.
     */
    const allNames = new Set();
    for (let o = $delegate; o !== Object.prototype; o = Object.getPrototypeOf(o)) {
        for (const name of Object.getOwnPropertyNames(o)) {
            allNames.add(name);
        }
    }
    Array.from(allNames).forEach((property) => {
        if (typeof $delegate[property] === 'function') {
            $delegate[property] = $delegate[property].bind($delegate);
        }
    });
    function transformAlert(alert) {
        const newAlert = Object.assign({}, alert);
        if (alert.onClose) {
            newAlert.onClose = () => {
                $injector.invoke(alert.onClose);
            };
        }
        if (alert.onDetail) {
            newAlert.onDetail = () => {
                $injector.invoke(alert.onDetail);
            };
        }
        return newAlert;
    }
    return $delegate;
}

const bootstrapComponent = downgradeComponent({ component: BootstrapComponent });
const userTotpComponent = downgradeComponent({ component: UserTotpRevokeComponent });
const appLogsAutoRefreshComponent = downgradeComponent({
    component: AppLogsAutoRefreshComponent
});
const dataGridComponent = downgradeComponent({ component: DataGridComponent });
const loadingComponent = downgradeComponent({ component: LoadingComponent });
const rangeDisplayComponent = downgradeComponent({ component: RangeDisplayComponent });
const helpComponent = downgradeComponent({ component: HelpComponent });
const highlightComponent = downgradeComponent({
    component: HighlightComponent,
    inputs: ['pattern', 'text']
});

class ServerMessagesService {
    constructor(translateService, patterns) {
        this.translateService = translateService;
        this.MESSAGE_PATTERNS = patterns;
    }
    translate(s) {
        return this.translateService.instant(s);
    }
}
ServerMessagesService.ɵfac = function ServerMessagesService_Factory(t) { return new (t || ServerMessagesService)(ɵngcc0.ɵɵinject(ɵngcc2.TranslateService), ɵngcc0.ɵɵinject(HOOK_PATTERN_MESSAGES)); };
ServerMessagesService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ServerMessagesService, factory: ServerMessagesService.ɵfac });
ServerMessagesService.ctorParameters = () => [
    { type: TranslateService },
    { type: undefined, decorators: [{ type: Inject, args: [HOOK_PATTERN_MESSAGES,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ServerMessagesService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc2.TranslateService }, { type: undefined, decorators: [{
                type: Inject,
                args: [HOOK_PATTERN_MESSAGES]
            }] }]; }, null); })();

const absoluteDateService = downgradeInjectable(AbsoluteDateService);
const bridgeService = downgradeInjectable(BridgeService);
const authBridgeService = downgradeInjectable(AuthBridgeService);
const appStateService = downgradeInjectable(AppStateService);
const headerService = downgradeInjectable(HeaderService);
const alertsService = downgradeInjectable(AlertService);
const userMenuService = downgradeInjectable(UserMenuService);
const apiService = downgradeInjectable(ApiService);
const docsService = downgradeInjectable(DocsService);
const passwordService = downgradeInjectable(PasswordService);
const translateService = downgradeInjectable(TranslateService);
const cachedLocaleDictionaryService = downgradeInjectable(CachedLocaleDictionaryService);
const serverMessagesService = downgradeInjectable(ServerMessagesService);
const bulkOperationDetailsService = downgradeInjectable(BulkOperationDetailsService);
const modalService = downgradeInjectable(ModalService);

function gettextCatalogDecorator($delegate, $interpolate, c8yTranslate) {
    'ngInject';
    const gettextCatalog = $delegate;
    const originalGetString = angular.bind(gettextCatalog, gettextCatalog.getString);
    function newGetString(input, scope, context) {
        if (typeof input === 'string') {
            const translatedString = originalGetString(input, scope, context);
            const interpolatedString = scope ? $interpolate(input)(scope) : input;
            let stringToReturn = translatedString;
            if (translatedString && translatedString === interpolatedString) {
                const translatedServerMessage = c8yTranslate.instant(interpolatedString);
                stringToReturn = translatedServerMessage;
            }
            return stringToReturn;
        }
        return input;
    }
    gettextCatalog.getString = newGetString;
    return gettextCatalog;
}

function groupTypesHierarchyNavigatorDecorator($delegate, $q) {
    'ngInject';
    $delegate.loadAll = () => $q.when();
    $delegate.addGroupNavigation = () => $q.when();
    return $delegate;
}

function c8yNg1HttpInterceptor($q, c8yLoadingIndicator, c8yApiService) {
    'ngInject';
    function request(config) {
        const { url, method } = config;
        c8yApiService.onStart({ url, method, options: config });
        return config;
    }
    function requestError(rejection) {
        finishRequest(rejection);
        return $q.reject(rejection);
    }
    function response(res) {
        finishRequest(res);
        return res;
    }
    function responseError(rejection) {
        finishRequest(rejection);
        c8yLoadingIndicator.responseError(rejection);
        return $q.reject(rejection);
    }
    function finishRequest(res) {
        const { url, method } = res.config;
        c8yApiService.onFinish({
            url,
            method,
            response: res,
            options: res.config
        });
    }
    return {
        request,
        requestError,
        response,
        responseError
    };
}

class NavigatorNodeRootLegacy extends NavigatorNodeRoot {
    addRoot(nodeData) {
        let duplicate;
        if (nodeData.path === '') {
            nodeData.path = '/';
        }
        nodeData.label = nodeData.name;
        if (typeof nodeData.parent === 'object') {
            nodeData.parent.label = nodeData.parent.name;
        }
        if (nodeData.preventDuplicates) {
            duplicate = this.find(({ path, parents, label }) => {
                return path === nodeData.path &&
                    (label === nodeData.label) &&
                    parents.some((p) => p.label === nodeData.parent);
            });
            if (duplicate) {
                duplicate.routerLinkExact = false;
            }
        }
        return duplicate || super.addRoot(nodeData);
    }
    createNode(node) {
        const newNode = super.createNode(node);
        const update = newNode.update.bind(newNode);
        const root = this;
        return Object.defineProperties(assign(newNode, {
            realName: newNode.name || newNode.label,
            _parent: true,
            update(data) {
                if (this._parent === undefined) {
                    // _parent was deleted somene instead to put this in root
                    root.addRoot(this);
                    // put it back so it can be deleted again
                    this._parent = true;
                }
                update(data);
            },
            addChild(nodeChild) {
                this.add(root.createNode(nodeChild));
            }
        }), {
            label: {
                get() {
                    return this.realName || '';
                },
                set(name) {
                    this.realName = name;
                }
            },
            name: {
                get() {
                    return this.realName || '';
                },
                set(name) {
                    this.realName = name;
                }
            },
            show: {
                get() {
                    return !this.hidden;
                },
                set(show) {
                    this.hidden = !show;
                }
            }
        });
    }
}

// Just to hook into the bridge service
function c8yNavigatorProvider() {
    const root = new NavigatorNodeRootLegacy();
    const rootNodesSubject = new Subject();
    const conditionalNodes = [];
    const rootNodes$ = rootNodesSubject.pipe(merge(defer(() => of(root.children))));
    function addNavigation(nodes) {
        const nodeList = (Array.isArray(nodes) ? nodes : [nodes]);
        nodeList.forEach((node) => {
            if (isConditional(node)) {
                node.hidden = undefined;
                conditionalNodes.push(node);
            }
            node.navNode = root.addRoot(node);
        });
        rootNodesSubject.next(root.children);
    }
    function removeNavigation(node) {
        const found = root.find((n) => n === node);
        if (found) {
            found.parents.forEach((p) => p.remove(found));
            rootNodesSubject.next(root.children);
        }
    }
    function findNode(node) {
        return root.find(node);
    }
    function isConditional(node) {
        return node.showIf || node.showIfPermissions || node.showIfContainsVisibleViews;
    }
    function $get($q, $injector) {
        'ngInject';
        // This avoids the circular dependency
        setTimeout(() => conditionalNodes.forEach(processShowIf));
        function processShowIf(node) {
            const c8yUiUtil = $injector.get('c8yUiUtil');
            const visibilityPromises = [];
            const { showIf, showIfPermissions, showIfContainsVisibleViews } = node;
            if (showIf) {
                visibilityPromises.push($injector.invoke(showIf));
            }
            if (showIfContainsVisibleViews) {
                visibilityPromises.push(viewsConditionalVisibility(node));
            }
            c8yUiUtil.configureVisibility({
                showIf: () => $q.all(visibilityPromises).then(every),
                showIfPermissions
            }, 'visible')
                .then(({ visible }) => {
                if (visible) {
                    node.navNode.update({
                        hidden: false,
                        showIf: null,
                        showIfPermission: null,
                        showIfContainsVisibleViews: null
                    });
                }
                else {
                    node.navNode.update({
                        hidden: true
                    });
                }
            });
        }
        function viewsConditionalVisibility(node) {
            const c8yUiUtil = $injector.get('c8yUiUtil');
            const c8yViews = $injector.get('c8yViews');
            const views = c8yViews.getByPath(node.path);
            return $q.all(map(views, (view) => c8yUiUtil
                .configureVisibility(pick(view, ['showIf', 'showIfPermissions']), 'show', false)
                .then(property('show'))))
                .then(some);
        }
        return {
            rootNodes() {
                return root.children;
            },
            findNode,
            addNavigation,
            removeNavigation,
            rootNodes$
        };
    }
    return {
        $get,
        addNavigation,
        removeNavigation
    };
}

const rootComponent = {
    template: `
  <c8y-bootstrap>
    <div id="c8y-legacy-view">
      <div ng-view ng-if="vm.widthSet && vm.authState.hasAuth"></div>
    </div>
  </c8y-bootstrap>`,
    controller: c8yUiRootController,
    controllerAs: 'vm'
};
function c8yUiRootController($rootScope, $timeout, c8yBase, c8yNavigator, c8yApplication, c8yHeaderService) {
    'ngInject';
    const vm = this;
    Object.assign(vm, {
        $onInit,
        navOpen: false
    });
    ////////////
    function $onInit() {
        c8yHeaderService.map((states) => states.nav.open).subscribe((isOpen) => {
            vm.navOpen = isOpen;
        });
        c8yHeaderService.configNavigator({ canToggle: true });
        $rootScope.$on('authStateChange', onAuthStateChange);
        vm.rootNodes = c8yNavigator.rootNodes;
        c8yApplication.currentAppCached().then(onAppInfo);
        vm.navHiddenOnStartup = c8yBase.appOption('hide_navigator');
        checkReady();
    }
    function onAuthStateChange(evt, data) {
        vm.authState = data;
    }
    function onAppInfo() {
        vm.tabsHorizontal = c8yBase.appOption('tabsHorizontal');
    }
    function checkReady() {
        const element = document.querySelector('#c8y-legacy-view');
        const hasWidth = element && element.clientWidth;
        if (hasWidth) {
            vm.widthSet = true;
        }
        else {
            $timeout(checkReady);
        }
    }
}

function c8yTitleDecorator($q, $delegate, $injector, $rootScope, $location, $templateCache, $compile, c8yHeaderService) {
    'ngInject';
    const exports = {
        translate,
        changeTitleInAngular
    };
    $delegate.changeTitle = changeTitle;
    $delegate.setTitleElement = setTitleElement;
    $rootScope.$on('$routeChangeStart', () => {
        changeTitle({});
    });
    $rootScope.$on('$routeChangeSuccess', (event) => {
        const title = $delegate.get($location.path());
        if (title) {
            const titleData = $q.when(title.data ? $injector.invoke(title.data) : {});
            titleData.then((data) => {
                const { templateUrl } = data;
                if (templateUrl) {
                    const template = $templateCache.get(templateUrl);
                    setTitleElement($compile(template)(event.targetScope));
                }
                else {
                    changeTitle(data);
                }
            });
        }
    });
    function changeTitle(newTitleSubtitleObjOrPromise, options = { skipTitleTranslation: false, skipSubtitleTranslation: false }) {
        $q.when(newTitleSubtitleObjOrPromise).then(newTitleSubtitleObj => changeTitleInAngular(translate(newTitleSubtitleObj, options)));
    }
    function translate({ title = '', subtitle = '' }, { skipTitleTranslation = false, skipSubtitleTranslation = false }) {
        const titleTemplate = skipTitleTranslation ? '{{ title }}' : '{{ title | translate }}';
        const subtitleTemplate = skipSubtitleTranslation ? '{{ subtitle }}' : '{{ subtitle | translate }}';
        const template = `
      <h1 class="text-truncate">${titleTemplate}
      <small>${subtitleTemplate}</small></h1>
    `;
        const isolatedScope = $rootScope.$new(true);
        isolatedScope.title = title;
        isolatedScope.subtitle = subtitle;
        return $compile(angular.element(template))(isolatedScope)[0];
    }
    function changeTitleInAngular(domElement) {
        c8yHeaderService.changeTitle(domElement);
    }
    function setTitleElement($element) {
        $element.show();
        changeTitleInAngular($element[0]);
    }
    return $delegate;
}

const NAME = 'c8y.upgrade';
window.preventNg1Bootstrap = true;
angular
    .module(NAME, [])
    // tslint:disable-next-line:only-arrow-functions
    .config(function ($httpProvider) {
    'ngInject';
    const ng1InterceptorIndex = $httpProvider.interceptors.indexOf('c8yLoadingIndicator');
    if (ng1InterceptorIndex > -1) {
        $httpProvider.interceptors.splice(ng1InterceptorIndex, 1);
    }
    $httpProvider.interceptors.push(c8yNg1HttpInterceptor);
})
    .component('c8yUiRoot', rootComponent)
    .directive('c8yBootstrap', bootstrapComponent)
    .factory('c8yBridgeService', bridgeService)
    .factory('c8yAuthBridgeService', authBridgeService)
    .factory('c8yAppStateService', appStateService)
    .factory('c8yHeaderService', headerService)
    .factory('c8yUserMenuService', userMenuService)
    // tslint:disable-next-line:only-arrow-functions
    .service('c8yQueriesUtil', function () {
    return new QueriesUtil();
})
    .decorator('c8yTitle', c8yTitleDecorator)
    .factory('c8yAlert', alertsService)
    .decorator('c8yAlert', c8yAlertDecorator)
    .decorator('groupTypesHierarchyNavigator', groupTypesHierarchyNavigatorDecorator) // prevents loading the groups
    .factory('c8yApiService', apiService)
    .factory('c8yDocs', docsService)
    .service('c8yPasswordConfirm', passwordService)
    .service('c8yModalService', modalService);
angular
    .module('c8y.ui')
    .filter('absoluteDate', absoluteDateService)
    .directive('c8yLoading', loadingComponent)
    .provider('c8yNavigator', c8yNavigatorProvider)
    .provider('c8yViews', c8yViewsProvider)
    .directive('c8yUserTotpRevoke', userTotpComponent)
    .directive('c8yAppLogsAutoRefresh', appLogsAutoRefreshComponent)
    .directive('c8yDataGrid', dataGridComponent)
    .directive('c8yRangeDisplay', rangeDisplayComponent)
    .directive('c8yHelp', helpComponent)
    .directive('c8yHighlight', highlightComponent)
    .factory('c8yTranslate', translateService)
    .factory('c8yCachedLocaleDictionaryService', cachedLocaleDictionaryService)
    .factory('c8yBulkOperationDetailsService', bulkOperationDetailsService)
    .decorator('gettextCatalog', gettextCatalogDecorator)
    .factory('c8yServerMessages', serverMessagesService)
    .factory('ngZone', downgradeInjectable(NgZone));
const ng1Modules = ['app', NAME];

class HybridAppModule {
    constructor() {
        this.ng1Modules = ng1Modules;
    }
    ngDoBootstrap() {
        window.bootstrap();
        this.upgrade.bootstrap(document.getElementById('app'), this.ng1Modules, { strictDi: false });
    }
}

const UPGRADE_ROUTES = [
    { path: '**', component: EmptyComponent }
];

class DashboardBridgeService {
    constructor(ng1Injector, zone, router, contextDashboardService, actionBarService) {
        this.ng1Injector = ng1Injector;
        this.zone = zone;
        this.router = router;
        this.contextDashboardService = contextDashboardService;
        this.actionBarService = actionBarService;
        this.dashboardSvc = ng1Injector.get('dashboardSvc');
        this.compile = ng1Injector.get('$compile');
    }
    get ng1Components() {
        return this.ng1Injector.get('c8yComponents');
    }
    instantiateComponent(widget, element) {
        return __awaiter(this, void 0, void 0, function* () {
            const { dashboard, context, child } = widget;
            if (dashboard) {
                const transformedChild = yield this.dashboardSvc.transformChildWithContext(this.dashboardSvc.forcedContext || context, dashboard, child);
                if (this.dashboardSvc.forcedContext || dashboard.deviceType || dashboard.updateTarget) {
                    yield this.dashboardSvc.updateConfigTargetsWithContext(this.dashboardSvc.forcedContext || context, transformedChild.config);
                }
                return this.zone.runOutsideAngular(() => this.loadTemplate(transformedChild, child, element, context));
            }
            else {
                return this.loadConfigTemplate(element, widget);
            }
        });
    }
    editDashboard(dashboard) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.dashboardSvc.editCurrentDashboard({ dashboardId: dashboard.id });
        });
    }
    copyDashboard() {
        const dashboard = this.getDashboard();
        const couldCopy = this.dashboardSvc.copyDashboard(dashboard.c8y_Dashboard);
        if (couldCopy) {
            this.dashboardClipboard = dashboard;
            this.actionBarService.refresh();
            return dashboard;
        }
    }
    pasteDashboard() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const newDashboard = yield this.dashboardSvc.pasteDashboard();
                this.navigateToDashboard(newDashboard);
                this.dashboardClipboard = undefined;
            }
            catch (ex) {
                // intended empty
            }
            this.actionBarService.refresh();
        });
    }
    instantiateDeviceSelector(element, widgetConfig) {
        return this.loadConfigTemplate(element, widgetConfig, true);
    }
    loadTemplate(transformedChild, child, element, context) {
        const scope = this.ng1Injector.get('$rootScope').$new(true);
        scope.child = transformedChild;
        scope.dashboardContext = context;
        if (child.widgetComponent) {
            element.innerHTML = `<c8y-ui-component component-name="'${child.widgetComponent}'" config="child.config" context="dashboardContext"></c8y-ui-component>`;
        }
        else if (child.templateUrl) {
            element.innerHTML = `<ng-include src="'${child.templateUrl}'"></ng-include>`;
        }
        this.compile(element)(scope);
        return scope;
    }
    navigateToDashboard(dashboard) {
        if (/dashboard/.test(this.router.url)) {
            this.router.navigate(['..', dashboard.id], {
                relativeTo: getActivatedRoute(this.router)
            });
        }
        else {
            this.router.navigate(['..', 'dashboard', dashboard.id], {
                relativeTo: getActivatedRoute(this.router)
            });
        }
    }
    getDashboard() {
        return getActivatedRoute(this.router).snapshot.data.dashboard;
    }
    loadConfigTemplate(element, widgetConfig, onlyDeviceSelector = false) {
        const { settings } = widgetConfig;
        const scope = this.ng1Injector.get('$rootScope').$new(true);
        scope.settings = Object.assign(Object.assign({}, settings), settings.ng1);
        scope.options = widgetConfig.options;
        scope.config = widgetConfig;
        scope.forms = {};
        scope.rootId = settings.context.id;
        scope.dashboard = get(widgetConfig, 'settings.dashboardMo');
        let configCmp = '';
        if (!onlyDeviceSelector) {
            if (widgetConfig.settings.configComponent) {
                configCmp = `<c8y-ui-component component-name="'${widgetConfig.settings.configComponent}'" config="config"></c8y-ui-component>`;
            }
            else if (widgetConfig.settings.configTemplateUrl) {
                configCmp = `<ng-include src="'${widgetConfig.settings.configTemplateUrl}'"></ng-include>`;
            }
        }
        element.innerHTML = `
    <ng-form name="forms.componentForm">
      <div class="form-group"
        ng-if="!settings.noDeviceTarget"
        ng-style="{height: settings.hideTarget && '0', overflow: 'hidden'}"
      >
        <label translate>${gettext('Target assets or devices')}</label>
        <c8y-device-selector-combo parent="rootId"
          selected-child-device="config.device"
          groups-selectable="settings.groupsSelectable"
          select-required="!settings.deviceTargetNotRequired"
        ></c8y-device-selector-combo>
      </div>
      ${configCmp}
    </ng-form>`;
        scope.$watch('forms.componentForm.$invalid', formStatus => {
            this.contextDashboardService.formDisabled = formStatus;
        });
        this.compile(element)(scope);
        this.contextDashboardService.formDisabled = scope.forms.componentForm.$invalid;
        return scope;
    }
}
DashboardBridgeService.ɵfac = function DashboardBridgeService_Factory(t) { return new (t || DashboardBridgeService)(ɵngcc0.ɵɵinject(undefined), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc3.Router), ɵngcc0.ɵɵinject(ɵngcc4.ContextDashboardService), ɵngcc0.ɵɵinject(ɵngcc1.ActionBarService)); };
DashboardBridgeService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DashboardBridgeService, factory: DashboardBridgeService.ɵfac });
DashboardBridgeService.ctorParameters = () => [
    { type: undefined },
    { type: NgZone },
    { type: Router },
    { type: ContextDashboardService },
    { type: ActionBarService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DashboardBridgeService, [{
        type: Injectable
    }], function () { return [{ type: undefined }, { type: ɵngcc0.NgZone }, { type: ɵngcc3.Router }, { type: ɵngcc4.ContextDashboardService }, { type: ɵngcc1.ActionBarService }]; }, null); })();

class WidgetComponent {
    constructor(dashboard, dashboardBridgeService, el) {
        this.dashboard = dashboard;
        this.dashboardBridgeService = dashboardBridgeService;
        this.el = el;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.config) {
                this.ng1Scope = yield this.dashboardBridgeService.instantiateComponent(this.config, this.el.nativeElement);
                if (this.dashboard) {
                    this.resizeSubscription = this.dashboard.onChangeDashboard.subscribe(() => {
                        this.ng1Scope.$broadcast('dashboardResize');
                    });
                }
            }
        });
    }
    ngOnDestroy() {
        if (this.ng1Scope) {
            this.ng1Scope.$destroy();
        }
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
}
WidgetComponent.ɵfac = function WidgetComponent_Factory(t) { return new (t || WidgetComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.WidgetsDashboardComponent, 8), ɵngcc0.ɵɵdirectiveInject(DashboardBridgeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
WidgetComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: WidgetComponent, selectors: [["c8y-widget-legacy"]], decls: 0, vars: 0, template: function WidgetComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
WidgetComponent.ctorParameters = () => [
    { type: WidgetsDashboardComponent, decorators: [{ type: Optional }] },
    { type: DashboardBridgeService },
    { type: ElementRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(WidgetComponent, [{
        type: Component,
        args: [{
                selector: 'c8y-widget-legacy',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc1.WidgetsDashboardComponent, decorators: [{
                type: Optional
            }] }, { type: DashboardBridgeService }, { type: ɵngcc0.ElementRef }]; }, null); })();

class DeviceSelectorComponent {
    constructor(dashboardBridgeService, el) {
        this.dashboardBridgeService = dashboardBridgeService;
        this.el = el;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.ng1Scope = this.dashboardBridgeService.instantiateDeviceSelector(this.el.nativeElement, this.config);
        });
    }
    ngOnDestroy() {
        if (this.ng1Scope) {
            this.ng1Scope.$destroy();
        }
    }
}
DeviceSelectorComponent.ɵfac = function DeviceSelectorComponent_Factory(t) { return new (t || DeviceSelectorComponent)(ɵngcc0.ɵɵdirectiveInject(DashboardBridgeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
DeviceSelectorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DeviceSelectorComponent, selectors: [["c8y-device-selector-legacy"]], decls: 0, vars: 0, template: function DeviceSelectorComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
DeviceSelectorComponent.ctorParameters = () => [
    { type: DashboardBridgeService },
    { type: ElementRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DeviceSelectorComponent, [{
        type: Component,
        args: [{
                selector: 'c8y-device-selector-legacy',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: DashboardBridgeService }, { type: ɵngcc0.ElementRef }]; }, null); })();

class Ng1ComponentFactoryService {
    constructor(bridge) {
        this.bridge = bridge;
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            const components = (yield this.bridge.ng1Components.list()).map(cmp => {
                const data = {
                    settings: Object.assign(Object.assign({}, cmp.options), { configTemplateUrl: cmp.configTemplateUrl, widgetComponent: cmp.widgetComponent, configComponent: cmp.configComponent, transformConfigWithContext: cmp.transformConfigWithContext || cmp.componentTransformConfigWithContext, upgrade: true })
                };
                data.settings.templateUrl = cmp.templateUrl; // workaround as in object it creates build error
                return {
                    id: cmp.name,
                    label: cmp.nameDisplay || cmp.name,
                    description: cmp.description,
                    component: WidgetComponent,
                    configComponent: WidgetComponent,
                    previewImage: cmp.previewImage,
                    data
                };
            });
            // add the device selector legacy component
            components.push({
                id: 'device.selector.legacy',
                label: 'Device selector',
                description: '',
                data: { settings: { noNewWidgets: true, upgrade: true } },
                component: DeviceSelectorComponent
            });
            return components;
        });
    }
}
Ng1ComponentFactoryService.ɵfac = function Ng1ComponentFactoryService_Factory(t) { return new (t || Ng1ComponentFactoryService)(ɵngcc0.ɵɵinject(DashboardBridgeService)); };
Ng1ComponentFactoryService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Ng1ComponentFactoryService, factory: Ng1ComponentFactoryService.ɵfac });
Ng1ComponentFactoryService.ctorParameters = () => [
    { type: DashboardBridgeService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Ng1ComponentFactoryService, [{
        type: Injectable
    }], function () { return [{ type: DashboardBridgeService }]; }, null); })();

class CopyActionComponent {
    constructor(vcRef, dashboardBridgeService) {
        this.vcRef = vcRef;
        this.dashboardBridgeService = dashboardBridgeService;
    }
    ngOnInit() {
        this.vcRef.createEmbeddedView(this.templateCopy);
    }
    copyDashboard() {
        this.dashboardBridgeService.copyDashboard();
    }
}
CopyActionComponent.ɵfac = function CopyActionComponent_Factory(t) { return new (t || CopyActionComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DashboardBridgeService)); };
CopyActionComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CopyActionComponent, selectors: [["c8y-copy-action-legacy"]], viewQuery: function CopyActionComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 7, TemplateRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateCopy = _t.first);
    } }, decls: 2, vars: 0, consts: [["templateCopy", ""], [3, "title", "click"], [1, "dlt-c8y-icon-copy", "m-r-4"], ["translate", ""]], template: function CopyActionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CopyActionComponent_ng_template_0_Template, 6, 3, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
    } }, directives: [ɵngcc1.C8yTranslateDirective], pipes: [ɵngcc1.C8yTranslatePipe], encapsulation: 2 });
CopyActionComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: DashboardBridgeService }
];
CopyActionComponent.propDecorators = {
    templateCopy: [{ type: ViewChild, args: ['templateCopy', { read: TemplateRef, static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CopyActionComponent, [{
        type: Component,
        args: [{
                selector: 'c8y-copy-action-legacy',
                template: `
    <ng-template #templateCopy>
      <li>
        <button title="{{'Copy dashboard' | translate}}" (click)="copyDashboard()">
          <i class="dlt-c8y-icon-copy m-r-4"></i><span translate>Copy dashboard</span>
        </button>
      </li>
    </ng-template>
  `
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: DashboardBridgeService }]; }, { templateCopy: [{
            type: ViewChild,
            args: ['templateCopy', { read: TemplateRef, static: true }]
        }] }); })();

class PasteActionComponent {
    constructor(vcRef, dashboardBridgeService) {
        this.vcRef = vcRef;
        this.dashboardBridgeService = dashboardBridgeService;
        this.dashboardName = '';
    }
    ngOnInit() {
        this.vcRef.createEmbeddedView(this.templatePaste);
        this.dashboardName = this.dashboardBridgeService.dashboardClipboard.c8y_Dashboard.name;
    }
    pasteDashboard() {
        this.dashboardBridgeService.pasteDashboard();
    }
}
PasteActionComponent.ɵfac = function PasteActionComponent_Factory(t) { return new (t || PasteActionComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DashboardBridgeService)); };
PasteActionComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PasteActionComponent, selectors: [["c8y-paste-action-legacy"]], viewQuery: function PasteActionComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c1, 7, TemplateRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templatePaste = _t.first);
    } }, decls: 2, vars: 0, consts: [["templatePaste", ""], [3, "title", "click"], ["c8yIcon", "clipboard", 1, "m-r-4"], ["translate", ""]], template: function PasteActionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, PasteActionComponent_ng_template_0_Template, 9, 4, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
    } }, directives: [ɵngcc1.C8yTranslateDirective], pipes: [ɵngcc1.C8yTranslatePipe], encapsulation: 2 });
PasteActionComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: DashboardBridgeService }
];
PasteActionComponent.propDecorators = {
    templatePaste: [{ type: ViewChild, args: ['templatePaste', { read: TemplateRef, static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PasteActionComponent, [{
        type: Component,
        args: [{
                selector: 'c8y-paste-action-legacy',
                template: `
    <ng-template #templatePaste>
      <li>
        <button title="{{'Paste dashboard' | translate}}" (click)="pasteDashboard()">
          <i class="m-r-4" c8yIcon="clipboard"></i><span translate>Paste dashboard</span>&nbsp;<span
            >"{{ dashboardName }}"</span
          >
        </button>
      </li>
    </ng-template>
  `
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: DashboardBridgeService }]; }, { templatePaste: [{
            type: ViewChild,
            args: ['templatePaste', { read: TemplateRef, static: true }]
        }] }); })();

class Ng1DashboardActionFactoryService {
    constructor(dashboardBridgeService) {
        this.dashboardBridgeService = dashboardBridgeService;
    }
    get(activeRoute) {
        const actions = [];
        const data = !activeRoute.parent || activeRoute.snapshot.data.context
            ? activeRoute.snapshot.data
            : activeRoute.parent.snapshot.data;
        const { contextData } = data;
        const canCopy = contextData &&
            activeRoute.snapshot.data.dashboard &&
            [ViewContext.Device, ViewContext.Group].includes(data.context);
        const canPaste = contextData &&
            [ViewContext.Device, ViewContext.Group].includes(data.context) &&
            this.dashboardBridgeService.dashboardClipboard;
        if (canCopy) {
            actions.push({
                priority: -20,
                placement: 'more',
                template: CopyActionComponent
            });
        }
        if (canPaste) {
            actions.push({
                priority: -10,
                placement: 'more',
                template: PasteActionComponent
            });
        }
        return actions;
    }
}
Ng1DashboardActionFactoryService.ɵfac = function Ng1DashboardActionFactoryService_Factory(t) { return new (t || Ng1DashboardActionFactoryService)(ɵngcc0.ɵɵinject(DashboardBridgeService)); };
Ng1DashboardActionFactoryService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Ng1DashboardActionFactoryService, factory: Ng1DashboardActionFactoryService.ɵfac });
Ng1DashboardActionFactoryService.ctorParameters = () => [
    { type: DashboardBridgeService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Ng1DashboardActionFactoryService, [{
        type: Injectable
    }], function () { return [{ type: DashboardBridgeService }]; }, null); })();

class DashboardUpgradeModule {
}
DashboardUpgradeModule.ɵfac = function DashboardUpgradeModule_Factory(t) { return new (t || DashboardUpgradeModule)(); };
DashboardUpgradeModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DashboardUpgradeModule });
DashboardUpgradeModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [
        {
            provide: DashboardBridgeService,
            useFactory: dashboardBridgeFactory,
            deps: ['$injector', NgZone, Router, [new Optional(), ContextDashboardService], ActionBarService]
        },
        { provide: HOOK_COMPONENTS, useClass: Ng1ComponentFactoryService, multi: true },
        { provide: HOOK_ACTION_BAR, useClass: Ng1DashboardActionFactoryService, multi: true }
    ], imports: [[CommonModule, C8yTranslateModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DashboardUpgradeModule, [{
        type: NgModule,
        args: [{
                declarations: [DeviceSelectorComponent, WidgetComponent, CopyActionComponent, PasteActionComponent],
                entryComponents: [DeviceSelectorComponent, WidgetComponent, CopyActionComponent, PasteActionComponent],
                imports: [CommonModule, C8yTranslateModule],
                providers: [
                    {
                        provide: DashboardBridgeService,
                        useFactory: dashboardBridgeFactory,
                        deps: ['$injector', NgZone, Router, [new Optional(), ContextDashboardService], ActionBarService]
                    },
                    { provide: HOOK_COMPONENTS, useClass: Ng1ComponentFactoryService, multi: true },
                    { provide: HOOK_ACTION_BAR, useClass: Ng1DashboardActionFactoryService, multi: true }
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DashboardUpgradeModule, { declarations: function () { return [DeviceSelectorComponent, WidgetComponent, CopyActionComponent, PasteActionComponent]; }, imports: function () { return [CommonModule, C8yTranslateModule]; } }); })();
function dashboardBridgeFactory(injector, ngZone, router, contextDashboardService, actionBarService) {
    return new DashboardBridgeService(injector, ngZone, router, contextDashboardService, actionBarService);
}

/**
 * Generated bundle index. Do not edit.
 */

export { AuthBridgeService, BridgeService, CopyActionComponent, DashboardBridgeService, DashboardUpgradeModule, DeviceSelectorComponent, HybridAppModule, Ng1ActionBarFactoryService, Ng1ActionFactoryService, Ng1BreadcrumbFactoryService, Ng1ComponentFactoryService, Ng1DashboardActionFactoryService, Ng1DocsFactoryService, Ng1NodesFactoryService, Ng1TabsFactoryService, PasteActionComponent, UPGRADE_ROUTES, UpgradeModule, WidgetComponent, authBridgeServiceFactory, authBridgeServiceProvider, bridgeServiceFactory, bridgeServiceProvider, dashboardBridgeFactory, ng1Modules, AbsoluteDateService as ɵa, absoluteDateServiceFactory as ɵb, absoluteDateServiceProvider as ɵc };

//# sourceMappingURL=c8y-ngx-components-upgrade.js.map