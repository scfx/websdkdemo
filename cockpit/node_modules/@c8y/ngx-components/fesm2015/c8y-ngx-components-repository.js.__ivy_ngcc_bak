import { Pipe, EventEmitter, Injectable, Component, Input, Output, ViewChild, ChangeDetectionStrategy, ChangeDetectorRef, ElementRef, HostListener, NgModule } from '@angular/core';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { gettext, AlertService, OperationRealtimeService, AppStateService, Status, ModalService, FilterInputComponent, memoize, ModalSelectionMode, NavigatorNode, CellRendererContext, FilteringFormRendererContext, TypeaheadComponent, ViewContext, CoreModule, FormsModule, HOOK_NAVIGATOR_NODES, HOOK_ROUTE } from '@c8y/ngx-components';
import { SingleOperationDetailsModule } from '@c8y/ngx-components/operations/single-operation-details';
import { BsDropdownModule } from 'ngx-bootstrap/dropdown';
import { PopoverModule } from 'ngx-bootstrap/popover';
import { TabsModule } from 'ngx-bootstrap/tabs';
import { TooltipModule } from 'ngx-bootstrap/tooltip';
import { __awaiter, __decorate } from 'tslib';
import { QueriesUtil, OperationStatus, InventoryService, InventoryBinaryService, OperationService, EventService, EventBinaryService, UserService, Realtime, Service, FetchClient, ApplicationService } from '@c8y/client';
import { map, take, switchMap, withLatestFrom, filter, takeWhile, mergeMap, tap, shareReplay, distinctUntilChanged, debounceTime, distinctUntilKeyChanged, takeUntil } from 'rxjs/operators';
import { saveAs } from 'file-saver';
import { BsModalRef, BsModalService } from 'ngx-bootstrap/modal';
import { isNil, set, assign, isUndefined, get, isString, head, cloneDeep, map as map$1, pick, remove, forEach, find, has, uniqBy, property, isEmpty, indexOf, filter as filter$1 } from 'lodash-es';
import { of, from, defer, throwError, merge, pipe, Subject, BehaviorSubject, combineLatest, NEVER } from 'rxjs';
import { TranslateService } from '@ngx-translate/core';
import { BaseDeviceGridColumn, DeviceGridService } from '@c8y/ngx-components/device-grid';

class ConfigurationFilterPipe {
    transform(items, filterTerm) {
        return filterTerm.trim().length === 0
            ? items
            : items.filter((item) => this.filterContainString(item.name, filterTerm) ||
                this.filterContainString(item.deviceType, filterTerm));
    }
    filterContainString(name, filterTerm) {
        const term = filterTerm.toLowerCase().trim();
        return name && name.toLowerCase().indexOf(term) > -1;
    }
}
ConfigurationFilterPipe.decorators = [
    { type: Pipe, args: [{
                name: 'configurationFilterPipe'
            },] }
];

var RepositoryType;
(function (RepositoryType) {
    RepositoryType["FIRMWARE"] = "c8y_Firmware";
    RepositoryType["SOFTWARE"] = "c8y_Software";
    RepositoryType["CONFIGURATION"] = "c8y_ConfigurationDump";
})(RepositoryType || (RepositoryType = {}));
const REPOSITORY_BINARY_TYPES = {
    [RepositoryType.SOFTWARE]: 'c8y_SoftwareBinary',
    [RepositoryType.FIRMWARE]: 'c8y_FirmwareBinary',
    [RepositoryType.CONFIGURATION]: 'c8y_ConfigurationDumpBinary'
};
var DeviceConfigurationOperation;
(function (DeviceConfigurationOperation) {
    DeviceConfigurationOperation["UPLOAD_CONFIG"] = "c8y_UploadConfigFile";
    DeviceConfigurationOperation["DOWNLOAD_CONFIG"] = "c8y_DownloadConfigFile";
    DeviceConfigurationOperation["CONFIG"] = "c8y_Configuration";
    DeviceConfigurationOperation["SEND_CONFIG"] = "c8y_SendConfiguration";
})(DeviceConfigurationOperation || (DeviceConfigurationOperation = {}));

class DeviceConfigurationService {
    constructor() {
        this.configurationsUpdated = new EventEmitter();
    }
    updateConfigurations(repositorySnapsOnly) {
        this.configurationsUpdated.emit(repositorySnapsOnly);
    }
    hasAnySupportedOperation(mo, operation) {
        const supported = mo.c8y_SupportedOperations;
        if (!supported) {
            return false;
        }
        if (!Array.isArray(operation)) {
            operation = [operation];
        }
        return supported.some(supportedOperation => operation.includes(supportedOperation));
    }
}
DeviceConfigurationService.decorators = [
    { type: Injectable }
];

class RepositoryService {
    constructor(inventory, inventoryBinary, operation, alert, event, operationRealtime, eventBinary) {
        this.inventory = inventory;
        this.inventoryBinary = inventoryBinary;
        this.operation = operation;
        this.alert = alert;
        this.event = event;
        this.operationRealtime = operationRealtime;
        this.eventBinary = eventBinary;
        this.dateFrom = new Date(0);
        this.dateTo = new Date(Date.now() + 86400000); // 1 day in the future
        this.queriesUtil = new QueriesUtil();
    }
    /**
     * Lists repository entries of given type.
     * @param type The type of repository entries to list.
     * @param options Extra listing options.
     */
    listRepositoryEntries(type, options) {
        const defaultOrder = [{ name: 1 }];
        const defaultFilters = { type };
        const legacyFilters = { __has: `url` };
        let filters = {};
        let fullQuery = (options && options.query) || {};
        if (!options || (options && !options.skipDefaultOrder)) {
            fullQuery = this.queriesUtil.addOrderbys(fullQuery, defaultOrder, 'prepend');
        }
        fullQuery = this.queriesUtil.addAndFilter(fullQuery, defaultFilters);
        if (options && options.partialTextFilter) {
            const { partialText, properties } = options.partialTextFilter;
            const orFilter = { __or: properties.map(property => ({ [property]: `*${partialText}*` })) };
            fullQuery = this.queriesUtil.addAndFilter(fullQuery, orFilter);
        }
        if (options && options.partialName) {
            // backwards compatibility if
            fullQuery = this.queriesUtil.addAndFilter(fullQuery, { name: `*${options.partialName}*` });
        }
        if (options && options.skipLegacy) {
            fullQuery = this.queriesUtil.addAndFilter(fullQuery, { __not: legacyFilters });
        }
        filters = Object.assign({ query: this.queriesUtil.buildQuery(fullQuery), pageSize: 50, withTotalPages: true }, ((options && options.params) || {}));
        return this.inventory.list(filters);
    }
    // TODO: merge with create()
    save(data, type, mo = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (type) {
                case RepositoryType.CONFIGURATION: {
                    Object.assign(mo, {
                        type: RepositoryType.CONFIGURATION,
                        configurationType: data.selected ? data.selected.configurationType : undefined,
                        name: data.version,
                        description: data.description,
                        deviceType: data.deviceType,
                        c8y_Global: {}
                    });
                    if (!data.deviceType && mo.id) {
                        mo.deviceType = null;
                    }
                    if (!data.selected && mo.id) {
                        mo.configurationType = null;
                    }
                    break;
                }
            }
            const existingUrl = mo.url;
            if (data.binary.url) {
                mo.url = data.binary.url;
            }
            else if (data.binary.file) {
                const response = yield this.inventoryBinary.create(data.binary.file, {
                    c8y_Global: {}
                });
                mo.url = response.data.self;
            }
            if (mo.id) {
                return this.updateEntry(mo, existingUrl);
            }
            return this.createEntry(mo);
        });
    }
    create(modal, type) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (type) {
                case RepositoryType.FIRMWARE:
                case RepositoryType.SOFTWARE:
                    return this.createFirmwareOrSoftware(modal, type);
            }
        });
    }
    createFirmwareOrSoftware(modal, type) {
        return __awaiter(this, void 0, void 0, function* () {
            let binary;
            let binaryURL;
            let repositoryEntry;
            let repositoryBinary;
            const mos = [];
            const { selected: { id: selectedId }, binary: { file, url } } = modal;
            try {
                if (file) {
                    ({ data: binary } = yield this.saveBinary(file));
                    ({ self: binaryURL } = binary);
                    mos.push(binary);
                }
                else {
                    binaryURL = url;
                }
                ({ data: repositoryEntry } = yield this.createOrUpdateRepositoryEntry(modal, type));
                if (isNil(selectedId)) {
                    mos.push(repositoryEntry);
                }
                ({ data: repositoryBinary } = yield this.createRepositoryBinary(modal, binaryURL, type, repositoryEntry));
                mos.push(repositoryBinary);
                if (file) {
                    yield this.linkBinary(repositoryBinary, binary);
                }
                return repositoryEntry;
            }
            catch (error) {
                this.cleanUp(mos);
                this.errorMsg();
                // Propagate error
                throw error;
            }
        });
    }
    saveBinary(file) {
        return this.inventoryBinary.create(file, { c8y_Global: {} });
    }
    createOrUpdateRepositoryEntry(modal, type) {
        const { selected: { id, name }, description, deviceType } = modal;
        const mo = {
            id,
            name: id ? undefined : name,
            description,
            type: id ? undefined : type,
            c8y_Global: {}
        };
        if (deviceType) {
            set(mo, 'c8y_Filter.type', deviceType);
        }
        if (modal.softwareType) {
            set(mo, 'softwareType', modal.softwareType.softwareType);
        }
        return id
            ? this.inventory.update(mo)
            : this.inventory.create(mo);
    }
    createRepositoryBinary(modal, binaryURL, type, parent) {
        const mo = this.prepareRepositoryBinaryMO(modal, binaryURL, type);
        return this.inventory.childAdditionsCreate(mo, parent);
    }
    prepareRepositoryBinaryMO(modal, binaryURL, type) {
        const { version, patchVersion, dependency } = modal;
        const result = {
            type: REPOSITORY_BINARY_TYPES[type],
            [type]: {
                url: binaryURL
            },
            c8y_Global: {}
        };
        if (dependency) {
            set(result, [type, 'version'], patchVersion);
            assign(result, {
                c8y_Patch: {
                    dependency: dependency.c8y_Firmware.version
                }
            });
        }
        else {
            set(result, [type, 'version'], version);
        }
        return result;
    }
    linkBinary(repositoryBinary, binary) {
        return __awaiter(this, void 0, void 0, function* () {
            const { id: repositoryBinaryId } = repositoryBinary;
            if (binary) {
                const { id: binaryId } = binary;
                return this.inventory.childAdditionsAdd(binaryId, repositoryBinaryId);
            }
        });
    }
    cleanUp(mosToDelete) {
        mosToDelete.forEach(mo => {
            const { c8y_IsBinary } = mo;
            isUndefined(c8y_IsBinary) ? this.delete(mo) : this.inventoryBinary.delete(mo);
        });
    }
    delete(entity) {
        return this.inventory.delete(entity, { forceCascade: true });
    }
    errorMsg() {
        const msg = gettext('Failed to save');
        this.alert.danger(msg);
    }
    getBaseVersionsCount$(entry) {
        if (this.isLegacyEntry(entry)) {
            return of(1);
        }
        return from(this.listBaseVersions(entry, { pageSize: 1, withTotalPages: true })).pipe(map(({ paging }) => paging.totalPages));
    }
    getBaseVersionFromMO(mo) {
        return this.isPatch(mo) ? get(mo, 'c8y_Patch.dependency') : get(mo, 'c8y_Firmware.version');
    }
    isPatch(mo) {
        return !!get(mo, 'c8y_Patch.dependency');
    }
    getPatchVersionsCount$(entry, baseVersion) {
        if (this.isLegacyEntry(baseVersion)) {
            return of(0);
        }
        return from(this.listPatchVersions(entry, baseVersion, { pageSize: 1, withTotalPages: true })).pipe(map(({ paging }) => paging.totalPages));
    }
    isLegacyEntry(entry) {
        return Boolean(entry.url);
    }
    /**
     * Lists all versions (base and patch ones) of given top level entry.
     * Versions are ordered by creation time (assuming the earlier created, the older the version).
     * @param entry Top level repository entry.
     * @param params Additional query params.
     */
    listAllVersions(entry, params = {}) {
        if (this.isLegacyEntry(entry)) {
            return this.getBaseVersionResultListForLegacyEntry(entry);
        }
        const VERSION_FILTER_ORDER = {
            __filter: {},
            __orderby: [{ 'creationTime.date': -1 }, { creationTime: -1 }]
        };
        return this.listChildren(entry, VERSION_FILTER_ORDER, params);
    }
    /**
     * Lists base versions of given top level entry.
     * Versions are ordered by creation time (assuming the earlier created, the older the version).
     * @param entry Top level repository entry.
     * @param params Additional query params.
     */
    listBaseVersions(entry, params = {}) {
        if (this.isLegacyEntry(entry)) {
            return this.getBaseVersionResultListForLegacyEntry(entry);
        }
        const NO_PATCH_FILTER_ORDER = {
            __filter: {
                __not: { __has: 'c8y_Patch' }
            },
            __orderby: [{ 'creationTime.date': -1 }, { creationTime: -1 }]
        };
        return this.listChildren(entry, NO_PATCH_FILTER_ORDER, params);
    }
    /**
     * Lists patch versions of given base version under the entry.
     * Versions are ordered by creation time (assuming the earlier created, the older the version).
     * @param entry Top level repository entry.
     * @param baseVersion Base version.
     * @param params Additional query params.
     */
    listPatchVersions(entry, baseVersion, params = {}) {
        const version = isString(baseVersion) ? baseVersion : get(baseVersion, 'c8y_Firmware.version');
        const PATCH_FILTER_ORDER = {
            __filter: {
                'c8y_Patch.dependency': version
            },
            __orderby: [{ 'creationTime.date': -1 }, { creationTime: -1 }]
        };
        return this.listChildren(entry, PATCH_FILTER_ORDER, params);
    }
    /**
     * Lists patch versions of given base version under the entry including the base version.
     * Versions are ordered by creation time (assuming the earlier created, the older the version).
     * In terms of legacy base version the entry gets transformed to fit the needed data model.
     * @param entry Top level repository entry.
     * @param baseVersion Base version.
     * @param params Additional query params.
     */
    listBaseVersionAndPatches(entry, baseVersion, params = {}) {
        if (this.isLegacyEntry(entry)) {
            return Promise.resolve({
                data: [
                    Object.assign({
                        c8y_Firmware: {
                            version: entry.version,
                            url: entry.url
                        }
                    }, entry)
                ]
            });
        }
        const PATCH_FILTER_ORDER = {
            __filter: {
                __or: {
                    'c8y_Patch.dependency': baseVersion.c8y_Firmware.version,
                    'c8y_Firmware.version': baseVersion.c8y_Firmware.version
                }
            },
            __orderby: [{ 'c8y_Patch.dependency': 1 }, { 'c8y_Firmware.version': 1 }]
        };
        return this.listChildren(entry, PATCH_FILTER_ORDER, params);
    }
    listChildren(entry, filters = {}, params = {}) {
        const childrenFilters = { __bygroupid: entry.id };
        const query = this.queriesUtil.addAndFilter(filters, childrenFilters);
        // FIXME: needed because of issue in forOf directive (...)
        params.withTotalPages = true;
        return this.inventory.listQuery(query, params);
    }
    /**
     * Fetches all items from the list starting with the provided page.
     * @param firstPage The first page of the list to fetch all items for.
     */
    fetchAllItemsFromList(firstPage) {
        return __awaiter(this, void 0, void 0, function* () {
            let allItems;
            if (!firstPage.then) {
                allItems = [...firstPage];
            }
            else {
                let { paging, data: items } = yield firstPage;
                allItems = [...items];
                while (paging && paging.nextPage) {
                    ({ paging, data: items } = yield paging.next());
                    allItems = [...allItems, ...items];
                }
            }
            return allItems;
        });
    }
    /**
     * Gets top level repository entry managed object for base or patch version.
     * @param mo Base or patch version managed object with parents.
     */
    getRepositoryEntryMO$(mo) {
        if (!mo) {
            return of(undefined);
        }
        const [reference] = get(mo, 'additionParents.references');
        const id = get(reference, 'managedObject.id');
        return id
            ? from(this.inventory.detail(id, { withChildren: false })).pipe(map(({ data }) => data))
            : of(undefined);
    }
    /**
     * Gets base or patch version managed object.
     * @param deviceRepositoryFragment Device repository fragment.
     * @param type Top level repository entry type.
     * @param configuration Configuration object with options:
     * - **skipLegacy** - `boolean` - Exclude legacy entries.
     * - **filters** - `object` - Filter object.
     *
     * @deprecated as it doesn't support 'missing url' case
     */
    getRepositoryBinaryMoByVersion(deviceRepositoryFragment, type, { skipLegacy = false, filters = {} } = {}) {
        const { version, url, name } = deviceRepositoryFragment;
        const repositoryBinaryType = REPOSITORY_BINARY_TYPES[type];
        let query;
        const newModelBaseVersionQuery = {
            [`${type}.version`]: version,
            [`${type}.url`]: url,
            type: repositoryBinaryType
        };
        const legacyVersionQuery = { url, type, name };
        filters = Object.assign({ withChildren: false, withParents: true }, filters);
        if (skipLegacy) {
            query = {
                __and: Object.assign({}, newModelBaseVersionQuery)
            };
        }
        else {
            query = {
                __or: [{ __and: Object.assign({}, newModelBaseVersionQuery) }, { __and: Object.assign({}, legacyVersionQuery) }]
            };
        }
        return this.inventory.listQuery(query, filters).then(({ data }) => head(data));
    }
    getBinaryName$(binaryUrl) {
        if (!binaryUrl) {
            return of('---');
        }
        const binaryId = this.inventoryBinary.getIdFromUrl(binaryUrl);
        if (!binaryId) {
            return of(binaryUrl);
        }
        return defer(() => this.inventory.detail(binaryId).then(result => result.data)).pipe(map(mo => mo.name));
    }
    /**
     * Generates an inventory query object which can be used to find
     * repository entries of specified type matching the type of provided device.
     * @param repositoryType The type of repository entries which will be queried with the generated query.
     * @param device The device for which matching repository entries will be queried with the generated query.
     */
    getDeviceTypeQuery(repositoryType, device) {
        let result = { type: repositoryType };
        if (repositoryType === RepositoryType.CONFIGURATION) {
            if (device.type) {
                result = this.queriesUtil.addAndFilter(result, {
                    __or: [{ deviceType: device.type }, { __not: { __has: `deviceType` } }]
                });
            }
        }
        else {
            result = this.queriesUtil.addAndFilter(result, {
                __or: [
                    { 'c8y_Filter.type': device.type },
                    { 'c8y_Filter.type': '' },
                    { __not: { __has: `c8y_Filter.type` } }
                ]
            });
        }
        return result;
    }
    /**
     * Generates an inventory query object which can be used to find configuration repository entries
     * matching the type of provided device and specified configuration type.
     * @param device The device for which matching repository entries will be queried with the generated query.
     * @param configurationType Configuration type for which matching repository entries will be queried with the generated query.
     */
    getConfigurationTypeQuery(device, configurationType) {
        const query = this.getDeviceTypeQuery(RepositoryType.CONFIGURATION, device);
        return this.queriesUtil.addAndFilter(query, {
            __or: [
                { configurationType },
                { configurationType: '' },
                { __not: { __has: `configurationType` } }
            ]
        });
    }
    /**
     * Gets the list of software installed in the device in the uniform format.
     * Supports c8y_SoftwareList and c8y_Software fragments.
     * @param device The device whose software list should be returned.
     */
    getDeviceSoftwareList(device) {
        if (device.c8y_SoftwareList) {
            return cloneDeep(device.c8y_SoftwareList);
        }
        if (device.c8y_Software) {
            return map$1(device.c8y_Software, (version, name) => ({ name, version }));
        }
        return [];
    }
    /**
     * Prepares a software update operation for given device and the list of changes, and sends it to the device.
     * @param device The device which the operation should be prepared for and sent to.
     * @param changes The list of software changes which should be applied.
     */
    createSoftwareUpdateOperation(device, changes) {
        return __awaiter(this, void 0, void 0, function* () {
            const operation = this.getSoftwareUpdateOperation(device, changes);
            return (yield this.operation.create(operation)).data;
        });
    }
    /**
     * Prepares a software update operation for given device and changes.
     * Returned operation type depends on device's supported operations.
     * Supports c8y_SoftwareUpdate, c8y_SoftwareList, and c8y_Software operations.
     * @param device The device for which operation should be prepared.
     * @param changes The list of software changes which should be applied.
     */
    getSoftwareUpdateOperation(device, changes) {
        const operation = {
            deviceId: device.id,
            description: `Apply software changes: ${changes
                .map(change => `${change.action} "${change.name}"${change.version ? ` (version: ${change.version})` : ''}`)
                .join(', ')}`
        };
        if (device.c8y_SupportedOperations.includes('c8y_SoftwareUpdate')) {
            operation.c8y_SoftwareUpdate = cloneDeep(changes);
        }
        else if (device.c8y_SupportedOperations.includes('c8y_SoftwareList')) {
            operation.c8y_SoftwareList = cloneDeep(device.c8y_SoftwareList) || [];
            changes.forEach(change => {
                const deviceSoftware = pick(change, ['name', 'version', 'url']);
                if (change.action === 'delete') {
                    remove(operation.c8y_SoftwareList, deviceSoftware);
                }
                if (change.action === 'install') {
                    operation.c8y_SoftwareList.push(deviceSoftware);
                }
            });
        }
        else if (device.c8y_SupportedOperations.includes('c8y_Software')) {
            operation.c8y_Software = cloneDeep(device.c8y_Software) || {};
            changes.forEach(change => {
                if (change.action === 'delete') {
                    delete operation.c8y_Software[change.name];
                }
                if (change.action === 'install') {
                    operation.c8y_Software[change.name] = change.version;
                }
            });
        }
        return operation;
    }
    /**
     * Extracts the list of device software changes from given operation in the context of given device.
     * @param operation The operation from which the list should be extracted.
     * @param device The target device of the operation.
     */
    getDeviceSoftwareChangesFromOperation(operation, device) {
        if (operation.c8y_SoftwareUpdate) {
            return cloneDeep(operation.c8y_SoftwareUpdate);
        }
        if (operation.c8y_SoftwareList) {
            return this.getDeviceSoftwareChangesFromSoftwareListOperation(operation, device);
        }
        if (operation.c8y_Software) {
            return this.getDeviceSoftwareChangesFromSoftwareOperation(operation, device);
        }
        return [];
    }
    /**
     * Prepares a firmware update operation for given device and the selected repository binary, and sends it to the device.
     * @param device The device which the operation should be prepared for and sent to.
     * @param selectedOption The selected repository binary option.
     */
    createFirmwareUpdateOperation(device, selectedOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const operation = this.getFirmwareUpdateOperation(device, selectedOption);
            return (yield this.operation.create(operation)).data;
        });
    }
    /**
     * Prepares a firmware update operation for given device and selected version.
     * Supports c8y_Firmware operation.
     * @param device The device for which operation should be prepared.
     * @param selectedOption Selected firmware version.
     */
    getFirmwareUpdateOperation(device, selectedOption) {
        delete selectedOption.id;
        const operation = {
            deviceId: device.id,
            description: `Update firmware to: "${selectedOption.name}"${selectedOption.version ? ` (version: ${selectedOption.version})` : ''}`,
            c8y_Firmware: Object.assign({}, selectedOption)
        };
        return operation;
    }
    /**
     * Prepares a configuration file upload operation for given device and configuration type.
     * @param device The device for which operation should be prepared.
     * @param configurationType Selected configuration type.
     * @param isLegacy  A legacy operation is created without a configurationType.
     */
    getUploadConfigurationFileOperation(device, configurationType, isLegacy = false) {
        if (isLegacy) {
            return {
                deviceId: device.id,
                description: `Retrieve configuration snapshot from device ${device.name}`,
                c8y_UploadConfigFile: {}
            };
        }
        return {
            deviceId: device.id,
            description: `Retrieve ${configurationType} configuration snapshot from device ${device.name}`,
            c8y_UploadConfigFile: {
                type: configurationType
            }
        };
    }
    /**
     * Prepares a configuration file download operation for given device and configuration type.
     * @param device The device for which operation should be prepared.
     * @param configurationType Selected configuration type.
     * @param binaryUrl The url of a binary to be downloaded.
     * @param isLegacy A legacy operation is created without a configurationType.
     */
    getDownloadConfigurationFileOperation(device, configurationType, configSnapshot, isLegacy = false) {
        if (isLegacy) {
            return {
                deviceId: device.id,
                description: `Send configuration snapshot ${configSnapshot.name} to device ${device.name}`,
                c8y_DownloadConfigFile: {
                    url: configSnapshot.binaryUrl,
                    c8y_ConfigurationDump: {
                        id: configSnapshot.id
                    }
                }
            };
        }
        return {
            deviceId: device.id,
            description: `Send configuration snapshot ${configSnapshot.name} of configuration type ${configurationType} to device ${device.name}`,
            c8y_DownloadConfigFile: {
                url: configSnapshot.binaryUrl,
                type: configurationType
            }
        };
    }
    /**
     * Gets the last firmware update operation for given device.
     * Looks for c8y_Firmware operations.
     * @param deviceId The ID of the device to find an operation for.
     */
    getLastFirmwareUpdateOperation(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = {
                deviceId,
                dateFrom: new Date(0).toISOString(),
                dateTo: new Date(Date.now()).toISOString(),
                revert: true,
                pageSize: 1
            };
            return this.getFirstMatchingOperation([Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_Firmware' })]);
        });
    }
    /**
     * Gets the last software update operation for given device.
     * Looks for c8y_SoftwareUpdate, c8y_SoftwareList, or c8y_Software operations.
     * @param deviceId The ID of the device to find an operation for.
     */
    getLastSoftwareUpdateOperation(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = {
                deviceId,
                dateFrom: new Date(0).toISOString(),
                dateTo: new Date(Date.now()).toISOString(),
                revert: true,
                pageSize: 1
            };
            return this.getFirstMatchingOperation([
                Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_SoftwareUpdate' }),
                Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_SoftwareList' }),
                Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_Software' })
            ]);
        });
    }
    /**
     * Iterates over the list of filters and queries the operations.
     * If a query returns at least one operation, the first one will be returned.
     * Otherwise the next query will be performed.
     * If none of the queries returns any operation, null will be returned.
     * @param filtersList The list of filters for the queries.
     */
    getFirstMatchingOperation(filtersList) {
        return __awaiter(this, void 0, void 0, function* () {
            let matchingOperation = null;
            for (const filters of filtersList) {
                const operations = (yield this.operation.list(filters)).data;
                if (operations.length) {
                    matchingOperation = operations[0];
                    break;
                }
            }
            return matchingOperation;
        });
    }
    /**
     * Iterates over the list of filters and queries the operations.
     * It compares the operations retrieved by the queries by 'creationTime'
     * and return the latest one.
     * If none of the queries returns any operation, null will be returned.
     * @param filtersList The list of filters for the queries.
     */
    getLatestMatchingOperation(filtersList) {
        return __awaiter(this, void 0, void 0, function* () {
            let matchingOperation = null;
            for (const filters of filtersList) {
                const operations = (yield this.operation.list(filters)).data;
                if (operations.length) {
                    if (matchingOperation) {
                        matchingOperation =
                            new Date(matchingOperation.creationTime).getTime() <
                                new Date(operations[0].creationTime).getTime()
                                ? operations[0]
                                : matchingOperation;
                    }
                    else {
                        matchingOperation = operations[0];
                    }
                }
            }
            return matchingOperation;
        });
    }
    /**
     * Creates the operation and returns an observable to track its progress.
     * Fails the observable when the operation returns FAILED status.
     * Completes the observable when the operation returns SUCCESSFUL status.
     * @param operation The operation to create and track.
     */
    createObservedOperation(operation) {
        return from(this.operation.create(operation)).pipe(map(({ data }) => data), take(1), switchMap(createdOperation => this.observeOperation(createdOperation)));
    }
    /**
     * Returns an observable to track progress of given operation.
     * Fails the observable when the operation returns FAILED status.
     * Completes the observable when the operation returns SUCCESSFUL status.
     * @param operation The operation to be observed.
     */
    observeOperation(operation) {
        const observedOperation$ = of(operation);
        const operationUpdates$ = observedOperation$.pipe(switchMap(observedOperation => this.operationRealtime.onAll$(observedOperation.deviceId)), map(({ data }) => data), withLatestFrom(observedOperation$), filter(([operationUpdate, observedOperation]) => operationUpdate.id === observedOperation.id), switchMap(([operationUpdate]) => {
            if (operationUpdate.status === OperationStatus.FAILED) {
                return throwError(operationUpdate);
            }
            return of(operationUpdate);
        }), takeWhile(operationUpdate => operationUpdate.status !== OperationStatus.SUCCESSFUL, true));
        return merge(observedOperation$, operationUpdates$);
    }
    /**
     * Gets a single event with latest creationTime for the given device Id and event type.
     * @param deviceId The device Id for which the events should be queried.
     * @param type Event type.
     */
    getLatestConfigurationEvent(deviceId, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventFilter = {
                source: deviceId,
                type,
                dateFrom: this.dateFrom.toISOString(),
                dateTo: this.dateTo.toISOString(),
                pageSize: 1
            };
            const { data } = yield this.event.list(eventFilter);
            return data[0];
        });
    }
    /**
     * Gets a list of operations for the given device Id, and operation type.
     * @param deviceId The device Id for which the operation should be queried.
     * @param operationType Operation type fragment.
     */
    getConfigFileOperationList(deviceId, operationType) {
        return __awaiter(this, void 0, void 0, function* () {
            const operationFilter = {
                deviceId,
                fragmentType: operationType,
                dateFrom: this.dateFrom.toISOString(),
                dateTo: this.dateTo.toISOString(),
                revert: true,
                pageSize: 2000
            };
            return (yield this.operation.list(operationFilter)).data;
        });
    }
    /**
     * Gets latest uploaded configuration snapshot for the given device, and configuration type.
     * @param device The device for which the configuration snapshot was uploaded.
     * @param configurationType Selected configuration type.
     */
    getConfigSnapshot(device, configurationType) {
        return __awaiter(this, void 0, void 0, function* () {
            const event = yield this.getLatestConfigurationEvent(device.id, configurationType);
            let configSnapshot;
            if (event) {
                configSnapshot = {
                    time: event.time,
                    name: event.text,
                    deviceType: device.type,
                    configurationType
                };
                try {
                    configSnapshot.binary = yield (yield this.eventBinary.download(event)).text();
                    if (event.c8y_IsBinary) {
                        configSnapshot.binaryType = event.c8y_IsBinary.type;
                    }
                }
                catch (ex) {
                    const msg = gettext('Could not get the binary.');
                    this.alert.danger(msg);
                }
            }
            return configSnapshot;
        });
    }
    getLegacyConfigSnapshot(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            let configSnapshot;
            let mo;
            const device = (yield this.inventory.detail(deviceId, { withChildren: false })).data;
            const snapshotId = device.c8y_ConfigurationDump && device.c8y_ConfigurationDump.id;
            if (!snapshotId) {
                return;
            }
            try {
                mo = (yield this.inventory.detail(snapshotId)).data;
            }
            catch (ex) {
                // do nothing
            }
            if (mo) {
                configSnapshot = {
                    time: mo.creationTime,
                    name: mo.name
                };
                configSnapshot.binary = yield this.getBinaryText(mo.url, { allowExternal: false });
            }
            return configSnapshot;
        });
    }
    /**
     * Returns a binary object as text.
     * @param binaryUrl The URL to find binary
     * @param options The object with additional options:
     * - **allowExternal** - `boolean` - allows downloading external binary file
     * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`
     */
    getBinaryText(binaryUrl, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const binaryId = this.inventoryBinary.getIdFromUrl(binaryUrl);
            let res;
            if (!binaryId && options.allowExternal) {
                res = yield this.getExternalBinaryResponse(binaryUrl, options);
            }
            else {
                res = yield this.getInternalBinaryResponse(binaryId, options);
            }
            if (!res) {
                return null;
            }
            return res.text();
        });
    }
    /**
     * Returns a binary object as File.
     * @param binaryUrl The URL to find binary
     * @param options The object with additional options:
     * - **allowExternal** - `boolean` - allows downloading external binary file
     */
    getBinaryFile(binaryUrl, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const binaryId = this.inventoryBinary.getIdFromUrl(binaryUrl);
            if (!binaryId && !options.allowExternal) {
                return null;
            }
            // @TODO: note that it doesn't solve issue with external binary here, such url won't have binaryId, so we won't know the name or contentType to use in File constructor, let's add a @FIXME comment for now?
            const { name, contentType } = (yield this.inventory.detail(binaryId)).data;
            const res = !!binaryId
                ? yield this.getInternalBinaryResponse(binaryId)
                : yield this.getExternalBinaryResponse(binaryUrl);
            const arrayBuffer = yield res.arrayBuffer();
            return new File([arrayBuffer], name, { type: contentType });
        });
    }
    /**
     * Gets the last configuration update operation for given device.
     * Looks for c8y_Configuration and c8y_SendConfiguration operations.
     * @param deviceId The ID of the device to find an operation for.
     */
    getLastConfigUpdateOperation(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = {
                deviceId,
                dateFrom: new Date(0).toISOString(),
                dateTo: new Date(Date.now()).toISOString(),
                revert: true,
                pageSize: 1
            };
            return this.getLatestMatchingOperation([
                Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_Configuration' }),
                Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_SendConfiguration' })
            ]);
        });
    }
    /**
     * Prepares a configuration download operation for given device and its current configuration.
     * Supports c8y_SendConfiguration operation.
     * @param device The device for which operation should be prepared.
     */
    createTextBasedConfigurationReloadOperation(device) {
        return {
            deviceId: device.id,
            description: gettext('Requested current configuration'),
            c8y_SendConfiguration: {}
        };
    }
    /**
     * Prepares a configuration update operation for the given device.
     * Supports c8y_Configuration operation.
     * @param device The device for which operation should be prepared.
     * @param config The configuration which will update the existing one.
     */
    createTextBasedConfigurationUpdateOperation(device, config) {
        return {
            deviceId: device.id,
            description: gettext('Configuration update'),
            c8y_Configuration: {
                config
            }
        };
    }
    getBinary(binaryId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.inventoryBinary.download(binaryId);
            }
            catch (ex) {
                const msg = gettext('Could not get the binary.');
                this.alert.danger(msg);
            }
        });
    }
    /**
     * Gets all available snapshots from the repository for the given device.
     * @param device The device for which the snapshots should be prepared.
     * @param configurationType Selected configuration type.
     */
    getSnapshotsFromRepository(device, configurationType) {
        return __awaiter(this, void 0, void 0, function* () {
            const searchQuery = this.getConfigurationTypeQuery(device, configurationType);
            const res = yield this.listRepositoryEntries(RepositoryType.CONFIGURATION, {
                query: searchQuery,
                params: { pageSize: 100 }
            });
            return res.data;
        });
    }
    /**
     * Returns a binary object.
     * @param binaryId binary ID
     * @param options The object with additional options:
     * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`
     */
    getInternalBinaryResponse(binaryId, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let res;
            try {
                res = yield this.inventoryBinary.download(binaryId);
            }
            catch (ex) {
                if (!options.noAlerts) {
                    const msg = gettext('Could not get the binary.');
                    this.alert.danger(msg);
                }
            }
            return res;
        });
    }
    /**
     * Returns a binary object.
     * @param binaryUrl The URL to find binary
     * @param options The object with additional options:
     * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`
     */
    getExternalBinaryResponse(binaryUrl, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let res;
            try {
                const fetchRes = yield fetch(binaryUrl);
                if (fetchRes.status >= 400) {
                    throw res;
                }
                res = fetchRes;
            }
            catch (_a) {
                if (!options.noAlerts) {
                    const msg = gettext('Could not get the external binary');
                    this.alert.danger(msg);
                }
            }
            return res;
        });
    }
    createEntry(mo) {
        return __awaiter(this, void 0, void 0, function* () {
            const binaryId = yield this.inventoryBinary.getIdFromUrl(mo.url);
            const newMo = yield this.inventory.create(mo);
            if (binaryId) {
                yield this.inventory.childAdditionsAdd(binaryId, newMo.data);
            }
            return newMo;
        });
    }
    updateEntry(mo, url) {
        return __awaiter(this, void 0, void 0, function* () {
            const existingBinaryId = yield this.inventoryBinary.getIdFromUrl(url);
            const newBinaryId = yield this.inventoryBinary.getIdFromUrl(mo.url);
            if (existingBinaryId && existingBinaryId !== newBinaryId) {
                const id = this.inventoryBinary.getIdFromUrl(url);
                yield this.inventoryBinary.delete(id);
            }
            if (newBinaryId) {
                yield this.inventory.childAdditionsAdd(newBinaryId, mo);
            }
            return this.inventory.update(mo);
        });
    }
    getBaseVersionResultListForLegacyEntry(entry) {
        return Promise.resolve({
            res: {},
            data: [
                Object.assign(Object.assign({}, entry), { [entry.type]: {
                        version: entry.version,
                        url: entry.url
                    } })
            ]
        });
    }
    getDeviceSoftwareChangesFromSoftwareListOperation(operation, device) {
        const changes = [];
        forEach(device.c8y_SoftwareList, deviceSoftware => {
            const operationSoftware = find(operation.c8y_SoftwareList, { name: deviceSoftware.name });
            if ((operationSoftware && operationSoftware.version) !==
                (deviceSoftware && deviceSoftware.version)) {
                changes.push(Object.assign(Object.assign({}, deviceSoftware), { action: 'delete' }));
            }
        });
        forEach(operation.c8y_SoftwareList, operationSoftware => {
            const deviceSoftware = find(device.c8y_SoftwareList, { name: operationSoftware.name });
            if ((operationSoftware && operationSoftware.version) !==
                (deviceSoftware && deviceSoftware.version)) {
                changes.push(Object.assign(Object.assign({}, operationSoftware), { action: 'install' }));
            }
        });
        return changes;
    }
    getDeviceSoftwareChangesFromSoftwareOperation(operation, device) {
        const changes = [];
        forEach(device.c8y_Software, (deviceSoftwareVersion, deviceSoftwareName) => {
            if (operation.c8y_Software[deviceSoftwareName] !== deviceSoftwareVersion) {
                changes.push({
                    name: deviceSoftwareName,
                    version: deviceSoftwareVersion,
                    action: 'delete'
                });
            }
        });
        forEach(operation.c8y_Software, (operationSoftwareVersion, operationSoftwareName) => {
            const deviceSoftwareVersion = device.c8y_Software && device.c8y_Software[operationSoftwareName];
            if (deviceSoftwareVersion !== operationSoftwareVersion) {
                changes.push({
                    name: operationSoftwareName,
                    version: operationSoftwareVersion,
                    action: 'install'
                });
            }
        });
        return changes;
    }
}
RepositoryService.decorators = [
    { type: Injectable }
];
RepositoryService.ctorParameters = () => [
    { type: InventoryService },
    { type: InventoryBinaryService },
    { type: OperationService },
    { type: AlertService },
    { type: EventService },
    { type: OperationRealtimeService },
    { type: EventBinaryService }
];

class SaveToRepositoryComponent {
    constructor(modal, alertService, repositoryService) {
        this.modal = modal;
        this.alertService = alertService;
        this.repositoryService = repositoryService;
        this.result = new Promise((resolve, reject) => {
            this._save = resolve;
            this._cancel = reject;
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            {
                try {
                    const configSnapshotData = {
                        selected: {
                            configurationType: this.configSnapshot.configurationType
                        },
                        version: this.configSnapshot.name,
                        deviceType: this.configSnapshot.deviceType,
                        description: this.configSnapshot.description,
                        binary: {
                            file: new File([this.configSnapshot.binary], this.configSnapshot.name)
                        }
                    };
                    yield this.repositoryService.save(configSnapshotData, RepositoryType.CONFIGURATION);
                    this.alertService.success(gettext('Configuration saved.'));
                    this._save();
                }
                catch (ex) {
                    this.alertService.addServerFailure(ex);
                }
            }
        });
    }
    close() {
        this._cancel();
        this.modal.hide();
    }
}
SaveToRepositoryComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-save-config-to-configuration-repository',
                template: "<div class=\"modal-header bg-primary text-center text-white\">\n  <div style=\"font-size: 62px;\">\n    <span c8yIcon=\"gears\"></span>\n  </div>\n  <h4 class=\"text-uppercase\" translate>\n    Save configuration\n  </h4>\n</div>\n<div class=\"modal-body\">\n  <form #saveConfigurationSnapshot=\"ngForm\" class=\"p-t-24\">\n    <c8y-form-group>\n      <label translate for=\"name\">Name</label>\n      <input\n        id=\"name\"\n        type=\"text\"\n        class=\"form-control\"\n        autocomplete=\"off\"\n        name=\"name\"\n        [(ngModel)]=\"configSnapshot.name\"\n        required\n      />\n    </c8y-form-group>\n    <c8y-form-group>\n      <label translate for=\"deviceType\">Device type</label>\n      <input\n        id=\"deviceType\"\n        class=\"form-control\"\n        rows=\"6\"\n        name=\"deviceType\"\n        [(ngModel)]=\"configSnapshot.deviceType\"\n      />\n    </c8y-form-group>\n    <c8y-form-group>\n      <label translate for=\"description\">Description</label>\n      <input\n        type=\"text\"\n        id=\"description\"\n        class=\"form-control\"\n        maxlength=\"254\"\n        autocomplete=\"off\"\n        name=\"description\"\n        [(ngModel)]=\"configSnapshot.description\"\n      />\n    </c8y-form-group>\n    <c8y-form-group>\n      <label translate for=\"configurationType\">Configuration type</label>\n      <input\n        id=\"configurationType\"\n        class=\"form-control\"\n        rows=\"6\"\n        name=\"configurationType\"\n        [(ngModel)]=\"configSnapshot.configurationType\"\n      />\n    </c8y-form-group>\n  </form>\n</div>\n<div class=\"modal-footer\">\n  <button title=\"{{ 'Cancel' | translate }}\" class=\"btn btn-default\" (click)=\"close()\" translate>\n    Cancel\n  </button>\n\n  <button\n    title=\"{{ 'Save configuration to repository' | translate }}\"\n    class=\"btn btn-primary\"\n    (click)=\"save()\"\n    [disabled]=\"saveConfigurationSnapshot.form.invalid\"\n    translate\n  >\n    Save\n  </button>\n</div>\n"
            },] }
];
SaveToRepositoryComponent.ctorParameters = () => [
    { type: BsModalRef },
    { type: AlertService },
    { type: RepositoryService }
];

class ConfigurationPreviewComponent {
    constructor(deviceConfigurationService, operationRealtime, bsModal, user, appState, repositoryService, operationService, alertService) {
        this.deviceConfigurationService = deviceConfigurationService;
        this.operationRealtime = operationRealtime;
        this.bsModal = bsModal;
        this.user = user;
        this.appState = appState;
        this.repositoryService = repositoryService;
        this.operationService = operationService;
        this.alertService = alertService;
        this.isLegacy = false;
        this.canCallAction = true;
        this.deviceConfigurationOperation = DeviceConfigurationOperation;
    }
    set configurationType(type) {
        this._configurationType = type;
        this.setOperation(type);
    }
    get configurationType() {
        return this._configurationType;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.setCanCallAction();
            this.setOperation(this._configurationType);
            this.operationsSubscription = this.operationRealtime
                .onAll$(this.device.id)
                .pipe(map(({ data }) => data))
                .subscribe(operation => {
                this.updatePreview(operation);
            });
        });
    }
    setOperation(configType) {
        return __awaiter(this, void 0, void 0, function* () {
            const operationList = yield this.repositoryService.getConfigFileOperationList(this.device.id, this.operationToTrigger);
            const operation = this.isLegacy
                ? operationList.find(op => op[this.operationToTrigger] && !op[this.operationToTrigger].type)
                : operationList.find(op => op[this.operationToTrigger].type === configType);
            this.operation =
                operation && operation.status !== OperationStatus.SUCCESSFUL ? operation : undefined;
        });
    }
    setCanCallAction() {
        this.canCallAction = this.deviceConfigurationService.hasAnySupportedOperation(this.device, this.operationToTrigger);
    }
    createDeviceOperation() {
        return __awaiter(this, void 0, void 0, function* () {
            let operationCfg;
            if (this.operationToTrigger === DeviceConfigurationOperation.DOWNLOAD_CONFIG) {
                operationCfg = this.repositoryService.getDownloadConfigurationFileOperation(this.device, this._configurationType, this.configSnapshot, this.isLegacy);
            }
            if (this.operationToTrigger === DeviceConfigurationOperation.UPLOAD_CONFIG) {
                operationCfg = this.repositoryService.getUploadConfigurationFileOperation(this.device, this._configurationType, this.isLegacy);
            }
            try {
                this.operation = (yield this.operationService.create(operationCfg)).data;
            }
            catch (ex) {
                this.alertService.addServerFailure(ex);
            }
        });
    }
    showOperation() {
        if (this.operationToTrigger === DeviceConfigurationOperation.DOWNLOAD_CONFIG) {
            return !!this.operation;
        }
        return (this.operation &&
            [OperationStatus.PENDING, OperationStatus.EXECUTING, OperationStatus.FAILED].includes(this.operation.status));
    }
    showBinary() {
        if (this.operationToTrigger === DeviceConfigurationOperation.DOWNLOAD_CONFIG) {
            return true;
        }
        return !this.showOperation();
    }
    isCreateOperationDisabled() {
        return (this.operation &&
            [OperationStatus.PENDING, OperationStatus.EXECUTING].includes(this.operation.status));
    }
    updatePreview(operation) {
        if (operation &&
            operation[this.operationToTrigger] &&
            (this.isLegacy ||
                (operation[this.operationToTrigger].type &&
                    operation[this.operationToTrigger].type === this.configurationType))) {
            this.operation = operation;
            this.updateSnapshotsOnConfigUpload(operation);
        }
    }
    download() {
        const blob = new Blob([this.configSnapshot.binary], { type: this.configSnapshot.binaryType });
        let fileName = this.configSnapshot.name;
        switch (this.configSnapshot.binaryType) {
            case 'text/csv':
            case 'application/csv':
                fileName = fileName.concat('.csv');
                break;
            case 'text/yaml':
            case 'application/x-yaml':
                fileName = fileName.concat('.yaml');
                break;
            case 'application/json':
                fileName = fileName.concat('.json');
                break;
        }
        saveAs(blob, fileName);
    }
    saveToRepository() {
        return __awaiter(this, void 0, void 0, function* () {
            const initialState = {
                configSnapshot: cloneDeep(this.configSnapshot)
            };
            const modal = this.bsModal.show(SaveToRepositoryComponent, {
                class: 'modal-sm',
                initialState,
                ignoreBackdropClick: true
            }).content;
            try {
                yield modal.result;
                this.deviceConfigurationService.updateConfigurations(true);
                modal.close();
            }
            catch (ex) {
                // do nothing
            }
        });
    }
    hasPermission() {
        return this.user.hasAnyRole(this.appState.currentUser.value, [
            'ROLE_INVENTORY_ADMIN',
            'ROLE_INVENTORY_CREATE'
        ]);
    }
    ngOnDestroy() {
        if (this.operationsSubscription) {
            this.operationsSubscription.unsubscribe();
        }
    }
    updateSnapshotsOnConfigUpload(operation) {
        return __awaiter(this, void 0, void 0, function* () {
            if (operation[DeviceConfigurationOperation.UPLOAD_CONFIG] &&
                operation.status === OperationStatus.SUCCESSFUL) {
                this.deviceConfigurationService.updateConfigurations();
            }
        });
    }
}
ConfigurationPreviewComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-device-configuration-preview',
                template: "<div class=\"content-flex-55 p-b-16\">\n  <div class=\"col-7 p-t-4\">\n    <p>\n      <span class=\"text-label-small text-uppercase m-r-4\" translate>Configuration</span>\n      <span *ngIf=\"configSnapshot?.name; else emptyText\">\n        <strong>{{ configSnapshot.name }}</strong>\n      </span>\n      <ng-template #emptyText> --- </ng-template>\n    </p>\n    <p>\n      <span class=\"text-label-small text-uppercase m-r-4\" translate>Last updated</span>\n      <small *ngIf=\"configSnapshot?.time; else emptyDate\">\n        {{ configSnapshot.time | c8yDate }}\n      </small>\n      <ng-template #emptyDate> --- </ng-template>\n    </p>\n  </div>\n  <div class=\"col-5\">\n    <button\n      id=\"action-btn\"\n      class=\"btn btn-default btn-sm pull-right\"\n      type=\"button\"\n      title=\"{{ actionButtonText | translate }}\"\n      (click)=\"createDeviceOperation()\"\n      [disabled]=\"isCreateOperationDisabled()\"\n      *ngIf=\"canCallAction\"\n    >\n      <i [c8yIcon]=\"actionButtonIcon\"></i> {{ actionButtonText | translate }}\n    </button>\n  </div>\n</div>\n<div class=\"c8y-empty-state text-left\" *ngIf=\"!configSnapshot?.binary && showBinary()\">\n  <h1 [c8yIcon]=\"'file-image-o'\"></h1>\n  <p>\n    <strong translate>No preview available.</strong><br />\n    <small *ngIf=\"configSnapshot?.binary !== ''; else emptyFile\" translate\n      >The file is not available.</small\n    >\n    <ng-template #emptyFile>\n      <small translate>The file is empty.</small>\n    </ng-template>\n  </p>\n</div>\n<div *ngIf=\"configSnapshot?.binary && showBinary()\" class=\"flex-grow d-flex d-col\">\n  <c8y-source-code-preview\n    [text]=\"configSnapshot.binary\"\n    [isDisabled]=\"true\"\n    class=\"d-contents\"\n  ></c8y-source-code-preview>\n  <div *ngIf=\"canSaveSnapshot\" class=\"p-t-16\">\n    <button\n      type=\"button\"\n      class=\"btn btn-primary btn-sm pull-right m-l-8\"\n      (click)=\"download()\"\n      translate\n    >\n      Download\n    </button>\n    <button\n      *ngIf=\"hasPermission()\"\n      type=\"button\"\n      class=\"btn btn-default btn-sm pull-right\"\n      (click)=\"saveToRepository()\"\n      translate\n    >\n      Save to repository\n    </button>\n  </div>\n</div>\n<div *ngIf=\"showOperation()\">\n  <c8y-single-operation [operation]=\"operation\"></c8y-single-operation>\n</div>\n"
            },] }
];
ConfigurationPreviewComponent.ctorParameters = () => [
    { type: DeviceConfigurationService },
    { type: OperationRealtimeService },
    { type: BsModalService },
    { type: UserService },
    { type: AppStateService },
    { type: RepositoryService },
    { type: OperationService },
    { type: AlertService }
];
ConfigurationPreviewComponent.propDecorators = {
    device: [{ type: Input }],
    configurationType: [{ type: Input }],
    configSnapshot: [{ type: Input }],
    canSaveSnapshot: [{ type: Input }],
    actionButtonText: [{ type: Input }],
    actionButtonIcon: [{ type: Input }],
    isLegacy: [{ type: Input }],
    operationToTrigger: [{ type: Input }]
};

class DeviceConfigurationListComponent {
    constructor() {
        this.configSelected = new EventEmitter();
        this.filterTerm = '';
    }
    showConfigurationTypePreview(config) {
        this.selectedConfig = config;
        this.configSelected.emit(config);
    }
    updatePipe(filterTerm) {
        this.filterTerm = filterTerm;
    }
}
DeviceConfigurationListComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-device-configuration-list',
                template: "<div class=\"p-l-16 m-b-8\" *ngIf=\"isFilterEnabled\">\n  <c8y-filter [icon]=\"'search'\" (onSearch)=\"updatePipe($event)\"></c8y-filter>\n</div>\n\n<!-- EMPTY STATE -->\n<div class=\"c8y-empty-state text-left\" *ngIf=\"items?.length === 0\">\n  <h1 [c8yIcon]=\"emptyState.icon\"></h1>\n  <p>\n    <strong>{{ emptyState.title | translate }}</strong\n    ><br />\n    <small>{{ emptyState.text | translate }}</small>\n  </p>\n</div>\n\n<!-- CONFIGURATIONS AVAILABLE -->\n<div class=\"c8y-nav-stacked\">\n  <div\n    class=\"c8y-stacked-item flex-row\"\n    [class.active]=\"config === selectedConfig\"\n    *ngFor=\"let config of items | configurationFilterPipe: filterTerm\"\n    (click)=\"showConfigurationTypePreview(config)\"\n  >\n    <div class=\"list-item-icon\">\n      <i [c8yIcon]=\"itemIcon\"></i>\n    </div>\n    <div class=\"list-item-body text-truncate\">\n      <div class=\"d-flex\">\n        <span class=\"text-truncate\" title=\"{{ config.name }}\">{{ config.name }}</span>\n        <span class=\"text-label-small flex-item-right flex-item-middle\">{{ config.deviceType }}</span>\n      </div>\n    </div>\n  </div>\n</div>\n\n<!-- for Carlos: config.configurationType to differentiate whether a config matches configuration type. -->\n"
            },] }
];
DeviceConfigurationListComponent.propDecorators = {
    items: [{ type: Input }],
    itemIcon: [{ type: Input }],
    emptyState: [{ type: Input }],
    isFilterEnabled: [{ type: Input }],
    configSelected: [{ type: Output }]
};

class TextBasedConfigurationComponent {
    constructor(route, alertService, repositoryService, deviceConfigurationService, inventoryService) {
        this.route = route;
        this.alertService = alertService;
        this.repositoryService = repositoryService;
        this.deviceConfigurationService = deviceConfigurationService;
        this.inventoryService = inventoryService;
        this.reloadingConfig = false;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.load();
        });
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            this.device = this.route.snapshot.parent.data.contextData;
            yield this.loadDevice();
            yield this.loadOperation();
            this.showTextBasedConfigReload = this.deviceConfigurationService.hasAnySupportedOperation(this.device, [DeviceConfigurationOperation.SEND_CONFIG]);
            this.showTextBasedConfigSave = this.deviceConfigurationService.hasAnySupportedOperation(this.device, [DeviceConfigurationOperation.CONFIG]);
            if (this.device.c8y_Configuration && this.device.c8y_Configuration.config) {
                this.config = this.device.c8y_Configuration.config;
            }
        });
    }
    loadOperation() {
        return __awaiter(this, void 0, void 0, function* () {
            const operation = yield this.repositoryService.getLastConfigUpdateOperation(this.device.id);
            if (operation !== null) {
                this.reloadingConfig =
                    !!operation.c8y_SendConfiguration &&
                        (operation.status === OperationStatus.PENDING ||
                            operation.status === OperationStatus.EXECUTING);
                this.repositoryService.observeOperation(operation).subscribe((operationUpdate) => {
                    this.latestOperation = operationUpdate;
                });
            }
        });
    }
    get savingConfig() {
        return this.latestOperation
            ? !!this.latestOperation.c8y_Configuration &&
                (this.latestOperation.status === OperationStatus.PENDING ||
                    this.latestOperation.status === OperationStatus.EXECUTING)
            : false;
    }
    reloadConfiguration() {
        return __awaiter(this, void 0, void 0, function* () {
            this.reloadingConfig = true;
            const operationCfg = yield this.repositoryService.createTextBasedConfigurationReloadOperation(this.device);
            try {
                this.repositoryService
                    .createObservedOperation(operationCfg)
                    .subscribe(operationUpdate => this.onOperationReloadSuccess(operationUpdate), operationUpdate => this.onOperationReloadError(operationUpdate), () => this.onOperationReloadComplete());
            }
            catch (ex) {
                this.alertService.addServerFailure(ex);
            }
        });
    }
    updateConfiguration(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const operationCfg = yield this.repositoryService.createTextBasedConfigurationUpdateOperation(this.device, config);
            try {
                this.repositoryService
                    .createObservedOperation(operationCfg)
                    .subscribe(operationUpdate => this.onOperationUpdateSuccess(operationUpdate), operationUpdate => this.onOperationUpdateError(operationUpdate), () => this.onOperationUpdateComplete());
            }
            catch (ex) {
                this.alertService.addServerFailure(ex);
            }
        });
    }
    onOperationReloadSuccess(operationUpdate) {
        this.latestOperation = operationUpdate;
        if (operationUpdate.status === OperationStatus.PENDING) {
            this.alertService.success(gettext('Configuration will be reloaded.'));
        }
    }
    onOperationReloadError(operationUpdate) {
        this.latestOperation = operationUpdate;
        this.reloadingConfig = false;
    }
    onOperationReloadComplete() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadDevice();
            this.config = this.device.c8y_Configuration.config;
            this.reloadingConfig = false;
        });
    }
    onOperationUpdateSuccess(operationUpdate) {
        this.latestOperation = operationUpdate;
        if (operationUpdate.status === OperationStatus.PENDING) {
            this.alertService.success(gettext('Configuration will be updated.'));
        }
    }
    onOperationUpdateError(operationUpdate) {
        this.latestOperation = operationUpdate;
    }
    onOperationUpdateComplete() {
        this.device.c8y_Configuration.config = this.config;
    }
    loadDevice() {
        return __awaiter(this, void 0, void 0, function* () {
            this.device = (yield this.inventoryService.detail(this.device.id, {
                withChildren: false
            })).data;
        });
    }
}
TextBasedConfigurationComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-text-based-configuration',
                template: "<div class=\"d-flex d-col fit-h\">\n  <fieldset class=\"card-block bg-gray-white fit-w\">\n    <div class=\"content-flex-50\">\n      <div class=\"flex-item-left d-flex\">\n        <button\n          title=\"{{ 'Get configuration from device' | translate }}\"\n          type=\"button\"\n          class=\"btn btn-default btn-sm flex-item-v-center m-t-8 m-b-8\"\n          *ngIf=\"showTextBasedConfigReload\"\n          (click)=\"reloadConfiguration()\"\n          [disabled]=\"reloadingConfig || savingConfig\"\n        >\n          <i\n            c8yIcon=\"refresh\"\n            *ngIf=\"reloadingConfig\"\n            class=\"m-r-4\"\n            [ngClass]=\"{ 'icon-spin': reloadingConfig }\"\n          ></i>\n          <i c8yIcon=\"download\" *ngIf=\"!reloadingConfig\" class=\"m-r-4\"></i>\n\n          {{ 'Get configuration from device' | translate }}\n        </button>\n      </div>\n      <c8y-single-operation\n        *ngIf=\"latestOperation !== undefined\"\n        [operation]=\"latestOperation\"\n        class=\"flex-grow\"\n      ></c8y-single-operation>\n    </div>\n  </fieldset>\n  <div class=\"flex-grow\">\n    <textarea\n      [(ngModel)]=\"config\"\n      class=\"form-control fit-h p-r-16 p-l-16\"\n      [disabled]=\"reloadingConfig || savingConfig\"\n      c8y-spellcheck=\"false\"\n    ></textarea>\n  </div>\n  <div class=\"card-footer fit-w separator\" *ngIf=\"showTextBasedConfigSave\">\n    <button\n      type=\"button\"\n      id=\"send-config-btn\"\n      (click)=\"updateConfiguration(config)\"\n      [disabled]=\"reloadingConfig || savingConfig || !config\"\n      class=\"btn btn-primary\"\n      [ngClass]=\"{ 'btn-pending': savingConfig }\"\n    >\n      <span title=\"{{ 'Send' | translate }}\" *ngIf=\"!savingConfig\">\n        {{ 'Send configuration to device' | translate }}\n      </span>\n      <span title=\"{{ 'Sending\u2026' | translate }}\" *ngIf=\"savingConfig\">\n        {{ 'Sending\u2026' | translate }}\n      </span>\n    </button>\n  </div>\n</div>\n"
            },] }
];
TextBasedConfigurationComponent.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: AlertService },
    { type: RepositoryService },
    { type: DeviceConfigurationService },
    { type: InventoryService }
];

class DeviceConfigurationComponent {
    constructor(route, deviceConfigurationService, realtime, repositoryService) {
        this.route = route;
        this.deviceConfigurationService = deviceConfigurationService;
        this.realtime = realtime;
        this.repositoryService = repositoryService;
        this.supportedConfigurations = [];
        this.showBinaryBasedConfig = false;
        this.configSnapshot = {};
        this.reloading = false;
        this.deviceConfigurationService.configurationsUpdated.subscribe(repositorySnapsOnly => {
            this.updateSnapshots(repositorySnapsOnly);
        });
    }
    ngOnInit() {
        this.device = this.route.snapshot.parent.data.contextData;
        if (this.device.c8y_SupportedConfigurations) {
            this.supportedConfigurations = this.device.c8y_SupportedConfigurations.map(item => ({
                name: item
            }));
        }
        if (this.deviceConfigurationService.hasAnySupportedOperation(this.device, [
            DeviceConfigurationOperation.DOWNLOAD_CONFIG,
            DeviceConfigurationOperation.UPLOAD_CONFIG
        ])) {
            this.supportedConfigurations.push({
                name: gettext('Legacy configuration snapshot'),
                isLegacy: true
            });
        }
        if (this.supportedConfigurations.length > 0) {
            this.showBinaryBasedConfig = true;
        }
        this.repositorySnapshotsEmptyState = {
            icon: 'gears',
            title: gettext('No configurations available.'),
            text: gettext('Add configuration to configuration repository')
        };
        this.showTextBasedConfig =
            this.deviceConfigurationService.hasAnySupportedOperation(this.device, [
                DeviceConfigurationOperation.CONFIG,
                DeviceConfigurationOperation.SEND_CONFIG
            ]) || has(this.device, 'c8y_Configuration');
    }
    onConfigTypeSelected(config) {
        return __awaiter(this, void 0, void 0, function* () {
            this.configurationType = config.name;
            this.isLegacy = config.isLegacy;
            this.updateSnapshots();
        });
    }
    onRepositoryConfigSelected(config) {
        return __awaiter(this, void 0, void 0, function* () {
            this.repositorySnapshot = {
                id: config.id,
                time: config.creationTime,
                name: config.name,
                binaryUrl: config.url,
                deviceType: config.deviceType,
                configurationType: config.configurationType
            };
            if (config.url) {
                try {
                    const binary = yield this.repositoryService.getBinaryFile(config.url, {
                        allowExternal: false
                    });
                    if (binary) {
                        this.repositorySnapshot.binary = yield binary.text();
                    }
                }
                catch (ex) {
                    // do nothing
                }
            }
        });
    }
    updateSnapshots(repositorySnapsOnly) {
        return __awaiter(this, void 0, void 0, function* () {
            this.reloading = true;
            this.repositorySnapshot = undefined;
            this.repositorySnapshots = yield this.repositoryService.getSnapshotsFromRepository(this.device, this.configurationType);
            if (!repositorySnapsOnly) {
                this.configSnapshot = this.isLegacy
                    ? yield this.repositoryService.getLegacyConfigSnapshot(this.device)
                    : yield this.repositoryService.getConfigSnapshot(this.device, this.configurationType);
            }
            if (this.showTextBasedConfig) {
                yield this.textBasedConfigurationComponent.load();
            }
            this.reloading = false;
        });
    }
}
DeviceConfigurationComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-device-configuration',
                template: "<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\" title=\"{{ 'Reload' | translate }}\" (click)=\"updateSnapshots()\">\n    <i c8yIcon=\"refresh\" [ngClass]=\"{ 'icon-spin': reloading }\"></i>\n    {{ 'Reload' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<div class=\"card content-fullpage card-has-tabs\">\n  <tabset>\n    <div class=\"card-header separator\" *ngIf=\"showBinaryBasedConfig && !showTextBasedConfig\">\n      <h4 class=\"card-title\">{{ 'Configurations' | translate }}</h4>\n    </div>\n    <div class=\"card-header separator\" *ngIf=\"!showBinaryBasedConfig && showTextBasedConfig\">\n      <h4 class=\"card-title\">{{ 'Text-based configuration' | translate }}</h4>\n    </div>\n    <tab heading=\"{{ 'Configurations' | translate }}\" *ngIf=\"showBinaryBasedConfig\">\n      <div class=\"card--grid card grid__col--4-8--md grid__row--6-6--md m-b-0\">\n        <!-- DEVICE SUPPORTED CONFIGURATIONS -->\n        <div class=\"card--grid__inner-scroll bg-gray-white\">\n          <div class=\"p-l-16 p-r-16\">\n            <h5 class=\"legend form-block\">\n              <span translate>Device-supported configurations</span>\n            </h5>\n          </div>\n          <c8y-device-configuration-list\n            [items]=\"supportedConfigurations\"\n            [itemIcon]=\"'gears'\"\n            (configSelected)=\"onConfigTypeSelected($event)\"\n          ></c8y-device-configuration-list>\n        </div>\n\n        <!-- CONFIGURATION PREVIEW -->\n        <div class=\"card--grid__inner-scroll d-flex d-col flex-grow\">\n          <div class=\"card-block d-flex d-col flex-grow\">\n            <h5 class=\"legend form-block\"><span translate>Preview</span></h5>\n\n            <!-- EMPTY STATE -->\n            <div class=\"c8y-empty-state text-left\" *ngIf=\"!configurationType\">\n              <h1 [c8yIcon]=\"'file-text'\"></h1>\n              <p>\n                <strong translate>No configuration selected.</strong><br />\n                <small translate>Select a configuration to preview</small>\n              </p>\n            </div>\n\n            <!-- PREVIEW AVAILABLE STATE -->\n            <c8y-device-configuration-preview\n              *ngIf=\"configurationType\"\n              [device]=\"device\"\n              [configurationType]=\"configurationType\"\n              [configSnapshot]=\"configSnapshot\"\n              [canSaveSnapshot]=\"true\"\n              [operationToTrigger]=\"'c8y_UploadConfigFile'\"\n              [actionButtonText]=\"'Get snapshot from device' | translate\"\n              [actionButtonIcon]=\"'download'\"\n              [isLegacy]=\"isLegacy\"\n              class=\"d-flex d-col flex-grow\"\n            ></c8y-device-configuration-preview>\n          </div>\n        </div>\n\n        <!-- AVAILABLE SUPPORTED CONFIGURATIONS -->\n        <div class=\"card--grid__inner-scroll bg-gray-white\">\n          <div class=\"p-l-16 p-r-16\">\n            <h5 class=\"legend form-block\" translate>Available supported configurations</h5>\n          </div>\n\n          <!-- EMPTY STATE -->\n          <div class=\"c8y-empty-state text-left\" *ngIf=\"!configurationType\">\n            <h1 [c8yIcon]=\"'gears'\"></h1>\n            <p>\n              <strong translate>No selection</strong><br />\n              <small translate\n                >Select a configuration from the device-supported configuration list</small\n              >\n            </p>\n          </div>\n          <div class=\"p-r-16\" *ngIf=\"configurationType\">\n            <c8y-device-configuration-list\n              [items]=\"repositorySnapshots\"\n              [itemIcon]=\"'file-text'\"\n              [emptyState]=\"repositorySnapshotsEmptyState\"\n              [isFilterEnabled]=\"true\"\n              (configSelected)=\"onRepositoryConfigSelected($event)\"\n            ></c8y-device-configuration-list>\n          </div>\n        </div>\n\n        <!-- CONFIGURATION PREVIEW -->\n        <div class=\"card--grid__inner-scroll d-flex d-col flex-grow\">\n          <div class=\"card-block flex-grow d-flex d-col\">\n            <h5 class=\"legend form-block\" translate>Preview</h5>\n\n            <!-- EMPTY STATE -->\n\n            <div class=\"c8y-empty-state text-left\" *ngIf=\"!repositorySnapshot\">\n              <h1 [c8yIcon]=\"'file-text'\"></h1>\n              <p>\n                <strong translate>No configuration selected.</strong><br />\n                <small *ngIf=\"!configurationType; else noSnapshot\" translate\n                  >Select a configuration to preview</small\n                >\n                <ng-template #noSnapshot>\n                  <small translate>Select the configuration you want to preview</small>\n                </ng-template>\n              </p>\n            </div>\n\n            <!-- CONFIGURATION SELECTED STATE -->\n            <c8y-device-configuration-preview\n              *ngIf=\"repositorySnapshot\"\n              [device]=\"device\"\n              [configurationType]=\"configurationType\"\n              [configSnapshot]=\"repositorySnapshot\"\n              [operationToTrigger]=\"'c8y_DownloadConfigFile'\"\n              [actionButtonText]=\"'Send configuration to device' | translate\"\n              [actionButtonIcon]=\"'upload'\"\n              [isLegacy]=\"isLegacy\"\n              class=\"d-flex d-col flex-grow\"\n            ></c8y-device-configuration-preview>\n          </div>\n        </div>\n      </div>\n    </tab>\n    <tab heading=\"{{ 'Text-based configuration' | translate }}\" *ngIf=\"showTextBasedConfig\">\n      <c8y-text-based-configuration></c8y-text-based-configuration>\n    </tab>\n  </tabset>\n</div>\n"
            },] }
];
DeviceConfigurationComponent.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: DeviceConfigurationService },
    { type: Realtime },
    { type: RepositoryService }
];
DeviceConfigurationComponent.propDecorators = {
    textBasedConfigurationComponent: [{ type: ViewChild, args: [TextBasedConfigurationComponent,] }]
};

class DeviceConfigurationGuard {
    constructor(deviceConfigurationService) {
        this.deviceConfigurationService = deviceConfigurationService;
    }
    canActivate(route, state) {
        const contextData = route.data.contextData || route.parent.data.contextData;
        if (!contextData) {
            return false;
        }
        return ((contextData.c8y_SupportedConfigurations &&
            contextData.c8y_SupportedConfigurations.length > 0) ||
            this.deviceConfigurationService.hasAnySupportedOperation(contextData, [
                DeviceConfigurationOperation.DOWNLOAD_CONFIG,
                DeviceConfigurationOperation.UPLOAD_CONFIG,
                DeviceConfigurationOperation.CONFIG,
                DeviceConfigurationOperation.SEND_CONFIG
            ]) ||
            has(contextData, 'c8y_Configuration'));
    }
}
DeviceConfigurationGuard.decorators = [
    { type: Injectable }
];
DeviceConfigurationGuard.ctorParameters = () => [
    { type: DeviceConfigurationService }
];

class SourceCodePreviewComponent {
}
SourceCodePreviewComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-source-code-preview',
                template: "<textarea\n  [disabled]=\"isDisabled\"\n  class=\"text-monospace form-control no-resize flex-grow\"\n  rows=\"4\"\n  >{{ text }}</textarea\n>\n"
            },] }
];
SourceCodePreviewComponent.propDecorators = {
    isDisabled: [{ type: Input }],
    text: [{ type: Input }]
};

class ConfigurationDetailComponent {
    constructor(repositoryService, bsModalRef, alert) {
        this.repositoryService = repositoryService;
        this.bsModalRef = bsModalRef;
        this.alert = alert;
        this.binary = {
            file: undefined,
            url: undefined
        };
        this.pattern = '';
        this.mo = {};
        this.saving = false;
        this.uploadChoice = 'uploadBinary';
        this.textForConfigurationUrlPopover = gettext(`Path for binaries can vary depending on device agent implementation, e.g.:
    /configuration/binaries/configuration1.bin
    https://configuration/binary/123
    ftp://configuration/binary/123.tar.gz
  `);
        this.result = new Promise((resolve, reject) => {
            this._save = resolve;
            this._cancel = reject;
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.configs = yield this.repositoryService.listRepositoryEntries(RepositoryType.CONFIGURATION);
            if (this.selected) {
                this.uploadChoice = this.binary.file ? 'uploadBinary' : 'uploadUrl';
                this.existingBinary = this.binary.file;
            }
            this.setPipe('');
            this.submitButtonTitle = this.mo.id
                ? gettext('Update configuration')
                : gettext('Add configuration');
        });
    }
    cancel() {
        this.bsModalRef.hide();
        this._cancel();
    }
    setPipe(filterStr) {
        this.pattern = filterStr;
        this.filterPipe = pipe(map((data) => uniqBy(data, 'configurationType')), map((data) => {
            return data.filter((mo) => mo.configurationType &&
                mo.configurationType.toLowerCase().indexOf(filterStr.toLowerCase()) > -1);
        }));
    }
    onFile(dropped) {
        this.configurationForm.form.markAsDirty();
        if (!isUndefined(dropped.url)) {
            this.binary = {
                url: dropped.url
            };
            return;
        }
        else if (!isUndefined(dropped.droppedFiles)) {
            this.binary = {
                file: dropped.droppedFiles[0].file
            };
            return;
        }
        else {
            this.binary = {
                file: undefined,
                url: undefined
            };
        }
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.saving = true;
                const { selected, version, description, binary, deviceType } = this;
                if (this.existingBinary === this.binary.file) {
                    binary.file = undefined;
                }
                yield this.repositoryService.save({ selected, version, description, binary, deviceType }, RepositoryType.CONFIGURATION, this.mo);
                this.alert.success(this.mo.id ? gettext('Configuration updated.') : gettext('Configuration created.'));
                this.bsModalRef.hide();
                this._save();
            }
            catch (ex) {
                this.alert.addServerFailure(ex);
                this._cancel();
            }
            finally {
                this.saving = false;
            }
        });
    }
}
ConfigurationDetailComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-configuration-detail',
                template: "<div class=\"viewport-modal\">\n  <div class=\"modal-header dialog-header\">\n    <i [c8yIcon]=\"'cogs'\"></i>\n    <h4 translate *ngIf=\"mo.id\">Update configuration</h4>\n    <h4 translate *ngIf=\"!mo.id\">Add configuration</h4>\n  </div>\n\n  <form\n    class=\"d-contents\"\n    #configurationForm=\"ngForm\"\n    (ngSubmit)=\"configurationForm.form.valid && save()\"\n  >\n    <div class=\"modal-inner-scroll\">\n      <div class=\"modal-body\">\n        <c8y-form-group>\n          <label translate>Name</label>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'e.g.' | translate }} hosts\"\n            autocomplete=\"off\"\n            required\n            maxlength=\"254\"\n            [(ngModel)]=\"version\"\n            name=\"version\"\n          />\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <label translate>Device type</label>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'e.g.' | translate }} c8y_Linux\"\n            maxlength=\"254\"\n            autocomplete=\"off\"\n            [(ngModel)]=\"deviceType\"\n            name=\"deviceType\"\n          />\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <label translate>Description</label>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'e.g. Host configuration' | translate }} c8y_Linux\"\n            maxlength=\"254\"\n            autocomplete=\"off\"\n            [(ngModel)]=\"description\"\n            name=\"description\"\n          />\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <label translate>Configuration type</label>\n          <c8y-typeahead\n            [(ngModel)]=\"selected\"\n            name=\"confType\"\n            placeholder=\"{{ 'e.g.' | translate }} ssh\"\n            maxlength=\"254\"\n            (onSearch)=\"setPipe($event)\"\n            displayProperty=\"configurationType\"\n          >\n            <c8y-li\n              *c8yFor=\"let config of configs; pipe: filterPipe; notFound: notFoundTemplate\"\n              class=\"p-l-8 p-r-8 c8y-list__item--link\"\n              (click)=\"selected = config; setPipe('')\"\n              [active]=\"selected === config\"\n            >\n              <c8y-highlight\n                [text]=\"config.configurationType || '--'\"\n                [pattern]=\"pattern\"\n              ></c8y-highlight>\n            </c8y-li>\n            <ng-template #notFoundTemplate>\n              <c8y-li class=\"bg-gray-lighter p-8\" *ngIf=\"pattern.length > 0\">\n                <span translate>No match found.</span>\n                <button\n                  title=\"{{ 'Add new`configuration type`' | translate }}\"\n                  type=\"button\"\n                  class=\"btn btn-primary btn-xs m-l-16\"\n                  translate\n                >\n                  Add new`configuration type`\n                </button>\n              </c8y-li>\n            </ng-template>\n          </c8y-typeahead>\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <div class=\"legend form-block m-t-40\" translate>Configuration file</div>\n          <c8y-file-picker\n            [maxAllowedFiles]=\"1\"\n            (onFilesPicked)=\"onFile($event)\"\n            [uploadChoice]=\"uploadChoice\"\n            [fileUrl]=\"binary.url\"\n            [fileBinary]=\"binary.file\"\n            [fileUrlPopover]=\"textForConfigurationUrlPopover\"\n          >\n          </c8y-file-picker>\n        </c8y-form-group>\n      </div>\n    </div>\n\n    <div class=\"modal-footer\">\n      <button\n        (click)=\"cancel()\"\n        type=\"button\"\n        class=\"btn btn-default\"\n        title=\"{{ 'Cancel' | translate }}\"\n        [disabled]=\"saving\"\n      >\n        <span translate>Cancel</span>\n      </button>\n      <button\n        class=\"btn btn-primary\"\n        type=\"submit\"\n        title=\"{{ submitButtonTitle | translate }}\"\n        [ngClass]=\"{ 'btn-pending': saving }\"\n        [disabled]=\"\n          !configurationForm.valid ||\n          configurationForm.pristine ||\n          (!binary?.url && !binary?.file) ||\n          saving\n        \"\n      >\n        {{ submitButtonTitle | translate }}\n      </button>\n    </div>\n  </form>\n</div>\n"
            },] }
];
ConfigurationDetailComponent.ctorParameters = () => [
    { type: RepositoryService },
    { type: BsModalRef },
    { type: AlertService }
];
ConfigurationDetailComponent.propDecorators = {
    configurationForm: [{ type: ViewChild, args: ['configurationForm', { static: true },] }]
};

class ConfigurationListComponent {
    constructor(alert, repositoryService, bsModalService, modalService, translateService, inventoryBinaryService, inventoryService) {
        this.alert = alert;
        this.repositoryService = repositoryService;
        this.bsModalService = bsModalService;
        this.modalService = modalService;
        this.translateService = translateService;
        this.inventoryBinaryService = inventoryBinaryService;
        this.inventoryService = inventoryService;
        this.filterTerm = '';
        this.reloading = false;
        this.DELETED_SUCCESS_MSG = gettext('Configuration deleted.');
    }
    ngOnInit() {
        this.loadConfigurations();
    }
    loadConfigurations() {
        return __awaiter(this, void 0, void 0, function* () {
            this.reloading = true;
            this.configurations$ = of(yield this.repositoryService.listRepositoryEntries(RepositoryType.CONFIGURATION));
            this.reloading = false;
            this.reset();
        });
    }
    add() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.bsModalService.show(ConfigurationDetailComponent, {
                    class: 'modal-sm',
                    ignoreBackdropClick: true
                }).content.result;
                yield this.loadConfigurations();
            }
            catch (ex) {
                // intended empty
            }
        });
    }
    edit(configuration) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileBinary = yield this.repositoryService.getBinaryFile(configuration.url, {
                allowExternal: false
            });
            try {
                const modal = this.bsModalService.show(ConfigurationDetailComponent, {
                    class: 'modal-sm',
                    ignoreBackdropClick: true,
                    initialState: {
                        selected: configuration,
                        version: configuration.name,
                        deviceType: configuration.deviceType,
                        description: configuration.description,
                        binary: { file: fileBinary, url: configuration.url }
                    }
                }).content;
                modal.mo = configuration;
                yield modal.result;
                yield this.loadConfigurations();
            }
            catch (ex) {
                // intended empty
            }
        });
    }
    isBinaryFile(configuration) {
        return configuration.url ? !!this.inventoryBinaryService.getIdFromUrl(configuration.url) : false;
    }
    getBinaryName(configuration) {
        return this.repositoryService.getBinaryName$(configuration.url);
    }
    download(configuration) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileBinary = yield this.repositoryService.getBinaryFile(configuration.url, {
                allowExternal: false
            });
            saveAs(fileBinary);
        });
    }
    delete(configuration) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const title = gettext('Delete configuration snapshot');
                const confirmationText = gettext('You are about to delete the configuration snapshot {{ name }}.');
                const hint = gettext('This operation is irreversible.');
                const proceed = gettext('Do you want to proceed?');
                const body = [
                    this.translateService.instant(confirmationText, {
                        name: configuration.name
                    }),
                    this.translateService.instant(hint),
                    this.translateService.instant(proceed)
                ].join(' ');
                const labels = {
                    ok: gettext('Delete')
                };
                yield this.modalService.confirm(title, body, Status.DANGER, labels);
                yield this.repositoryService.delete(configuration);
                this.alert.success(this.DELETED_SUCCESS_MSG);
                yield this.loadConfigurations();
            }
            catch (ex) {
                if (ex) {
                    this.alert.addServerFailure(ex);
                }
            }
        });
    }
    setPipe(filterTerm) {
        this.filterTerm = filterTerm;
        this.filterPipe = pipe(map((data) => {
            this.data =
                filterTerm.trim().length === 0
                    ? data
                    : data.filter((mo) => this.filterContainString(mo.name, filterTerm) ||
                        this.filterContainString(mo.configurationType, filterTerm) ||
                        this.filterContainString(mo.deviceType, filterTerm) ||
                        this.filterContainString(mo.description, filterTerm));
            return this.data;
        }));
    }
    shouldShowEmptyState() {
        return !(this.data && this.data.length > 0);
    }
    reset() {
        this.filter.filterTerm = '';
        this.setPipe('');
    }
    filterContainString(name, filterTerm) {
        const term = filterTerm.toLowerCase().trim();
        return name && name.toLowerCase().indexOf(term) > -1;
    }
}
ConfigurationListComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-configuration-list',
                template: "<c8y-title>\n  <span translate>\n    Configuration snapshots repository\n  </span>&nbsp;\n  <small\n    *ngIf=\"(configurations$ | async)?.paging.totalPages === 1 && !filterTerm\"\n  >\n    {{ (configurations$ | async).data.length }}\n    <span translate>\n      snapshots\n    </span>\n  </small>\n  <small\n    *ngIf=\"(configurations$ | async)?.paging.totalPages > 1 && !filterTerm\"\n    [tooltip]=\"'More data available. Scroll to the bottom of the list to load it.' | translate\"\n    container=\"body\"\n  >\n    {{ (configurations$ | async).paging.pageSize }}+\n    <span translate>snapshots</span>\n  </small>\n  <small *ngIf=\"filterTerm\">\n    <span translate>\n      Search results for\n    </span>&nbsp;\"\n      {{ this.filterTerm }}\"\n    </small>\n</c8y-title>\n\n<c8y-action-bar-item itemClass=\"navbar-form\">\n  <c8y-filter\n    [icon]=\"'search'\"\n    (onSearch)=\"setPipe($event)\"\n  ></c8y-filter>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\"\n    (click)=\"add()\"\n  >\n    <i c8yIcon=\"plus-circle\"></i>\n    {{ 'Add configuration snapshot' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\"\n    title=\"{{ 'Reload' | translate }}\"\n    (click)=\"loadConfigurations()\"\n  >\n    <i [ngClass]=\"{ 'icon-spin': reloading }\"\n      c8yIcon=\"refresh\"\n    ></i>\n    {{ 'Reload' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<!-- empty state -->\n<div class=\"c8y-empty-state text-center\"\n  *ngIf=\"!filterTerm && (configurations$ | async)?.data.length === 0\"\n>\n  <h1 c8yIcon=\"gears\"></h1>\n  <h3 translate>There are no configuration snapshots defined</h3>\n  <p translate>Add a configuration snapshot first.</p>\n  <div>\n    <button (click)=\"add()\" class=\"btn btn-primary\" translate>\n      Add configuration snapshot\n    </button>\n  </div>\n  <p c8y-guide-docs>\n    <small translate ngNonBindable>\n      Find out more in the\n      <a c8y-guide-href=\"users-guide/device-management/#configuration-repository\">\n        User guide`KEEP_ORIGINAL`\n        </a>.\n    </small>\n  </p>\n</div>\n\n<!-- no results empty state -->\n<div class=\"c8y-empty-state\"\n  *ngIf=\"shouldShowEmptyState() && (configurations$ | async)?.data.length > 0\"\n>\n  <h1 class=\"c8y-icon-duocolor\"\n    c8yIcon=\"search\"\n  ></h1>\n  <h3 translate>\n    No results to display.\n  </h3>\n  <p translate>\n    Refine your search terms or check your spelling.\n  </p>\n</div>\n\n<c8y-list-group class=\"m-b-24\"\n  *ngIf=\"(configurations$ | async)?.data.length > 0\"\n  [ngClass]=\"{ 'dd-low': data && data.length ? data.length < 10 : (configurations$ | async)?.data.length < 10 }\"\n\n>\n  <c8y-li class=\"page-sticky-header c8y-list__item--empty-actions hidden-xs\"\n    *ngIf=\"!shouldShowEmptyState()\"\n  >\n    <c8y-li-icon>\n      <i class=\"p-l-24\"></i>\n    </c8y-li-icon>\n    <c8y-li-body class=\"content-flex-60\">\n      <div class=\"col-2\">\n        {{ 'Configuration' | translate }}\n      </div>\n      <div class=\"col-3\">\n        {{ 'Description' | translate }}\n      </div>\n      <div class=\"col-3\">\n        {{ 'File' | translate }}\n      </div>\n      <div class=\"col-2\">\n        {{ 'Device type' | translate }}\n      </div>\n      <div class=\"col-2\">\n        {{ 'Configuration type' | translate }}\n      </div>\n    </c8y-li-body>\n  </c8y-li>\n\n  <c8y-li *c8yFor=\"let configuration of configurations$; pipe: filterPipe\">\n    <c8y-li-icon icon=\"gears\"></c8y-li-icon>\n    <div class=\"content-flex-60\">\n      <button class=\"btn-clean col-2\"\n        (click)=\"edit(configuration)\"\n      >\n        <span class=\"text-truncate\"\n          title=\"{{ configuration.name || '-' }}\"\n        >\n          <c8y-highlight\n            [text]=\"configuration.name || '-'\"\n            elementClass=\"text-info\"\n            [pattern]=\"filterTerm\"\n          ></c8y-highlight>\n        </span>\n      </button>\n      <div class=\"col-3\">\n        <div class=\"text-label-small visible-xs-inline m-r-4\">\n          {{ 'Description' | translate }}\n        </div>\n        <small class=\"text-truncate\"\n          *ngIf=\"configuration.description; else emptyDescription\"\n          title=\"configuration.description\"\n        >\n          <c8y-highlight\n            [text]=\"configuration.description || '-'\"\n            elementClass=\"text-info\"\n            [pattern]=\"filterTerm\">\n          </c8y-highlight>\n        </small>\n      </div>\n      <div class=\"col-3\">\n        <span class=\"text-truncate\">\n          <span class=\"text-label-small m-r-4 visible-xs-inline\" translate>\n            File\n          </span>\n          <small\n            *ngIf=\"isBinaryFile(configuration); else noFile\"\n            title=\"{{ getBinaryName(configuration) | async }}\"\n          >\n            {{ getBinaryName(configuration) | async }}\n          </small>\n          <ng-template #noFile>\n            <small title=\"{{ configuration.url }}\">\n              {{ configuration.url }}\n            </small>\n          </ng-template>\n        </span>\n      </div>\n      <div class=\"col-2\">\n        <div class=\"text-truncate\"\n          title=\"{{ 'Device type' | translate }}: {{ configuration.deviceType || '-' }}\"\n        >\n          <span class=\"text-label-small visible-xs-inline m-r-4\" translate>\n            Device type\n          </span>\n          <span *ngIf=\"configuration.deviceType; else emptyText\">\n            <c8y-highlight\n              [text]=\"configuration.deviceType || '-'\"\n              elementClass=\"text-info\"\n              [pattern]=\"filterTerm\"\n            >\n            </c8y-highlight>\n          </span>\n        </div>\n      </div>\n      <div class=\"col-2\">\n        <div class=\"text-truncate\"\n          title=\"{{ configuration.configurationType }}\"\n        >\n          <span class=\"label label-primary\"\n            *ngIf=\"configuration.configurationType; else emptyText\"\n          >\n            <c8y-highlight\n              [text]=\"configuration.configurationType\"\n              elementClass=\"text-info\"\n              [pattern]=\"filterTerm\"\n            >\n            </c8y-highlight>\n          </span>\n        </div>\n      </div>\n    </div>\n    <c8y-li-action\n      (click)=\"edit(configuration)\"\n      icon=\"pencil\"\n      label=\"{{ 'Edit' | translate }}\"\n    >\n    </c8y-li-action>\n    <c8y-li-action\n      (click)=\"delete(configuration)\"\n      icon=\"trash-o\"\n      label=\"{{ 'Delete' | translate }}\"\n    >\n    </c8y-li-action>\n    <c8y-li-action\n      *ngIf=\"isBinaryFile(configuration)\"\n      (click)=\"download(configuration)\"\n      icon=\"download\"\n      label=\"{{ 'Download' | translate }}\"\n    >\n    </c8y-li-action>\n    <ng-template #emptyText>\n      <small class=\"text-muted\">\n        <em>{{ 'Undefined' | translate }}</em>\n      </small>\n    </ng-template>\n    <ng-template #emptyDescription>\n      <small class=\"text-muted\">\n        <em>{{ 'No description' | translate }}</em>\n      </small>\n    </ng-template>\n  </c8y-li>\n</c8y-list-group>\n"
            },] }
];
ConfigurationListComponent.ctorParameters = () => [
    { type: AlertService },
    { type: RepositoryService },
    { type: BsModalService },
    { type: ModalService },
    { type: TranslateService },
    { type: InventoryBinaryService },
    { type: InventoryService }
];
ConfigurationListComponent.propDecorators = {
    filter: [{ type: ViewChild, args: [FilterInputComponent, { static: false },] }]
};
__decorate([
    memoize(property('id'))
], ConfigurationListComponent.prototype, "getBinaryName", null);

var LinkRenderType;
(function (LinkRenderType) {
    LinkRenderType[LinkRenderType["DOWNLOAD"] = 0] = "DOWNLOAD";
    LinkRenderType[LinkRenderType["LINK"] = 1] = "LINK";
    LinkRenderType[LinkRenderType["TEXTONLY"] = 2] = "TEXTONLY";
})(LinkRenderType || (LinkRenderType = {}));

class FileDownloadComponent {
    constructor(repositoryService, inventoryBinaryService, alertService) {
        this.repositoryService = repositoryService;
        this.inventoryBinaryService = inventoryBinaryService;
        this.alertService = alertService;
        this.linkRenderType = LinkRenderType;
        this.isDownloading = false;
    }
    getBinaryName$(binaryUrl) {
        return this.repositoryService.getBinaryName$(binaryUrl);
    }
    determineBehavior() {
        let result;
        if (this.inventoryBinaryService.getIdFromUrl(this.url)) {
            result = LinkRenderType.DOWNLOAD;
        }
        else if (this.url.match(/\/\//g)) {
            result = LinkRenderType.LINK;
        }
        else {
            result = LinkRenderType.TEXTONLY;
        }
        return result;
    }
    downloadFile() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.isDownloading = true;
                const binary = yield this.repositoryService.getBinaryFile(this.url, {
                    allowExternal: false
                });
                this.isDownloading = false;
                saveAs(binary);
            }
            catch (ex) {
                this.isDownloading = false;
                if (ex) {
                    this.alertService.addServerFailure(ex);
                }
            }
        });
    }
}
FileDownloadComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-file-download',
                template: "<a\n  *ngIf=\"determineBehavior() === linkRenderType.LINK\"\n  href=\"{{ url }}\"\n  class=\"pointer\"\n  target=\"_blank\"\n  rel=\"noopener noreferrer\"\n>\n  {{ getBinaryName$(url) | async }}\n</a>\n\n<span *ngIf=\"determineBehavior() === linkRenderType.TEXTONLY\">{{\n  getBinaryName$(url) | async\n}}</span>\n\n<span *ngIf=\"determineBehavior() === linkRenderType.DOWNLOAD\">\n  <a *ngIf=\"!isDownloading\" class=\"pointer\" (click)=\"downloadFile()\">\n    {{ getBinaryName$(url) | async }}\n  </a>\n\n  <span *ngIf=\"isDownloading\">\n    <i c8yIcon=\"spinner\" class=\"icon-spin\"></i> {{ 'Downloading\u2026' | translate }}\n  </span>\n</span>\n"
            },] }
];
FileDownloadComponent.ctorParameters = () => [
    { type: RepositoryService },
    { type: InventoryBinaryService },
    { type: AlertService }
];
FileDownloadComponent.propDecorators = {
    url: [{ type: Input }]
};
__decorate([
    memoize()
], FileDownloadComponent.prototype, "getBinaryName$", null);
__decorate([
    memoize()
], FileDownloadComponent.prototype, "determineBehavior", null);

// MODAL STRUCTURE
// - selectModalObject (repository entry (repositoryCategory) -> type c8y_Firmware/c8y_Software)
//   -- ISelectModalOption (repository binary entry (repositoryBinary) => type c8y_FirmwareBinary/c8y_SoftwareBinary)
//   -- ISelectModalOption...
// - selectModalObject...
/**
 * RepositorySelectModalComponent displays repository entries options and allows to select them.
 *
 * @example
 * ```
 * import { take } from 'rxjs/operators';
 * import { RepositorySelectModalComponent, ModalSelectionMode, RepositoryType } from '@c8y/ngx-components/repository';
 *
 * const initialState = {
 *   repositoryType: RepositoryType.FIRMWARE,
 *   title: gettext('Install firmware'),
 *   subTitle: gettext('Available firmwares matching the device type'),
 *   icon: 'c8y-firmware',
 *   mode: ModalSelectionMode.SINGLE,
 *   labels: { ok: gettext('Install') },
 *   disableSelected: false
 * };
 *
 * const modal = this.bsModal.show(RepositorySelectModalComponent, {
 *   ignoreBackdropClick: true,
 *   initialState
 * });
 *
 * modal.content.load.next();
 * modal.content.resultEmitter.pipe(take(1)).subscribe((firmware) => {
 *   ...
 * })
 * ```
 */
class RepositorySelectModalComponent {
    constructor(repositoryService, translateService) {
        this.repositoryService = repositoryService;
        this.translateService = translateService;
        /**
         * Optional
         * Allows to provide custom data.
         * @example
         * ```
         * import { from } from 'rxjs';
         *
         * const repositoryEntry = { name: 'ExampleEntry', type: 'c8y_Firmware' };
         * const versions = [{ c8y_Firmware: { version: '1.0.0', url: 'http://example.com' } }];
         *
         * const initialState = {repositoryEntriesWithVersions$: from({ ...repositoryEntry, versions })};
         * ```
         */
        this.repositoryEntriesWithVersions$ = undefined;
        /**
         * Optional
         * Allows to use custom badges templates.
         * @example
         * ```
         * import { gettext } from '@c8y/ngx-components';
         *
         * const badgeTemplates = { '=1': gettext('{{count}} version'), other: gettext('{{count}} versions') };
         * const initialState = { badgeTemplates };
         * ```
         */
        this.badgeTemplates = { '=1': gettext('{{count}} version'), other: gettext('{{count}} versions') };
        /**
         * Optional
         * Allows to provide custom modal title.
         */
        this.title = gettext('Select repository entry');
        /**
         * Loads the content of the modal.
         * Must be invoked by the modal's caller.
         */
        this.load = new Subject();
        /**
         * Optional
         * Emits a search string currently entered in the filter input.
         * Use it to filter the items if you use custom repositoryEntriesWithVersions$.
         */
        this.searchTerm = new BehaviorSubject('');
        /**
         * Optional
         * Allows to provide device type query to restrict search criteria.
         * Only takes effect when repositoryEntriesWithVersions$ is not provided,
         * otherwise modal's caller have to provide already filtered data in the repositoryEntriesWithVersions$.
         */
        this.deviceTypeQuery = {};
        /**
         * Optional
         * Allows to provide query to restrict search criteria.
         * Only takes effect when repositoryEntriesWithVersions$ is not provided,
         * otherwise modal's caller have to provide already filtered data in the repositoryEntriesWithVersions$.
         */
        this.searchQuery = {};
        /**
         * Optional
         * Allows to provide custom labels for the buttons responsible for confirm/dismiss modal actions.
         */
        this.labels = { ok: gettext('Save') };
        /**
         * Optional
         * Allows to hide the filter input field.
         * By default, the filter input field is displayed.
         */
        this.showFilter = true;
        /**
         * Optional
         * Allows to show a warning that the search criteria should be narrowed down.
         * By default, this warning is hidden.
         */
        this.areMoreEntries = false;
        /**
         * Emits the list of selected options.
         */
        this.resultEmitter = new EventEmitter();
        /**
         * Optional
         * Allows to change selection mode.
         * Supported options:
         *   * single: only single option can be selected.
         *   * multiple: multiple options can be selected.
         */
        this.mode = ModalSelectionMode.SINGLE;
        /**
         * Allows to block selection of the other versions from the same repository entry.
         */
        this.disableSelected = true;
        this.modalEntries = this.load.pipe(switchMap(() => this.repositoryEntriesWithVersions$), mergeMap(mos => this.aggregate(mos)), tap(items => {
            this.areMoreEntries = items.length >= this.PAGE_SIZE ? true : false;
        }));
        this.PAGE_SIZE = 100;
        this.queriesUtil = new QueriesUtil();
    }
    ngOnInit() {
        if (!this.repositoryType) {
            throw new Error('Repository type must be defined');
        }
        if (!this.repositoryEntriesWithVersions$) {
            this.repositoryEntriesWithVersions$ = from(this.repositoryService.listRepositoryEntries(this.repositoryType, {
                query: this.queriesUtil.addOrFilter(this.deviceTypeQuery, this.searchQuery),
                params: { pageSize: this.PAGE_SIZE }
            })).pipe(map(({ data }) => data), map(mos => this.getAndAssignRepositoryBinaries(mos)), shareReplay(1));
        }
    }
    getAndAssignRepositoryBinaries(mos) {
        mos.forEach(mo => {
            mo.versions = this.repositoryService.listAllVersions(mo);
        });
        return mos;
    }
    search(searchTerm) {
        this.searchTerm.next(searchTerm);
        if (!searchTerm) {
            this.searchQuery = {};
        }
        else {
            this.searchQuery = { name: `*${searchTerm}*` };
        }
        this.load.next();
    }
    result(selectedItems) {
        this.resultEmitter.emit(selectedItems);
    }
    aggregate(mos) {
        return __awaiter(this, void 0, void 0, function* () {
            const repositoryType = this.repositoryType;
            const selectedItems = this.selected;
            return Promise.all(mos.map((repositoryEntry) => __awaiter(this, void 0, void 0, function* () {
                const options = this.getSelectModalOptions(yield this.repositoryService.fetchAllItemsFromList(repositoryEntry.versions), selectedItems, repositoryEntry, repositoryType);
                const selectModalObject = this.getSelectModalObject(repositoryEntry, options);
                return selectModalObject;
            })));
        });
    }
    getSelectModalOptions(versions, selectedItems, repositoryEntry, repositoryType) {
        const selectModalOptions = [];
        versions.forEach(repositoryBinary => {
            const isSelected = this.isBinaryRepositorySelected(selectedItems, repositoryEntry, repositoryBinary, repositoryType);
            const { version } = repositoryBinary[`${repositoryType}`];
            const bodyValue = version || `(${this.translateService.instant(gettext('not specified`version`'))})`;
            const bodyClass = version ? '' : 'text-muted';
            selectModalOptions.push({
                body: [
                    {
                        value: bodyValue,
                        class: bodyClass
                    }
                ],
                obj: Object.assign(Object.assign(Object.assign({ id: repositoryBinary.id, name: repositoryEntry.name, version }, (get(repositoryBinary, 'c8y_Patch.dependency') && {
                    dependency: get(repositoryBinary, 'c8y_Patch.dependency')
                })), (get(repositoryBinary, 'c8y_Patch') && { isPatch: true })), { url: repositoryBinary[`${repositoryType}`].url }),
                selected: isSelected
            });
        });
        return selectModalOptions;
    }
    isBinaryRepositorySelected(selectedItems, repositoryEntry, repositoryBinary, repositoryType) {
        const isSelected = selectedItems
            ? selectedItems.filter(repositoryFragment => repositoryFragment.name === repositoryEntry.name &&
                repositoryFragment.version === repositoryBinary[`${repositoryType}`].version).length > 0
            : false;
        return isSelected;
    }
    getSelectModalObject(repositoryEntry, options) {
        const label = options.length === 1
            ? this.translateService.instant(this.badgeTemplates['=1'], { count: options.length })
            : this.translateService.instant(this.badgeTemplates.other, { count: options.length });
        const selectModalObject = {
            groupId: repositoryEntry.id,
            body: [
                { value: repositoryEntry.name, class: 'text-truncate' },
                { value: repositoryEntry.description, class: 'text-truncate text-muted' }
            ],
            additionalInformation: { value: label, class: 'label label-info' },
            options
        };
        return selectModalObject;
    }
}
RepositorySelectModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-repository-select-modal',
                template: "<c8y-select-modal\n  [icon]=\"icon\"\n  [title]=\"title\"\n  [subTitle]=\"subTitle\"\n  [items]=\"modalEntries | async\"\n  [mode]=\"mode\"\n  [disableSelected]=\"disableSelected\"\n  [labels]=\"labels\"\n  [showFilter]=\"showFilter\"\n  [areMoreEntries]=\"areMoreEntries\"\n  (search)=\"search($event)\"\n  (result)=\"result($event)\"\n>\n</c8y-select-modal>\n"
            },] }
];
RepositorySelectModalComponent.ctorParameters = () => [
    { type: RepositoryService },
    { type: TranslateService }
];

class FirmwareDeviceTabComponent {
    constructor(route, repository, inventory, bsModal) {
        this.route = route;
        this.repository = repository;
        this.inventory = inventory;
        this.bsModal = bsModal;
        this.isEmpty = isEmpty;
        this.reloading = false;
        this.device$ = new BehaviorSubject(this.route.parent.snapshot.data.contextData);
        this.deviceFirmwareFragment$ = this.device$.pipe(map(device => device.c8y_Firmware));
        this.firmwareBinary$ = this.deviceFirmwareFragment$.pipe(filter(deviceFirmwareFragment => !isEmpty(deviceFirmwareFragment)), switchMap(deviceFirmwareFragment => from(this.repository.getRepositoryBinaryMoByVersion(deviceFirmwareFragment, RepositoryType.FIRMWARE))), shareReplay(1));
        this.repositoryEntry$ = this.firmwareBinary$.pipe(switchMap(mo => this.repository.getRepositoryEntryMO$(mo)), shareReplay(1));
        this.patches$ = combineLatest(this.firmwareBinary$, this.repositoryEntry$).pipe(switchMap(([firmwareBinary, repositoryEntry]) => {
            if (repositoryEntry && firmwareBinary) {
                const version = this.repository.getBaseVersionFromMO(firmwareBinary);
                return from(this.repository.listPatchVersions(repositoryEntry, version)).pipe(map(({ data }) => data));
            }
            else {
                return of([]);
            }
        }), shareReplay(1));
        this.supportsFirmwareOperations$ = this.device$.pipe(map((device) => get(device, 'c8y_SupportedOperations', []).indexOf('c8y_Firmware') > -1));
        this.changesOperation$ = new BehaviorSubject(null);
        this.changesInProgress$ = this.changesOperation$.pipe(map(operation => this.isInProgress(operation)));
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO check route snapshot, why is not refreshing device.
            // Scenario: missing deviceFirmwareFragment => install new version => switch tabs.
            // Expected: device should be set.
            yield this.loadDevice();
            yield this.loadOperation();
        });
    }
    installFirmware() {
        const initialState = {
            repositoryEntriesWithVersions$: of([]),
            repositoryEntriesWithVersionsFn$: modal => this.getRepositoryEntriesWithVersions$(modal.content.searchTerm),
            repositoryType: RepositoryType.FIRMWARE,
            title: gettext('Install firmware'),
            subTitle: gettext('Available firmwares matching the device type'),
            icon: 'c8y-firmware',
            mode: ModalSelectionMode.SINGLE,
            labels: { ok: gettext('Install') },
            disableSelected: false
        };
        this.deviceFirmwareFragment$
            .pipe(take(1), switchMap(deviceFirmwareFragment => {
            if (deviceFirmwareFragment) {
                const { name, version } = deviceFirmwareFragment;
                const selected = [{ name, version }];
                assign(initialState, { selected });
            }
            const modal = this.bsModal.show(RepositorySelectModalComponent, {
                ignoreBackdropClick: true,
                initialState
            });
            if (initialState.repositoryEntriesWithVersionsFn$) {
                modal.content.repositoryEntriesWithVersions$ = initialState.repositoryEntriesWithVersionsFn$(modal);
            }
            modal.content.load.next();
            return modal.content.resultEmitter;
        }))
            .subscribe(([selectedFirmware]) => {
            this.handleOperation(selectedFirmware);
        });
    }
    getRepositoryEntriesWithVersions$(searchTerm$) {
        return searchTerm$.pipe(distinctUntilChanged(), switchMap(searchTerm => this.repository.listRepositoryEntries(RepositoryType.FIRMWARE, {
            query: this.repository.getDeviceTypeQuery(RepositoryType.FIRMWARE, this.device$.value),
            partialName: searchTerm,
            params: { pageSize: 100 }
        })), map(({ data }) => data), map(mos => this.getAndAssignRepositoryBinaries(mos)), shareReplay(1));
    }
    getAndAssignRepositoryBinaries(mos) {
        mos.forEach(mo => {
            mo.versions = this.repository.listBaseVersions(mo);
        });
        return mos;
    }
    addPatch() {
        const initialState = {
            repositoryType: RepositoryType.FIRMWARE,
            repositoryEntriesWithVersions$: this.getRepositoryEntryWithPatches$(),
            title: gettext('Install firmware'),
            subTitle: gettext('Available firmwares matching the device type'),
            icon: 'c8y-firmware',
            mode: ModalSelectionMode.SINGLE,
            labels: { ok: gettext('Install') },
            disableSelected: false
        };
        this.deviceFirmwareFragment$
            .pipe(take(1), switchMap(deviceFirmwareFragment => {
            if (deviceFirmwareFragment) {
                const { name, version } = deviceFirmwareFragment;
                const selected = [{ name, version }];
                assign(initialState, { selected });
            }
            const modal = this.bsModal.show(RepositorySelectModalComponent, {
                ignoreBackdropClick: true,
                initialState
            });
            modal.content.load.next();
            return modal.content.resultEmitter;
        }))
            .subscribe(([selectedOption]) => {
            this.handleOperation(selectedOption);
        });
    }
    getRepositoryEntryWithPatches$() {
        return combineLatest(this.repositoryEntry$, this.patches$).pipe(map(([repositoryEntry, patches]) => {
            return [Object.assign(Object.assign({}, repositoryEntry), { versions: patches })];
        }));
    }
    loadDevice() {
        return __awaiter(this, void 0, void 0, function* () {
            this.reloading = true;
            const deviceId = this.device$.value.id;
            const device = (yield this.inventory.detail(deviceId, { withChildren: false })).data;
            this.device$.next(device);
            this.reloading = false;
        });
    }
    handleOperation(selectedFirmware) {
        return __awaiter(this, void 0, void 0, function* () {
            const operation = yield this.repository.createFirmwareUpdateOperation(this.device$.value, selectedFirmware);
            this.trackOperation(operation);
        });
    }
    loadOperation() {
        return __awaiter(this, void 0, void 0, function* () {
            const deviceId = this.device$.value.id;
            const operation = yield this.repository.getLastFirmwareUpdateOperation(deviceId);
            this.trackOperation(operation);
        });
    }
    trackOperation(operation) {
        this.changesOperation$.next(operation);
        if (this.isInProgress(operation)) {
            this.repository.observeOperation(operation).subscribe(operationUpdate => {
                this.changesOperation$.next(operationUpdate);
                if (operationUpdate.status === OperationStatus.SUCCESSFUL) {
                    this.loadDevice();
                }
            }, operationUpdate => {
                this.changesOperation$.next(operationUpdate);
            });
        }
    }
    isInProgress(operation) {
        return (operation && [OperationStatus.PENDING, OperationStatus.EXECUTING].includes(operation.status));
    }
}
FirmwareDeviceTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-firmware-device-tab',
                template: "<div class=\"row\">\n  <div class=\"col-lg-12 col-lg-max\">\n    <div class=\"card\">\n      <div class=\"card-header separator\">\n        <h4 class=\"card-title\" translate>Current firmware</h4>\n      </div>\n      <div class=\"inner-scroll\">\n        <fieldset *ngIf=\"changesOperation$ | async\" class=\"card-block bg-gray-white\">\n          <c8y-single-operation [operation]=\"changesOperation$ | async\"></c8y-single-operation>\n        </fieldset>\n        <div class=\"card-block p-t-0 p-b-0\">\n          <!-- EMPTY STATE -->\n          <ng-container *ngIf=\"isEmpty(deviceFirmwareFragment$ | async); else firmwareBlock\">\n            <div class=\"c8y-empty-state text-center\">\n              <h1 c8yIcon=\"c8y-firmware\" class=\"c8y-icon-duocolor\"></h1>\n              <p>\n                <strong translate>No firmware installed.</strong> <br />\n                <small translate>Click below to install firmware into this device.</small>\n              </p>\n            </div>\n          </ng-container>\n\n          <!-- FIRMWARE -->\n          <ng-template #firmwareBlock>\n            <c8y-list-group class=\"no-border-last\">\n              <c8y-li>\n                <c8y-li-icon>\n                  <i c8yIcon=\"c8y-firmware\"></i>\n                </c8y-li-icon>\n\n                <c8y-li-body *ngIf=\"deviceFirmwareFragment$ | async as deviceFirmwareFragment\">\n                  <!-- Firmware title -->\n                  <p class=\"m-b-16 text-medium\">\n                    {{ deviceFirmwareFragment.name }}\n                  </p>\n                  <!-- Firmware description -->\n                  <div *ngIf=\"repositoryEntry$ | async as repositoryEntry\">\n                    <p class=\"text-label-small\" translate>Description</p>\n                    <p>\n                      {{ repositoryEntry.description }}\n                    </p>\n                  </div>\n\n                  <!-- BASE/PATCH VERSION -->\n                  <div class=\"m-b-16\">\n                    <p class=\"text-label-small\" translate>Version</p>\n                    <p *ngIf=\"deviceFirmwareFragment.version; else versionNotSpecified\">\n                      {{ deviceFirmwareFragment.version }}\n                    </p>\n                    <ng-template #versionNotSpecified>\n                      <p>\n                        <em class=\"text-muted\"> ({{ 'not specified`version`' | translate }}) </em>\n                      </p>\n                    </ng-template>\n                  </div>\n\n                  <!-- ADD PATCH -->\n                  <button\n                    *ngIf=\"\n                      (supportsFirmwareOperations$ | async) && (this.patches$ | async)?.length > 0\n                    \"\n                    (click)=\"addPatch()\"\n                    class=\"btn btn-xs btn-primary\"\n                    [disabled]=\"changesInProgress$ | async\"\n                    title=\"{{ 'Patches available' | translate }}\"\n                  >\n                    {{ 'Patches available' | translate }}\n                  </button>\n                </c8y-li-body>\n              </c8y-li>\n            </c8y-list-group>\n          </ng-template>\n        </div>\n      </div>\n      <div *ngIf=\"supportsFirmwareOperations$ | async\" class=\"card-footer separator-top\">\n        <!-- INSTALL FIRMWARE -->\n        <button\n          *ngIf=\"isEmpty(deviceFirmwareFragment$ | async)\"\n          class=\"btn btn-primary\"\n          (click)=\"installFirmware()\"\n          title=\"{{ 'Install firmware' | translate }}\"\n        >\n          {{ 'Install firmware' | translate }}\n        </button>\n\n        <!-- REPLACE FIRMWARE -->\n        <button\n          *ngIf=\"!isEmpty(deviceFirmwareFragment$ | async)\"\n          class=\"btn btn-primary\"\n          (click)=\"installFirmware()\"\n          [disabled]=\"changesInProgress$ | async\"\n          title=\"{{ 'Replace firmware' | translate }}\"\n        >\n          {{ 'Replace firmware' | translate }}\n        </button>\n      </div>\n    </div>\n  </div>\n</div>\n"
            },] }
];
FirmwareDeviceTabComponent.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: RepositoryService },
    { type: InventoryService },
    { type: BsModalService }
];

const FIRMWARE_FRAGMENT = 'c8y_Firmware';
const SUPPORTED_OPERATIONS_FRAGMENT = 'c8y_SupportedOperations';
class FirmwareDeviceTabGuard {
    canActivate(route) {
        const contextData = get(route, 'data.contextData') || get(route, 'parent.data.contextData');
        const supportedOperations = get(contextData, SUPPORTED_OPERATIONS_FRAGMENT);
        return ((!!supportedOperations ? indexOf(supportedOperations, FIRMWARE_FRAGMENT) >= 0 : false) ||
            has(contextData, 'c8y_Firmware'));
    }
}
FirmwareDeviceTabGuard.decorators = [
    { type: Injectable }
];

class AddFirmwareModalComponent {
    constructor(modal, repositoryService, alert) {
        this.modal = modal;
        this.repositoryService = repositoryService;
        this.alert = alert;
        this.saved = new EventEmitter();
        this.onInput = new BehaviorSubject('');
        this.model = {
            selected: undefined,
            version: undefined,
            description: undefined,
            deviceType: undefined,
            binary: {
                file: undefined,
                url: undefined
            }
        };
        this.saving = false;
        this.firmwarePreselected = false;
        this.textForFirmwareUrlPopover = gettext(`Path for binaries can vary depending on device agent implementation, e.g.:
    /firmware/binaries/firmware1.bin
    https://firmware/binary/123
    ftp://firmware/binary/123.tar.gz
  `);
    }
    ngOnInit() {
        this.setInitialState();
        this.loadFirmwares();
    }
    setInitialState() {
        if (this.model.selected) {
            this.firmwarePreselected = true;
        }
    }
    loadFirmwares() {
        this.inputSubscription$ = this.onInput
            .pipe(tap(() => {
            if (!this.firmwarePreselected) {
                this.model.description = null;
                if (this.form) {
                    this.form.form.get('description').reset();
                }
            }
        }), debounceTime(300), distinctUntilChanged(), switchMap(searchStr => this.getFirmwareResult(searchStr)))
            .subscribe(result => {
            this.firmwaresResult = result;
        });
    }
    getFirmwareResult(searchStr) {
        return from(this.repositoryService.listRepositoryEntries(RepositoryType.FIRMWARE, {
            partialName: searchStr,
            skipLegacy: true
        }));
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            this.saving = true;
            this.repositoryService
                .create(this.model, RepositoryType.FIRMWARE)
                .then(savedFirmware => {
                this.successMsg();
                this.saving = false;
                this.saved.next(savedFirmware);
                this.cancel();
            })
                .catch(e => {
                this.saving = false;
                this.saved.error(e);
                this.cancel();
            });
        });
    }
    successMsg() {
        const msg = gettext('Firmware added.');
        this.alert.success(msg);
    }
    cancel() {
        this.modal.hide();
        this.saved.complete();
    }
    ngOnDestroy() {
        this.inputSubscription$.unsubscribe();
    }
    onFile(dropped) {
        if (!isUndefined(dropped.url)) {
            this.model.binary = {
                url: dropped.url
            };
            return;
        }
        else if (!isUndefined(dropped.droppedFiles)) {
            this.model.binary = {
                file: dropped.droppedFiles[0].file
            };
            return;
        }
        else {
            this.model.binary = {
                file: undefined,
                url: undefined
            };
        }
    }
    onFirmwareSelect(firmware) {
        assign(this.model, {
            selected: firmware,
            description: firmware.description,
            deviceType: get(firmware, 'c8y_Filter.type')
        });
    }
}
AddFirmwareModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-add-firmware-software-modal',
                template: "<div class=\"viewport-modal\">\n  <div class=\"modal-header dialog-header\">\n    <i [c8yIcon]=\"'c8y-firmware'\"></i>\n    <h4 translate>\n      Add firmware\n    </h4>\n  </div>\n  <div class=\"p-16 text-center separator-bottom\" *ngIf=\"!firmwarePreselected\">\n    <p class=\"lead m-0\" translate>\n      Select or create new firmware\n    </p>\n  </div>\n  <form\n    class=\"d-contents\"\n    autocomplete=\"off\"\n    #firmwareForm=\"ngForm\"\n    (ngSubmit)=\"firmwareForm.form.valid && save()\"\n  >\n    <div class=\"modal-inner-scroll\">\n      <div class=\"modal-body\">\n        <div [hidden]=\"firmwarePreselected\">\n          <c8y-form-group>\n            <label for=\"firmwareName\" translate>Firmware</label>\n            <c8y-typeahead\n              [(ngModel)]=\"model.selected\"\n              name=\"firmwareName\"\n              placeholder=\"{{ 'Select or enter' | translate }}\"\n              (onSearch)=\"onInput.next($event)\"\n              [required]=\"true\"\n            >\n              <c8y-li\n                *c8yFor=\"\n                  let firmware of firmwaresResult;\n                  loadMore: 'auto';\n                  notFound: notFoundTemplate\n                \"\n                class=\"p-l-8 p-r-8 c8y-list__item--link\"\n                (click)=\"onFirmwareSelect(firmware)\"\n                [active]=\"model.selected === firmware\"\n              >\n                <c8y-highlight\n                  [text]=\"firmware.name || '--'\"\n                  [pattern]=\"onInput | async\"\n                ></c8y-highlight>\n              </c8y-li>\n              <ng-template #notFoundTemplate>\n                <c8y-li class=\"bg-gray-lighter p-8\" *ngIf=\"(onInput | async)?.length > 0\">\n                  <span translate>No match found.</span>\n                  <button\n                    title=\"{{ 'Add new`firmware`' | translate }}\"\n                    type=\"button\"\n                    class=\"btn btn-primary btn-xs m-l-16\"\n                    translate\n                  >\n                    Add new`firmware`\n                  </button>\n                </c8y-li>\n              </ng-template>\n            </c8y-typeahead>\n          </c8y-form-group>\n\n          <c8y-form-group>\n            <label for=\"firmwareDescription\" translate>Description</label>\n            <input\n              id=\"firmwareDescription\"\n              class=\"form-control\"\n              autocomplete=\"off\"\n              name=\"description\"\n              [(ngModel)]=\"model.description\"\n              placeholder=\"{{ 'e.g. Firmware for hardware revision b' | translate }}\"\n              [disabled]=\"model.selected?.id\"\n              [required]=\"true\"\n            />\n          </c8y-form-group>\n\n          <c8y-form-group>\n            <label class=\"control-label\" for=\"firmwareDeviceTypeFilter\">\n              {{ 'Device type filter' | translate }}\n              <button\n                class=\"btn btn-clean text-primary\"\n                popover=\"{{\n                  'If the filter is set, the firmware will show up for installation only for devices of that type. If no filter is set, it will be available for all devices.'\n                    | translate\n                }}\"\n                triggers=\"focus\"\n                container=\"body\"\n                placement=\"right\"\n              >\n                <i [c8yIcon]=\"'question-circle-o'\"></i>\n              </button>\n            </label>\n            <input\n              id=\"firmwareDeviceTypeFilter\"\n              class=\"form-control\"\n              name=\"firmwareDeviceTypeFilter\"\n              [(ngModel)]=\"model.deviceType\"\n              placeholder=\"{{ 'e.g.' | translate }} c8y_Linux\"\n              [disabled]=\"model.selected?.id\"\n            />\n          </c8y-form-group>\n        </div>\n\n        <c8y-form-group>\n          <label for=\"firmwareVersion\" translate>Version</label>\n          <input\n            id=\"firmwareVersion\"\n            class=\"form-control\"\n            autocomplete=\"off\"\n            name=\"version\"\n            [(ngModel)]=\"model.version\"\n            placeholder=\"{{ 'e.g.' | translate }} 1.0.0\"\n            [required]=\"true\"\n          />\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <div class=\"legend form-block m-t-40\" translate>Firmware file</div>\n          <c8y-file-picker [maxAllowedFiles]=\"1\" (onFilesPicked)=\"onFile($event)\" [fileUrlPopover]=\"textForFirmwareUrlPopover\">\n          </c8y-file-picker>\n        </c8y-form-group>\n      </div>\n    </div>\n    <div class=\"modal-footer\">\n      <button\n        title=\"{{ 'Cancel' | translate }}\"\n        class=\"btn btn-default\"\n        type=\"button\"\n        (click)=\"cancel()\"\n        [disabled]=\"saving\"\n        translate\n      >\n        Cancel\n      </button>\n\n      <button\n        title=\"{{ 'Add firmware' | translate }}\"\n        class=\"btn btn-primary\"\n        type=\"submit\"\n        [ngClass]=\"{ 'btn-pending': saving }\"\n        [disabled]=\"\n          !firmwareForm.form.valid ||\n          firmwareForm.form.pristine ||\n          saving ||\n          (!model.binary?.url && !model.binary?.file)\n        \"\n        translate\n      >\n        Add firmware\n      </button>\n    </div>\n  </form>\n</div>\n"
            },] }
];
AddFirmwareModalComponent.ctorParameters = () => [
    { type: BsModalRef },
    { type: RepositoryService },
    { type: AlertService }
];
AddFirmwareModalComponent.propDecorators = {
    form: [{ type: ViewChild, args: ['firmwareForm', { static: false },] }],
    saved: [{ type: Output }]
};

class AddFirmwarePatchModalComponent {
    constructor(modal, repository, alert) {
        this.modal = modal;
        this.repository = repository;
        this.alert = alert;
        this.saved = new EventEmitter();
        this.textForFirmwareUrlPopover = gettext(`Path for binaries can vary depending on device agent implementation, e.g.:
    /firmware/binaries/firmware1.bin
    https://firmware/binary/123
    ftp://firmware/binary/123.tar.gz
  `);
        this.model = {
            selected: undefined,
            dependency: null,
            patchVersion: undefined,
            binary: {
                file: undefined,
                url: undefined
            }
        };
        this.firmwareInput$ = new BehaviorSubject('');
        this.firmwares$ = this.firmwareInput$.pipe(debounceTime(300), distinctUntilChanged(), switchMap(searchStr => from(this.repository.listRepositoryEntries(RepositoryType.FIRMWARE, {
            partialName: searchStr,
            skipLegacy: true
        }))), shareReplay(1));
        this.firmwareSelected$ = new BehaviorSubject(null);
        this.patchDependencyInput$ = new BehaviorSubject('');
        this.saving = false;
        this.firmwarePreselected = false;
        this.baseVersions$ = merge(this.firmwareInput$.pipe(tap(() => {
            this.model.dependency = null;
            if (this.form) {
                this.form.form.get('patchDependency').reset();
            }
        }), switchMap(() => of(null))), this.firmwareSelected$).pipe(switchMap(selectedFirmware => selectedFirmware ? this.repository.listBaseVersions(selectedFirmware) : of(null)), shareReplay(1));
        this.baseVersionsFilterPipe = pipe(switchMap((data) => this.patchDependencyInput$.pipe(map(partialVersion => data.filter((mo) => {
            const version = mo.c8y_Firmware.version.toLowerCase();
            return (partialVersion.length === 0 || version.indexOf(partialVersion.toLowerCase()) > -1);
        })))));
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.setInitialState();
        });
    }
    setInitialState() {
        if (this.model.selected) {
            this.firmwarePreselected = true;
            this.firmwareSelected$.next(this.model.selected);
        }
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            this.saving = true;
            this.repository
                .create(this.model, RepositoryType.FIRMWARE)
                .then(savedFirmware => {
                this.successMsg();
                this.saving = false;
                this.saved.next(savedFirmware);
                this.cancel();
            })
                .catch(e => {
                this.saving = false;
                this.saved.error(e);
                this.cancel();
            });
        });
    }
    successMsg() {
        const msg = gettext('Firmware patch added.');
        this.alert.success(msg);
    }
    cancel() {
        this.modal.hide();
        this.saved.complete();
    }
    onFile(dropped) {
        if (!isUndefined(dropped.url)) {
            this.model.binary = {
                url: dropped.url
            };
            return;
        }
        else if (!isUndefined(dropped.droppedFiles)) {
            this.model.binary = {
                file: dropped.droppedFiles[0].file
            };
            return;
        }
        else {
            this.model.binary = {
                file: undefined,
                url: undefined
            };
        }
    }
}
AddFirmwarePatchModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-add-firmware-patch-modal.component',
                template: "<div class=\"viewport-modal\">\n  <div class=\"modal-header dialog-header\">\n    <i [c8yIcon]=\"'c8y-firmware'\"></i>\n    <h4 translate>\n      Add firmware patch\n    </h4>\n  </div>\n  <div class=\"p-16 text-center separator-bottom\">\n    <p class=\"lead m-0\" translate>\n      Select a firmware version\n    </p>\n  </div>\n\n  <form\n    class=\"d-contents\"\n    autocomplete=\"off\"\n    #firmwarePatchForm=\"ngForm\"\n    (ngSubmit)=\"firmwarePatchForm.form.valid && save()\">\n    <div class=\"modal-inner-scroll\">\n      <div class=\"modal-body\">\n        <div [hidden]=\"firmwarePreselected\">\n          <c8y-form-group>\n            <label for=\"firmwareName\" translate>Firmware</label>\n            <c8y-typeahead\n              [ngModel]=\"model.selected\"\n              name=\"firmwareName\"\n              placeholder=\"{{ 'Select or enter' | translate }}\"\n              (onSearch)=\"firmwareInput$.next($event)\"\n              [allowFreeEntries]=\"false\"\n              [required]=\"true\"\n            >\n              <c8y-li\n                *c8yFor=\"let firmware of firmwares$ | async; loadMore: 'auto'\"\n                class=\"p-l-8 p-r-8 c8y-list__item--link\"\n                (click)=\"model.selected = firmware; firmwareSelected$.next(firmware)\"\n                [active]=\"model.selected === firmware\"\n              >\n                <c8y-highlight\n                  [text]=\"firmware.name || '--'\"\n                  [pattern]=\"firmwareInput$ | async\"\n                ></c8y-highlight>\n              </c8y-li>\n            </c8y-typeahead>\n            <c8y-messages\n              ><c8y-message\n                name=\"notExisting\"\n                [text]=\"'Select one of the existing firmwares.' | translate\"\n              ></c8y-message>\n            </c8y-messages>\n          </c8y-form-group>\n        </div>\n\n        <c8y-form-group>\n          <label for=\"patchDependency\" class=\"m-r-8\" translate>Version</label>\n          <c8y-typeahead\n            [ngModel]=\"model.dependency\"\n            name=\"patchDependency\"\n            placeholder=\"{{ 'Select or enter' | translate }}\"\n            (onSearch)=\"patchDependencyInput$.next($event)\"\n            [displayProperty]=\"'c8y_Firmware.version'\"\n            [allowFreeEntries]=\"false\"\n            [disabled]=\"\n              (baseVersions$ | async) === null || (baseVersions$ | async)?.data.length === 0\n            \"\n            [required]=\"true\"\n          >\n            <c8y-li\n              *c8yFor=\"\n                let baseVersion of baseVersions$;\n                loadMore: 'auto';\n                pipe: baseVersionsFilterPipe\n              \"\n              class=\"p-l-8 p-r-8 c8y-list__item--link\"\n              (click)=\"model.dependency = baseVersion\"\n              [active]=\"model.dependency === baseVersion\"\n            >\n              <c8y-highlight\n                [text]=\"baseVersion.c8y_Firmware.version || '--'\"\n                [pattern]=\"patchDependencyInput$ | async\"\n              ></c8y-highlight>\n            </c8y-li>\n          </c8y-typeahead>\n          <c8y-messages\n            ><c8y-message\n              name=\"notExisting\"\n              [text]=\"'Select one of the existing versions.' | translate\"\n            ></c8y-message>\n          </c8y-messages>\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <label for=\"patchVersion\" translate>Patch</label>\n          <input\n            id=\"patchVersion\"\n            class=\"form-control\"\n            autocomplete=\"off\"\n            name=\"patchVersion\"\n            [(ngModel)]=\"model.patchVersion\"\n            placeholder=\"{{ 'e.g.' | translate }} 1.0.0\"\n            required\n          />\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <div class=\"legend form-block m-t-40\" translate>Patch file</div>\n          <c8y-file-picker [maxAllowedFiles]=\"1\" (onFilesPicked)=\"onFile($event)\" [fileUrlPopover]=\"textForFirmwareUrlPopover\">\n          </c8y-file-picker>\n        </c8y-form-group>\n      </div>\n    </div>\n    <div class=\"modal-footer\">\n      <button\n        title=\"{{ 'Cancel' | translate }}\"\n        class=\"btn btn-default\"\n        type=\"button\"\n        (click)=\"cancel()\"\n        [disabled]=\"saving\"\n        translate\n      >\n        Cancel\n      </button>\n      <button\n        title=\"{{ 'Add firmware patch' | translate }}\"\n        class=\"btn btn-primary\"\n        type=\"submit\"\n        [ngClass]=\"{ 'btn-pending': saving }\"\n        [disabled]=\"\n          !firmwarePatchForm.form.valid ||\n          firmwarePatchForm.form.pristine ||\n          (!model.binary?.url && !model.binary?.file) ||\n          saving\n        \"\n        translate\n      >\n        Add firmware patch\n      </button>\n    </div>\n  </form>\n</div>\n"
            },] }
];
AddFirmwarePatchModalComponent.ctorParameters = () => [
    { type: BsModalRef },
    { type: RepositoryService },
    { type: AlertService }
];
AddFirmwarePatchModalComponent.propDecorators = {
    saved: [{ type: Output }],
    dropdown: [{ type: ViewChild, args: ['dropdown', { static: false },] }],
    form: [{ type: ViewChild, args: ['firmwarePatchForm', { static: false },] }]
};

class FirmwareDetailsComponent {
    constructor(activatedRoute, inventoryService, repositoryService, alertService, translateService, modalService, bsModalService) {
        this.activatedRoute = activatedRoute;
        this.inventoryService = inventoryService;
        this.repositoryService = repositoryService;
        this.alertService = alertService;
        this.translateService = translateService;
        this.modalService = modalService;
        this.bsModalService = bsModalService;
        this.reload$ = new Subject();
        this.reloading$ = new BehaviorSubject(false);
        this.updateFirmware$ = new Subject();
        this.firmwareUpdated$ = new Subject();
        this.baseVersionsUpdated$ = new Subject();
        this.patchVersionsUpdated$ = new Subject();
        this.firmware$ = merge(this.activatedRoute.params.pipe(map(params => params.id), switchMap(id => defer(() => this.inventoryService.detail(id).then(result => result.data)))), this.reload$.pipe(tap(() => this.reloading$.next(true)), switchMap(() => this.activatedRoute.params), map(params => params.id), switchMap(id => defer(() => this.inventoryService.detail(id).then(result => result.data))), tap(() => this.reloading$.next(false))), this.firmwareUpdated$).pipe(shareReplay(1));
        this.baseVersions$ = merge(this.firmware$.pipe(distinctUntilKeyChanged('id')), this.baseVersionsUpdated$, this.patchVersionsUpdated$, this.reload$).pipe(switchMap(() => this.firmware$), switchMap(firmware => this.repositoryService.listBaseVersions(firmware)), shareReplay(1));
        this.isLegacy$ = this.firmware$.pipe(map(firmware => this.repositoryService.isLegacyEntry(firmware)), shareReplay(1));
        this.canAddPatchVersions$ = combineLatest(this.isLegacy$, this.baseVersions$.pipe(map(({ data }) => data.length > 0))).pipe(map(([isLegacy, hasBaseVersions]) => !isLegacy && hasBaseVersions));
        this.expanded = {};
        this.destroy$ = new Subject();
    }
    ngOnInit() {
        this.updateFirmware$
            .pipe(withLatestFrom(this.firmware$), switchMap(([firmwarePartial, firmware]) => this.inventoryService.update(Object.assign({ id: firmware.id }, firmwarePartial))), map(({ data }) => data), tap(firmware => this.firmwareUpdated$.next(firmware)), tap(() => this.alertService.success(gettext('Saved.'))), takeUntil(this.destroy$))
            .subscribe();
    }
    getPatchVersionsCount$(baseVersion) {
        return merge(this.firmware$.pipe(distinctUntilKeyChanged('id')), this.baseVersionsUpdated$, this.patchVersionsUpdated$, this.reload$).pipe(switchMap(() => this.firmware$), switchMap(firmware => this.repositoryService.getPatchVersionsCount$(firmware, baseVersion)), shareReplay(1));
    }
    getBinaryName$(binaryUrl) {
        return this.repositoryService.getBinaryName$(binaryUrl);
    }
    getPatchVersions$(baseVersion) {
        return merge(this.firmware$.pipe(distinctUntilKeyChanged('id')), this.patchVersionsUpdated$, this.reload$).pipe(switchMap(() => this.firmware$), switchMap(firmware => this.repositoryService.listPatchVersions(firmware, baseVersion)), shareReplay(1));
    }
    addBaseVersion() {
        this.firmware$
            .pipe(take(1), switchMap(firmware => {
            const initialState = {
                model: {
                    selected: firmware,
                    description: firmware.description
                }
            };
            const config = {
                class: 'modal-sm',
                ignoreBackdropClick: true,
                initialState
            };
            const modalRef = this.bsModalService.show(AddFirmwareModalComponent, config);
            return modalRef.content.saved;
        }))
            .subscribe(() => this.baseVersionsUpdated$.next());
    }
    addPatchVersion() {
        this.firmware$
            .pipe(take(1), switchMap(firmware => {
            const initialState = {
                model: {
                    selected: firmware
                }
            };
            const config = {
                class: 'modal-sm',
                ignoreBackdropClick: true,
                initialState
            };
            const modalRef = this.bsModalService.show(AddFirmwarePatchModalComponent, config);
            return modalRef.content.saved;
        }))
            .subscribe(() => this.patchVersionsUpdated$.next());
    }
    deleteBaseVersion(baseVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const title = gettext('Delete firmware');
                const body = `
        ${this.translateService.instant(gettext('You are about to delete firmware {{ version }} with all its patches.'), { version: baseVersion.c8y_Firmware.version })}
        ${this.translateService.instant(gettext('This operation is irreversible.'))}
        ${this.translateService.instant(gettext('Do you want to proceed?'))}
      `;
                const labels = {
                    ok: gettext('Delete')
                };
                yield this.modalService.confirm(title, body, Status.DANGER, labels);
                yield this.repositoryService.delete(baseVersion);
                this.alertService.success(gettext('Firmware deleted.'));
                this.baseVersionsUpdated$.next();
            }
            catch (ex) {
                // only if not cancel from modal
                if (ex) {
                    this.alertService.addServerFailure(ex);
                }
            }
        });
    }
    deletePatchVersion(patchVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const title = gettext('Delete firmware patch');
                const body = `
        ${this.translateService.instant(gettext('You are about to delete firmware patch {{ version }}.'), { version: patchVersion.c8y_Firmware.version })}
        ${this.translateService.instant(gettext('This operation is irreversible.'))}
        ${this.translateService.instant(gettext('Do you want to proceed?'))}
      `;
                const labels = {
                    ok: gettext('Delete')
                };
                yield this.modalService.confirm(title, body, Status.DANGER, labels);
                yield this.repositoryService.delete(patchVersion);
                this.alertService.success(gettext('Firmware patch deleted.'));
                this.patchVersionsUpdated$.next();
            }
            catch (ex) {
                // only if not cancel from modal
                if (ex) {
                    this.alertService.addServerFailure(ex);
                }
            }
        });
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.unsubscribe();
    }
}
FirmwareDetailsComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-firmware-details',
                template: "<c8y-title>\n  {{ (firmware$ | async)?.name }}\n</c8y-title>\n\n<c8y-breadcrumb>\n  <c8y-breadcrumb-item\n    path=\"#/firmware\"\n    label=\"{{ 'Firmware repository' | translate }}\"\n    icon=\"c8y-firmware\"\n  >\n  </c8y-breadcrumb-item>\n</c8y-breadcrumb>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button\n    *ngIf=\"!(isLegacy$ | async)\"\n    class=\"btn btn-link\"\n    title=\"{{ 'Add firmware' | translate }}\"\n    (click)=\"addBaseVersion()\"\n  >\n    <i c8yIcon=\"plus-circle\"></i>\n    {{ 'Add firmware' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button\n    *ngIf=\"canAddPatchVersions$ | async\"\n    class=\"btn btn-link\"\n    title=\"{{ 'Add firmware patch' | translate }}\"\n    (click)=\"addPatchVersion()\"\n  >\n    <i c8yIcon=\"plus-circle\"></i>\n    {{ 'Add firmware patch' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\" title=\"{{ 'Reload' | translate }}\" (click)=\"reload$.next()\">\n    <i c8yIcon=\"refresh\" [ngClass]=\"{ 'icon-spin': reloading$ | async }\"></i>\n    {{ 'Reload' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<div class=\"row\">\n  <div class=\"col-lg-12 col-lg-max\">\n    <div class=\"card m-b-4\">\n      <div class=\"card-header separator\">\n        <h4 class=\"card-title\" translate>\n          Name, description and device type filter\n        </h4>\n      </div>\n      <div class=\"card-block\">\n        <div class=\"row\">\n          <div class=\"col-md-4\">\n            <c8y-form-group>\n              <label class=\"control-label\">\n                {{ 'Name' | translate }}\n              </label>\n              <div class=\"input-group input-group-editable\">\n                <input\n                  #nameInput\n                  type=\"text\"\n                  class=\"form-control\"\n                  [ngModel]=\"(firmware$ | async)?.name\"\n                  #nameModel=\"ngModel\"\n                  placeholder=\"{{ 'e.g. My firmware' | translate }}\"\n                  [ngStyle]=\"{ 'width.ch': (firmware$ | async)?.name?.length || 31 }\"\n                  required\n                />\n                <span></span>\n                <div class=\"input-group-btn\">\n                  <button\n                    class=\"btn btn-primary\"\n                    title=\"{{ 'Save' | translate }}\"\n                    (click)=\"updateFirmware$.next({ name: nameInput.value }); nameModel.reset()\"\n                    [disabled]=\"nameInput.value.length == 0\"\n                  >\n                    {{ 'Save' | translate }}\n                  </button>\n                </div>\n              </div>\n            </c8y-form-group>\n          </div>\n          <div class=\"col-md-4\">\n            <c8y-form-group>\n              <label class=\"control-label\">\n                {{ 'Description' | translate }}\n              </label>\n              <div class=\"input-group input-group-editable\">\n                <input\n                  #descriptionInput\n                  type=\"text\"\n                  class=\"form-control\"\n                  [ngModel]=\"(firmware$ | async)?.description\"\n                  #descriptionModel=\"ngModel\"\n                  placeholder=\"{{ 'e.g. Firmware for hardware revision b' | translate }}\"\n                  [ngStyle]=\"{ 'width.ch': (firmware$ | async)?.description?.length || 31 }\"\n\n                />\n                <span></span>\n                <div class=\"input-group-btn\">\n                  <button\n                    class=\"btn btn-primary\"\n                    title=\"{{ 'Save' | translate }}\"\n                    (click)=\" updateFirmware$.next({ description: descriptionInput.value }); descriptionModel.reset() \"\n                  >\n                    {{ 'Save' | translate }}\n                  </button>\n                </div>\n              </div>\n            </c8y-form-group>\n          </div>\n          <div class=\"col-md-4\">\n            <c8y-form-group>\n              <label class=\"control-label\">\n                {{ 'Device type filter' | translate }}\n\n                <button\n                 class=\"btn-clean\"\n                  popover=\"{{ 'If the filter is set, the firmware will show up for installation only for devices of that type. If no filter is set, it will be available for all devices.' | translate }}\"\n                  [outsideClick]=\"true\"\n                  container=\"body\"\n                >\n                  <i c8yIcon=\"question-circle-o\" class=\"text-info\"></i>\n                </button>\n              </label>\n              <div class=\"input-group input-group-editable\">\n                <input\n                  #deviceTypeInput\n                  type=\"text\"\n                  class=\"form-control\"\n                  [ngModel]=\"(firmware$ | async)?.c8y_Filter?.type\"\n                  #deviceTypeModel=\"ngModel\"\n                  placeholder=\"{{ 'e.g.' | translate }} c8y_Linux\"\n                  [ngStyle]=\"{ 'width.ch': (firmware$ | async)?.type?.length || 31 }\"\n                />\n                <span></span>\n                <div class=\"input-group-btn\">\n                  <button\n                    class=\"btn btn-primary\"\n                    title=\"{{ 'Save' | translate }}\"\n                    (click)=\" updateFirmware$.next({ c8y_Filter: { type: deviceTypeInput.value } }); deviceTypeModel.reset()\"\n                  >\n                    {{ 'Save' | translate }}\n                  </button>\n                </div>\n              </div>\n            </c8y-form-group>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n<div class=\"row\">\n  <div class=\"col-lg-12 col-lg-max\">\n    <div class=\"card\">\n      <div class=\"card-header separator\">\n        <h4 class=\"card-title\" translate>\n          Versions and patches\n        </h4>\n      </div>\n\n      <div class=\"card-block p-t-0 p-b-24\">\n        <div *ngIf=\"(baseVersions$ | async)?.data.length === 0\">\n          <div class=\"c8y-empty-state text-center\">\n            <h1 c8yIcon=\"c8y-firmware\" class=\"c8y-icon-duocolor\"></h1>\n            <h3 translate>No versions to display.</h3>\n            <p translate>Add a new version by clicking below.</p>\n            <p>\n              <button\n                class=\"btn btn-primary\"\n                title=\"{{ 'Add firmware' | translate }}\"\n                (click)=\"addBaseVersion()\"\n              >\n                {{ 'Add firmware' | translate }}\n              </button>\n            </p>\n          </div>\n        </div>\n\n        <c8y-list-group\n          [ngClass]=\"{ 'dd-low': (baseVersions$ | async)?.data.length < 10 }\"\n          *ngIf=\"(baseVersions$ | async)?.data.length > 0\"\n        >\n          <c8y-li\n            *c8yFor=\"let baseVersion of baseVersions$ | async; let i = index; loadMore: 'auto'\"\n            [ngClass]=\"{ 'c8y-list__item--empty-actions': !(getPatchVersions$(baseVersion) | async)?.data.length }\"\n            [collapsed]=\"!expanded[baseVersion.id]\"\n            (collapsedChange)=\"expanded[baseVersion.id] = !$event\"\n          >\n            <c8y-li-icon>\n              <i c8yIcon=\"c8y-firmware\"></i>\n            </c8y-li-icon>\n\n            <c8y-li-body class=\"content-flex-50\">\n              <div class=\"col-4\">\n                <p class=\"text-truncate-wrap\" title=\"{{ baseVersion.c8y_Firmware.version }}\">\n                  {{ baseVersion.c8y_Firmware.version }}\n                </p>\n              </div>\n              <div class=\"col-5\">\n                <p class=\"text-truncate-wrap\">\n                  <span class=\"text-label-small m-r-8\" translate>\n                    File\n                  </span>\n                  <span title=\"{{ getBinaryName$(baseVersion.c8y_Firmware.url) | async }}\">\n                    <c8y-file-download url=\"{{ baseVersion.c8y_Firmware.url }}\"></c8y-file-download>\n                  </span>\n                </p>\n              </div>\n              <div class=\"col-2 flex-row a-i-start\">\n                <span *ngIf=\"isLegacy$ | async\" class=\"label label-warning flex-item-right-sm\">\n                  {{ 'Legacy' | translate }}\n                </span>\n\n                <span *ngIf=\"!(isLegacy$ | async)\">\n                  <span *ngIf=\"(getPatchVersionsCount$(baseVersion) | async) === null\">\n                    <span class=\"label label-info\">\n                      <i c8yIcon=\"circle-o-notch\" class=\"icon-spin\"></i>\n                    </span>\n                  </span>\n                  <span *ngIf=\"(getPatchVersionsCount$(baseVersion) | async) !== null\">\n                    <span [ngPlural]=\"getPatchVersionsCount$(baseVersion) | async\">\n                      <ng-template ngPluralCase=\"=0\">\n                        <span class=\"label label-default flex-item-right-sm\">\n                          <span translate>No patches</span>\n                        </span>\n                      </ng-template>\n                      <ng-template ngPluralCase=\"=1\">\n                        <span class=\"label label-info\">\n                          <span translate>1 patch</span>\n                        </span>\n                      </ng-template>\n                      <ng-template ngPluralCase=\"other\">\n                        <span class=\"label label-info\">\n                          <span\n                            ngNonBindable\n                            translate\n                            [translateParams]=\"{ count: getPatchVersionsCount$(baseVersion) | async }\"\n                          >\n                            {{ count }} patches\n                          </span>\n                        </span>\n                      </ng-template>\n                    </span>\n                  </span>\n                </span>\n              </div>\n              <div class=\"fit-h-20 visible-xs\" *ngIf=\"!(isLegacy$ | async)\">\n                <button\n                  class=\"btn btn-danger btn-xs m-t-8 \"\n                  (click)=\"deleteBaseVersion(baseVersion)\"\n                  title=\"{{ 'Delete' | translate }}\"\n                >\n                  <i c8yIcon=\"minus-circle\"></i>\n                  {{ 'Delete' | translate }}\n                </button>\n              </div>\n              <div *ngIf=\"!(isLegacy$ | async)\" class=\"flex-item-right fit-h-20 p-r-8 hidden-xs\">\n                <button\n                  class=\"btn btn-dot text-danger showOnHover\"\n                  (click)=\"deleteBaseVersion(baseVersion)\"\n                  title=\"{{ 'Delete' | translate }}\"\n                >\n                  <i c8yIcon=\"minus-circle\"></i>\n                </button>\n              </div>\n            </c8y-li-body>\n            <c8y-li-collapse *ngIf=\"(getPatchVersions$(baseVersion) | async)?.data.length\">\n              <c8y-list-group class=\"separator-top\">\n                <c8y-li\n                  *c8yFor=\" let patchVersion of getPatchVersions$(baseVersion) | async; let i = index; loadMore: 'auto' \"\n                >\n                  <c8y-li-icon>\n                    <i c8yIcon=\"c8y-firmware\"></i>\n                  </c8y-li-icon>\n                  <c8y-li-body class=\"content-flex-50\">\n                    <div class=\"col-4\">\n                      {{ patchVersion.c8y_Firmware.version }}\n                    </div>\n                    <div class=\"col-5\">\n                      <div class=\"text-truncate\">\n                        <span class=\"text-label-small m-r-8\" translate>\n                          File\n                        </span>\n                        <c8y-file-download\n                          url=\"{{ patchVersion.c8y_Firmware.url }}\"\n                        ></c8y-file-download>\n                      </div>\n                    </div>\n                    <div class=\"visible-xs m-t-8\">\n                      <button\n                        class=\"btn btn-danger btn-xs\"\n                        (click)=\"deletePatchVersion(patchVersion)\"\n                        title=\"{{ 'Delete' | translate }}\"\n                      >\n                        <i c8yIcon=\"minus-circle\"></i>\n                        {{ 'Delete' | translate }}\n                      </button>\n                    </div>\n                    <div class=\"flex-item-right p-r-8 hidden-xs fit-h-20\">\n                      <button\n                        class=\"btn btn-dot text-danger showOnHover\"\n                        (click)=\"deletePatchVersion(patchVersion)\"\n                        title=\"{{ 'Delete' | translate }}\"\n                      >\n                        <i c8yIcon=\"minus-circle\"></i>\n                      </button>\n                    </div>\n                  </c8y-li-body>\n                </c8y-li>\n              </c8y-list-group>\n            </c8y-li-collapse>\n          </c8y-li>\n        </c8y-list-group>\n      </div>\n    </div>\n  </div>\n</div>\n"
            },] }
];
FirmwareDetailsComponent.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: InventoryService },
    { type: RepositoryService },
    { type: AlertService },
    { type: TranslateService },
    { type: ModalService },
    { type: BsModalService }
];
__decorate([
    memoize(property('id'))
], FirmwareDetailsComponent.prototype, "getPatchVersionsCount$", null);
__decorate([
    memoize()
], FirmwareDetailsComponent.prototype, "getBinaryName$", null);
__decorate([
    memoize(property('id'))
], FirmwareDetailsComponent.prototype, "getPatchVersions$", null);

class FirmwareListComponent {
    constructor(repositoryService, modalService, bsModalService, translateService, alertService, router, activatedRoute) {
        this.repositoryService = repositoryService;
        this.modalService = modalService;
        this.bsModalService = bsModalService;
        this.translateService = translateService;
        this.alertService = alertService;
        this.router = router;
        this.activatedRoute = activatedRoute;
        this.textFilter$ = new BehaviorSubject('');
        this.reload$ = new BehaviorSubject(null);
        this.reloading = false;
        this.firmwares$ = combineLatest(this.textFilter$.pipe(debounceTime(400), distinctUntilChanged()), this.reload$).pipe(tap(() => {
            this.reloading = true;
        }), switchMap(([text]) => this.getFirmwares(text)), tap(() => {
            this.reloading = false;
        }), shareReplay(1));
        this.canAddFirmwarePatch$ = from(this.repositoryService.listRepositoryEntries(RepositoryType.FIRMWARE, { skipLegacy: true })).pipe(map(({ data }) => data.length > 0));
        this.isLegacy = this.repositoryService.isLegacyEntry.bind(this.repositoryService);
        this.DEVICE_TYPE_NOT_AVAILABLE = gettext('No device type available');
    }
    getFirmwares(partialText) {
        const properties = ['name', 'description', 'c8y_Filter.type'];
        const partialTextFilter = { partialText, properties };
        return this.repositoryService.listRepositoryEntries(RepositoryType.FIRMWARE, {
            partialTextFilter
        });
    }
    addFirmware() {
        const config = { class: 'modal-sm', ignoreBackdropClick: true };
        const modalRef = this.bsModalService.show(AddFirmwareModalComponent, config);
        modalRef.content.saved.subscribe(savedFirmware => this.editFirmware(savedFirmware));
    }
    addFirmwarePatch() {
        const config = { class: 'modal-sm', ignoreBackdropClick: true };
        const modalRef = this.bsModalService.show(AddFirmwarePatchModalComponent, config);
        modalRef.content.saved.subscribe(savedFirmware => this.editFirmware(savedFirmware));
    }
    editFirmware(firmware) {
        this.router.navigate([firmware.id], { relativeTo: this.activatedRoute });
    }
    deleteFirmware(firmware) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const title = gettext('Delete firmware');
                const body = `
        ${this.translateService.instant(gettext('You are about to delete firmware "{{ name }}" with all its versions and patches.'), { name: firmware.name })}
        ${this.translateService.instant(gettext('This operation is irreversible.'))}
        ${this.translateService.instant(gettext('Do you want to proceed?'))}
      `;
                const labels = {
                    ok: gettext('Delete')
                };
                yield this.modalService.confirm(title, body, Status.DANGER, labels);
                yield this.repositoryService.delete(firmware);
                this.alertService.success(gettext('Firmware deleted.'));
                this.reload$.next();
            }
            catch (ex) {
                // only if not cancel from modal
                if (ex) {
                    this.alertService.addServerFailure(ex);
                }
            }
        });
    }
    getBaseVersionsCount$(firmware) {
        return this.firmwares$.pipe(switchMap(() => this.repositoryService.getBaseVersionsCount$(firmware)), shareReplay(1));
    }
    getDeviceTypeTitle(firmware) {
        return get(firmware, 'c8y_Filter.type', this.translateService.instant(this.DEVICE_TYPE_NOT_AVAILABLE));
    }
}
FirmwareListComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-firmware-list',
                template: "<c8y-title>\n  {{ 'Firmware repository' | translate }}\n</c8y-title>\n\n<c8y-action-bar-item [placement]=\"'left'\" itemClass=\"navbar-form\">\n  <div class=\"input-group input-group-search\">\n    <input class=\"form-control\"\n      type=\"search\"\n      title=\"{{ 'Filter firmware\u2026' | translate }}\"\n      placeholder=\"{{ 'Filter firmware\u2026' | translate }}\"\n      [ngModel]=\"textFilter$ | async\"\n      (ngModelChange)=\"textFilter$.next($event)\"\n    />\n    <span class=\"input-group-addon\">\n      <i\n        c8yIcon=\"search\"\n        *ngIf=\"(textFilter$ | async).length === 0\"\n      ></i>\n      <i class=\"text-muted\"\n        c8yIcon=\"times\"\n        *ngIf=\"(textFilter$ | async).length > 0\"\n        (click)=\"textFilter$.next('')\"\n      ></i>\n    </span>\n  </div>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\"\n    title=\"{{ 'Add firmware' | translate }}\"\n    (click)=\"addFirmware()\"\n  >\n    <i c8yIcon=\"plus-circle\"></i>\n    {{ 'Add firmware' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\"\n    *ngIf=\"canAddFirmwarePatch$ | async\"\n    title=\"{{ 'Add firmware patch' | translate }}\"\n    (click)=\"addFirmwarePatch()\"\n  >\n    <i c8yIcon=\"plus-circle\"></i>\n    {{ 'Add firmware patch' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\"\n    title=\"{{ 'Reload' | translate }}\"\n    (click)=\"reload$.next()\"\n  >\n    <i c8yIcon=\"refresh\"\n      [ngClass]=\"{ 'icon-spin': reloading }\"\n    ></i>\n    {{ 'Reload' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<!-- empty state-->\n<div class=\"c8y-empty-state text-center\"\n  *ngIf=\"(firmwares$ | async)?.data.length === 0 && (textFilter$ | async)?.length === 0\"\n>\n  <h1 class=\"c8y-icon-duocolor\"\n    c8yIcon=\"c8y-firmware\"\n  ></h1>\n  <h3 translate>\n    No firmwares to display.\n  </h3>\n  <p translate>\n    Add a new firmware by clicking below.\n  </p>\n  <p>\n    <button class=\"btn btn-primary\"\n      title=\"{{ 'Add firmware' | translate }}\"\n      (click)=\"addFirmware()\"\n      translate\n    >\n      Add firmware\n    </button>\n  </p>\n</div>\n\n<!-- no results empty state -->\n<div class=\"c8y-empty-state\"\n  *ngIf=\"(firmwares$ | async)?.data.length === 0 && (textFilter$ | async)?.length > 0\"\n  >\n  <h1 class=\"c8y-icon-duocolor\"\n    c8yIcon=\"search\"></h1>\n  <h3 translate>\n    No results to display.\n  </h3>\n  <p translate>\n    Refine your search terms or check your spelling.\n  </p>\n</div>\n\n<c8y-list-group class=\"m-b-24\"\n  *ngIf=\"(firmwares$ | async)?.data.length > 0\"\n  [ngClass]=\"{ 'dd-low': (firmwares$ | async)?.data.length < 10 }\"\n\n>\n  <c8y-li class=\"page-sticky-header c8y-list__item--empty-actions hidden-xs\">\n    <c8y-li-icon>\n      <i class=\"p-l-24\"></i>\n    </c8y-li-icon>\n    <c8y-li-body class=\"content-flex-60\">\n      <div class=\"col-3\">\n        {{'Firmware' | translate}}\n      </div>\n      <div class=\"col-4\">\n        {{'Description' | translate}}\n      </div>\n      <div class=\"col-3\">\n        {{'Device type' | translate}}\n      </div>\n      <div class=\"col-2\">\n        {{'Versions' | translate}}\n      </div>\n    </c8y-li-body>\n  </c8y-li>\n\n  <c8y-li *c8yFor=\"let firmware of firmwares$ | async; let i = index; loadMore: 'auto'\">\n    <c8y-li-icon icon=\"c8y-firmware\"></c8y-li-icon>\n    <c8y-li-body class=\"content-flex-60\">\n      <button class=\"btn-clean col-3\"\n        (click)=\"editFirmware(firmware)\"\n      >\n        <span class=\"text-truncate\"\n          title=\"{{ firmware.name }}\"\n        >\n          <c8y-highlight\n            [text]=\"firmware.name || '-'\"\n            elementClass=\"text-info\"\n            [pattern]=\"textFilter$ | async\"\n          ></c8y-highlight>\n        </span>\n      </button>\n      <div class=\"col-4\">\n        <p class=\"text-truncate\"\n          title=\"{{ firmware.description }}\"\n        >\n          <span class=\"text-label-small m-r-4 visible-xs-inline\">\n            {{'Description' | translate }}\n          </span>\n          <span *ngIf=\"firmware.description; else emptyDescription\">\n            <c8y-highlight\n              [text]=\"firmware.description || '-'\"\n              elementClass=\"text-info\"\n              [pattern]=\"textFilter$ | async\"\n            ></c8y-highlight>\n          </span>\n        </p>\n        <ng-template #emptyDescription>\n          <small class=\"text-muted\">\n            <em>{{ 'No description' | translate }}</em>\n          </small>\n        </ng-template>\n      </div>\n      <div class=\"col-3\">\n        <div class=\"text-truncate\">\n          <span class=\"text-label-small m-r-4 visible-xs-inline\" translate>\n            Device type\n          </span>\n          <span\n            *ngIf=\"firmware.c8y_Filter?.type; else emptyText\"\n            title=\"{{ firmware.c8y_Filter?.type }}\"\n          >\n            <c8y-highlight\n              [text]=\"firmware.c8y_Filter?.type || '-'\"\n              elementClass=\"text-info\"\n              [pattern]=\"textFilter$ | async\"\n            ></c8y-highlight>\n          </span>\n          <ng-template #emptyText>\n            <small class=\"text-muted\">\n              <em>{{ 'Undefined' | translate }}</em>\n            </small>\n          </ng-template>\n        </div>\n      </div>\n      <div class=\"col-2\">\n        <span class=\"label label-warning flex-item-right-sm\"\n          *ngIf=\"isLegacy(firmware)\"\n          >\n          <span translate>\n            Legacy\n          </span>\n        </span>\n\n        <span *ngIf=\"!isLegacy(firmware)\">\n          <span *ngIf=\"(getBaseVersionsCount$(firmware) | async) === null\">\n            <span class=\"label label-info flex-item-right-sm\">\n              <i c8yIcon=\"circle-o-notch\" class=\"icon-spin\"></i>\n            </span>\n          </span>\n          <span *ngIf=\"(getBaseVersionsCount$(firmware) | async) !== null\">\n            <span [ngPlural]=\"getBaseVersionsCount$(firmware) | async\">\n              <ng-template ngPluralCase=\"=0\">\n                <span class=\"label label-default flex-item-right-sm\">\n                  <span translate>\n                    No versions\n                  </span>\n                </span>\n              </ng-template>\n              <ng-template ngPluralCase=\"=1\">\n                <span class=\"label label-info flex-item-right-sm\">\n                  <span translate>\n                    1 version\n                  </span>\n                </span>\n              </ng-template>\n              <ng-template ngPluralCase=\"other\">\n                <span class=\"label label-info flex-item-right-sm\">\n                  <span\n                    ngNonBindable\n                    translate\n                    [translateParams]=\"{ count: getBaseVersionsCount$(firmware) | async }\"\n                  >\n                    {{ count }} versions\n                  </span>\n                </span>\n              </ng-template>\n            </span>\n          </span>\n        </span>\n      </div>\n    </c8y-li-body>\n\n    <c8y-li-action\n      (click)=\"editFirmware(firmware)\"\n      icon=\"pencil\"\n    >\n      {{ 'Edit' | translate }}\n    </c8y-li-action>\n\n    <c8y-li-action\n      (click)=\"deleteFirmware(firmware)\"\n      icon=\"trash\"\n    >\n      {{ 'Delete' | translate }}\n    </c8y-li-action>\n  </c8y-li>\n</c8y-list-group>\n"
            },] }
];
FirmwareListComponent.ctorParameters = () => [
    { type: RepositoryService },
    { type: ModalService },
    { type: BsModalService },
    { type: TranslateService },
    { type: AlertService },
    { type: Router },
    { type: ActivatedRoute }
];
__decorate([
    memoize(property('id'))
], FirmwareListComponent.prototype, "getBaseVersionsCount$", null);

class RepositoryNavigationFactory {
    constructor() {
        this.navs = [];
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.navs.length === 0) {
                this.navs.push(new NavigatorNode({
                    label: gettext('Firmware repository'),
                    path: 'firmware',
                    icon: 'c8y-firmware',
                    parent: gettext('Management'),
                    priority: 1000
                }));
                this.navs.push(new NavigatorNode({
                    label: gettext('Software repository'),
                    path: 'software',
                    icon: 'c8y-tools',
                    parent: gettext('Management'),
                    priority: 900
                }));
                this.navs.push(new NavigatorNode({
                    label: gettext('Configuration repository'),
                    path: 'configuration',
                    icon: 'gears',
                    parent: gettext('Management'),
                    priority: 800
                }));
            }
            return this.navs;
        });
    }
}
RepositoryNavigationFactory.decorators = [
    { type: Injectable }
];

class AdvancedSoftwareService extends Service {
    constructor(client, applicationService) {
        super(client);
        this.applicationService = applicationService;
        this.baseUrl = 'service/advanced-software';
        this.listUrl = 'software';
        this.propertyName = 'softwareList';
    }
    list(filter = {}) {
        return super.list(filter);
    }
    isASMAvailable() {
        if (this.isAvailable === undefined) {
            this.isAvailable = this.applicationService
                .isAvailable(AdvancedSoftwareService.applicationName)
                .then(result => !!(result === null || result === void 0 ? void 0 : result.data));
        }
        return this.isAvailable;
    }
}
AdvancedSoftwareService.applicationName = 'advanced-software-mgmt';
AdvancedSoftwareService.decorators = [
    { type: Injectable }
];
AdvancedSoftwareService.ctorParameters = () => [
    { type: FetchClient },
    { type: ApplicationService }
];

class DeviceSoftwareChangesComponent {
    constructor() {
        this.clear = new EventEmitter();
        this.drop = new EventEmitter();
        this.apply = new EventEmitter();
        this.hideSoftwareChanges = new EventEmitter();
        this.changes$ = new BehaviorSubject([]);
        this.installations$ = this.changes$.pipe(map(changes => {
            return changes.filter(change => change.action === 'install');
        }));
        this.removals$ = this.changes$.pipe(map(changes => {
            return changes.filter(change => change.action === 'delete');
        }));
    }
    ngOnChanges(changes) {
        if (changes.changes) {
            this.changes$.next(changes.changes.currentValue);
        }
    }
}
DeviceSoftwareChangesComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-device-software-changes',
                template: "<div class=\"inner-scroll d-flex d-col\">\n  <div class=\"card-header separator sticky-top visible-sm visible-xs\">\n    <button\n      class=\"btn btn-clean text-primary\"\n      [title]=\"'Back' | translate\"\n      (click)=\"hideSoftwareChanges.emit()\"\n    >\n      <i c8yIcon=\"chevron-left\"></i><span translate>Back</span>\n    </button>\n  </div>\n  <div class=\"card-header separator large-padding sticky-top\">\n    <h4 class=\"card-title\" translate>Software changes</h4>\n  </div>\n  <div id=\"software-changes-list\" class=\"flex-grow inner-scroll\">\n    <div class=\"card-block large-padding\" *ngIf=\"(changes$ | async).length === 0; else changesList\">\n      <div class=\"c8y-empty-state text-center\">\n        <h1 class=\"c8y-icon c8y-icon-device-control c8y-icon-duocolor\"></h1>\n        <p>\n          <strong translate>No software changes.</strong> <br />\n          <small translate>Selected actions will be displayed here.</small>\n        </p>\n      </div>\n    </div>\n\n    <ng-template #changesList>\n      <fieldset\n        class=\"card-block p-t-0 p-b-0\"\n        *ngIf=\"(installations$ | async).length > 0\"\n        [disabled]=\"changesInProgress\"\n      >\n        <div class=\"form-block legend\" translate>Installations`software`</div>\n        <c8y-device-software-list\n          [softwareList]=\"installations$ | async\"\n          (remove)=\"drop.emit($event)\"\n        ></c8y-device-software-list>\n      </fieldset>\n\n      <fieldset\n        class=\"card-block p-t-0 p-b-0\"\n        *ngIf=\"(removals$ | async).length > 0\"\n        [disabled]=\"changesInProgress\"\n      >\n        <div class=\"form-block legend\" translate>Removals`software`</div>\n        <c8y-device-software-list\n          [softwareList]=\"removals$ | async\"\n          (remove)=\"drop.emit($event)\"\n        ></c8y-device-software-list>\n      </fieldset>\n    </ng-template>\n  </div>\n  <div\n    class=\"card-footer separator large-padding sticky-bottom\"\n    *ngIf=\"(changes$ | async).length > 0\"\n  >\n    <button\n      class=\"btn btn-default\"\n      (click)=\"clear.emit()\"\n      title=\"{{ 'Clear changes' | translate }}\"\n      [disabled]=\"changesInProgress\"\n      translate\n    >\n      Clear`changes`\n    </button>\n    <button\n      class=\"btn btn-primary\"\n      [ngClass]=\"{ 'btn-pending': changesInProgress }\"\n      [disabled]=\"changesInProgress\"\n      (click)=\"apply.emit(); hideSoftwareChanges.emit()\"\n      title=\"{{ 'Apply changes' | translate }}\"\n      translate\n    >\n      Apply changes\n    </button>\n  </div>\n</div>\n"
            },] }
];
DeviceSoftwareChangesComponent.propDecorators = {
    changes: [{ type: Input }],
    changesInProgress: [{ type: Input }],
    clear: [{ type: Output }],
    drop: [{ type: Output }],
    apply: [{ type: Output }],
    hideSoftwareChanges: [{ type: Output }]
};

class DeviceSoftwareListComponent {
    constructor(advancedSoftwareService) {
        this.advancedSoftwareService = advancedSoftwareService;
        this.filterCriteria$ = of(null);
        this.update = new EventEmitter();
        this.remove = new EventEmitter();
        this.onListEmpty = new EventEmitter();
        this.supportsSoftwareOperations = false;
        this.operationTypes = ['c8y_SoftwareUpdate', 'c8y_SoftwareList', 'c8y_Software'];
        this.legacySoftwareList$ = new BehaviorSubject([]);
    }
    set softwareList(softwareList) {
        if (softwareList !== null) {
            this.legacySoftwareList$.next(softwareList);
        }
    }
    ngOnInit() {
        this.softwareItems$ = combineLatest(this.filterCriteria$, this.legacySoftwareList$).pipe(debounceTime(300), distinctUntilChanged(), switchMap(([filterCriteria, legacySoftwareList]) => {
            if (legacySoftwareList) {
                return of(this.getLegacySoftwareList(filterCriteria)).pipe(map(resultList => ({ resultList, filterCriteria })));
            }
            else {
                return this.getAdvancedSoftwareList(filterCriteria).then(resultList => ({
                    resultList,
                    filterCriteria
                }));
            }
        }), tap(({ resultList, filterCriteria }) => {
            var _a, _b;
            this.notifyListEmpty(!((_a = resultList === null || resultList === void 0 ? void 0 : resultList.paging) === null || _a === void 0 ? void 0 : _a.totalPages) && !filterCriteria);
            this.noSearchResults = !((_b = resultList === null || resultList === void 0 ? void 0 : resultList.paging) === null || _b === void 0 ? void 0 : _b.totalPages) && !!filterCriteria;
        }), map(({ resultList }) => resultList));
        const supportedOperations = get(this.device, 'c8y_SupportedOperations', []);
        this.supportsSoftwareOperations = this.operationTypes.some(operationType => supportedOperations.indexOf(operationType) > -1);
    }
    ngAfterContentInit() {
        this.showUpdate = this.update.observers.length > 0;
        this.showRemove = this.remove.observers.length > 0;
    }
    isSoftwareGoingToBeChanged(software) {
        const relevantChanges = filter$1(this.deviceSoftwareChanges, software);
        return relevantChanges.length > 0;
    }
    getAdvancedSoftwareList(filterCriteria) {
        const queryFilter = { deviceId: this.device.id };
        if (filterCriteria === null || filterCriteria === void 0 ? void 0 : filterCriteria.name) {
            set(queryFilter, 'name', `*${filterCriteria.name}*`);
        }
        if (filterCriteria === null || filterCriteria === void 0 ? void 0 : filterCriteria.softwareType) {
            set(queryFilter, 'type', `${filterCriteria.softwareType}`);
        }
        return this.advancedSoftwareService.list(queryFilter);
    }
    getLegacySoftwareList(filterCriteria) {
        const data = filterCriteria
            ? this.legacySoftwareList$.value.filter(item => {
                var _a;
                let match = true;
                if (filterCriteria === null || filterCriteria === void 0 ? void 0 : filterCriteria.name) {
                    match = match && ((_a = item.name) === null || _a === void 0 ? void 0 : _a.includes(filterCriteria.name));
                }
                if (filterCriteria === null || filterCriteria === void 0 ? void 0 : filterCriteria.softwareType) {
                    match = match && item.softwareType === filterCriteria.softwareType;
                }
                return match;
            })
            : this.legacySoftwareList$.value;
        return {
            data,
            res: null,
            paging: {
                totalPages: data.length
            }
        };
    }
    notifyListEmpty(isEmpty) {
        this.emptyList = isEmpty;
        this.onListEmpty.emit(isEmpty);
    }
}
DeviceSoftwareListComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-device-software-list',
                template: "<c8y-list-group class=\"no-border-last\">\n  <c8y-li\n    [ngClass]=\"{ disabled: isSoftwareGoingToBeChanged(software) }\"\n    *c8yFor=\"let software of softwareItems$\"\n  >\n    <!-- SOFTWARE ICON -->\n    <c8y-li-icon>\n      <i c8yIcon=\"c8y-tools\"></i>\n    </c8y-li-icon>\n\n    <c8y-li-body class=\"content-flex-20\">\n      <div title=\"{{ software.name }}\" class=\"col-8\">\n        <!-- SOFTWARE NAME -->\n        <p class=\"text-truncate\">\n          {{ software.name }}\n          <!-- SOFTWARE TYPE-->\n          <span class=\"label label-primary m-l-8\">{{ software.softwareType }}</span>\n        </p>\n        <!-- SOFTWARE VERSION -->\n        <p class=\"text-truncate\">\n          <span class=\"text-label-small m-r-4\" translate> Version </span>\n          <span title=\"{{ software.version }}\">\n            {{ software.version }}\n          </span>\n        </p>\n      </div>\n\n      <div\n        *ngIf=\"supportsSoftwareOperations && (showUpdate || showRemove)\"\n        class=\"col-4 text-right\"\n      >\n        <!-- UPDATE SOFTWARE -->\n        <button\n          *ngIf=\"showUpdate && !isSoftwareGoingToBeChanged(software)\"\n          class=\"btn btn-default btn-xs showOnHover\"\n          (click)=\"update.emit(software)\"\n          title=\"{{ 'Update`software,verb`' | translate }}\"\n          translate\n        >\n          Update\n        </button>\n\n        <!-- REMOVE SOFTWARE -->\n        <button\n          *ngIf=\"showRemove && !isSoftwareGoingToBeChanged(software)\"\n          title=\"{{ 'Remove`software`' | translate }}\"\n          class=\"showOnHover btn btn-dot pull-right\"\n          (click)=\"remove.emit(software)\"\n        >\n          <i c8yIcon=\"minus-circle\" class=\"text-danger\"></i>\n        </button>\n      </div>\n    </c8y-li-body>\n  </c8y-li>\n</c8y-list-group>\n<!-- NO SEARCH RESULTS STATE -->\n<div class=\"card-block\" *ngIf=\"noSearchResults || emptyList\">\n  <ng-content *ngIf=\"emptyList\" select=\".c8y-empty-state:not(.c8y-no-results-state)\"></ng-content>\n  <ng-content *ngIf=\"noSearchResults\" select=\".c8y-no-results-state\"></ng-content>\n</div>\n"
            },] }
];
DeviceSoftwareListComponent.ctorParameters = () => [
    { type: AdvancedSoftwareService }
];
DeviceSoftwareListComponent.propDecorators = {
    softwareList: [{ type: Input }],
    device: [{ type: Input }],
    deviceSoftwareChanges: [{ type: Input }],
    filterCriteria$: [{ type: Input }],
    update: [{ type: Output }],
    remove: [{ type: Output }],
    onListEmpty: [{ type: Output }]
};

class InstalledSoftwareComponent {
    constructor(repository, bsModal) {
        this.repository = repository;
        this.bsModal = bsModal;
        this.changes = new EventEmitter();
        this.showSoftwareChanges = new EventEmitter();
        this.showFilter = false;
        this.supportsSoftwareOperations = false;
        this.textFilter$ = new BehaviorSubject('');
        this.softwareTypeFilter$ = new BehaviorSubject('');
        this.operationTypes = ['c8y_SoftwareUpdate', 'c8y_SoftwareList', 'c8y_Software'];
        this.filterCriteria$ = combineLatest(this.textFilter$, this.softwareTypeFilter$).pipe(map(([textFilter, softwareTypeFilter]) => ({
            name: textFilter,
            softwareType: softwareTypeFilter
        })), map(filterCriteria => !filterCriteria.name && !filterCriteria.softwareType ? null : filterCriteria));
    }
    ngOnInit() {
        const supportedOperations = get(this.device, 'c8y_SupportedOperations', []);
        this.supportsSoftwareOperations = this.operationTypes.some(operationType => supportedOperations.indexOf(operationType) > -1);
    }
    installSoftware() {
        this.displaySoftwareSelectModal({
            title: gettext('Install software'),
            labels: { ok: gettext('Install') },
            repositoryEntriesWithVersions$: of([]),
            repositoryEntriesWithVersionsFn$: modal => this.getInstallableSoftwareListWithVersions$(modal.content.searchTerm)
        }).subscribe(softwareToInstall => {
            this.emitSoftwareInstall(softwareToInstall);
            this.showSoftwareChanges.emit();
        });
    }
    updateSoftware(softwareToRemove) {
        this.displaySoftwareSelectModal({
            title: gettext('Update software'),
            labels: { ok: gettext('Update') },
            showFilter: false,
            repositoryEntriesWithVersions$: this.getSingleSoftwareWithVersions$(softwareToRemove)
        }).subscribe(softwareToInstall => {
            this.emitSoftwareInstall(softwareToInstall);
            this.showSoftwareChanges.emit();
        });
    }
    removeSoftware(softwareToRemove) {
        this.emitSoftwareRemoval([softwareToRemove]);
    }
    getInstallableSoftwareListWithVersions$(searchTerm$) {
        const installedSoftwareNames = (this.softwareList || []).map(s => s.name);
        return searchTerm$.pipe(distinctUntilChanged(), switchMap(searchTerm => this.repository.listRepositoryEntries(RepositoryType.SOFTWARE, {
            query: this.deviceTypeQuery,
            partialName: searchTerm,
            params: { pageSize: 100 }
        })), map(({ data }) => data), map(softwareList => {
            return softwareList.filter(software => {
                return !installedSoftwareNames.includes(software.name);
            });
        }), map(softwareList => this.attachVersions(softwareList)), shareReplay(1));
    }
    getSingleSoftwareWithVersions$(software) {
        return from(this.repository.listRepositoryEntries(RepositoryType.SOFTWARE, {
            query: { name: software.name }
        })).pipe(map(({ data }) => data), map(softwareList => this.attachVersions(softwareList)), shareReplay(1));
    }
    attachVersions(softwareList) {
        softwareList.forEach(software => {
            software.versions = this.repository.listBaseVersions(software);
        });
        return softwareList;
    }
    displaySoftwareSelectModal(initialStateOverrides) {
        const initialState = Object.assign({ repositoryType: RepositoryType.SOFTWARE, subTitle: gettext('Available softwares matching the device type'), mode: ModalSelectionMode.MULTI, icon: 'c8y-tools', disableSelected: false, selected: this.softwareList }, initialStateOverrides);
        const modal = this.bsModal.show(RepositorySelectModalComponent, {
            ignoreBackdropClick: true,
            class: 'modal-sm',
            initialState
        });
        if (initialStateOverrides.repositoryEntriesWithVersionsFn$) {
            modal.content.repositoryEntriesWithVersions$ =
                initialStateOverrides.repositoryEntriesWithVersionsFn$(modal);
        }
        modal.content.load.next();
        return modal.content.resultEmitter;
    }
    emitSoftwareInstall(items) {
        this.changes.emit(items.map(item => {
            return Object.assign(Object.assign({}, item), { action: 'install' });
        }));
    }
    emitSoftwareRemoval(items) {
        this.changes.emit(items.map(item => {
            return Object.assign(Object.assign({}, item), { action: 'delete' });
        }));
    }
}
InstalledSoftwareComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-installed-software',
                template: "<div class=\"d-flex d-col flex-grow\">\n  <div class=\"card-header large-padding separator sticky-top\">\n    <h4 class=\"card-title\" translate>Installed software</h4>\n  </div>\n  <div class=\"flex-grow\">\n    <fieldset\n      id=\"operation-block\"\n      *ngIf=\"deviceSoftwareChangesOperation\"\n      class=\"card-block large-padding bg-gray-lighter\"\n    >\n      <c8y-single-operation [operation]=\"deviceSoftwareChangesOperation\"></c8y-single-operation>\n    </fieldset>\n    <fieldset class=\"card-block large-padding overflow-visible\" *ngIf=\"showFilter\">\n      <div class=\"row\">\n        <div class=\"col-xs-6\">\n          <div class=\"input-group input-group-search\">\n            <input\n              class=\"form-control\"\n              type=\"search\"\n              title=\"{{ 'Filter installed software\u2026' | translate }}\"\n              placeholder=\"{{ 'Filter installed software\u2026' | translate }}\"\n              [ngModel]=\"textFilter$ | async\"\n              (ngModelChange)=\"textFilter$.next($event)\"\n            />\n            <span class=\"input-group-addon\">\n              <i c8yIcon=\"search\" *ngIf=\"(textFilter$ | async).length === 0\"></i>\n              <i\n                class=\"text-muted\"\n                c8yIcon=\"times\"\n                *ngIf=\"(textFilter$ | async).length > 0\"\n                (click)=\"textFilter$.next('')\"\n              ></i>\n            </span>\n          </div>\n        </div>\n        <div class=\"col-xs-6\">\n          <c8y-software-type\n            [required]=\"false\"\n            [emitResultsOnly]=\"true\"\n            [showBtnInNotFoundMessage]=\"false\"\n            [allowFreeEntries]=\"false\"\n            [placeholder]=\"'Filter by software type\u2026' | translate\"\n            (onSelectSoftware)=\"softwareTypeFilter$.next($event?.softwareType)\"\n          ></c8y-software-type>\n        </div>\n      </div>\n    </fieldset>\n\n    <fieldset\n      id=\"software-list\"\n      class=\"flex-grow inner-scroll\"\n      [disabled]=\"deviceSoftwareChangesInProgress\"\n    >\n      <!-- NOT EMPTY STATE -->\n      <c8y-device-software-list\n        [device]=\"device\"\n        [filterCriteria$]=\"filterCriteria$\"\n        [softwareList]=\"softwareList\"\n        [deviceSoftwareChanges]=\"deviceSoftwareChanges\"\n        (update)=\"updateSoftware($event)\"\n        (remove)=\"removeSoftware($event)\"\n        (onListEmpty)=\"showFilter = !$event\"\n        class=\"d-block p-l-16 p-r-16\"\n      >\n        <!-- EMPTY STATE -->\n        <div class=\"c8y-empty-state text-center m-t-16\">\n          <h1 class=\"c8y-icon c8y-icon-tools c8y-icon-duocolor\"></h1>\n          <p>\n            <strong translate>No software installed.</strong> <br />\n            <small translate>Click below to install software into this device.</small>\n          </p>\n        </div>\n        <!-- NO SEARCH RESULTS STATE -->\n        <div class=\"c8y-empty-state c8y-no-results-state text-center m-t-16\">\n          <h1 class=\"c8y-icon c8y-icon-tools c8y-icon-duocolor\"></h1>\n          <p>\n            <strong translate>No software matches your filter criteria.</strong> <br />\n            <small translate>Try changing your search criteria.</small>\n          </p>\n        </div>\n      </c8y-device-software-list>\n    </fieldset>\n  </div>\n  <!-- INSTALL SOFTWARE-->\n  <div\n    class=\"card-footer large-padding separator sticky-bottom d-flex j-c-between\"\n    [ngClass]=\"{ 'visible-sm visible-xs': !supportsSoftwareOperations }\"\n  >\n    <button\n      *ngIf=\"supportsSoftwareOperations\"\n      class=\"btn btn-default\"\n      title=\"{{ 'Install software' | translate }}\"\n      (click)=\"installSoftware()\"\n      [disabled]=\"deviceSoftwareChangesInProgress\"\n    >\n      <i c8yIcon=\"plus-circle\"></i>\n      {{ 'Install software' | translate }}\n    </button>\n    <button\n      (click)=\"showSoftwareChanges.emit()\"\n      class=\"btn btn-clean text-primary visible-sm visible-xs\"\n      [title]=\"'Show &quot;Software changes&quot;' | translate\"\n    >\n      <span translate>Show \"Software changes\"</span>\n      <i c8yIcon=\"chevron-right\"></i>\n    </button>\n  </div>\n</div>\n"
            },] }
];
InstalledSoftwareComponent.ctorParameters = () => [
    { type: RepositoryService },
    { type: BsModalService }
];
InstalledSoftwareComponent.propDecorators = {
    device: [{ type: Input }],
    softwareList: [{ type: Input }],
    deviceSoftwareChanges: [{ type: Input }],
    deviceSoftwareChangesOperation: [{ type: Input }],
    deviceSoftwareChangesInProgress: [{ type: Input }],
    deviceTypeQuery: [{ type: Input }],
    changes: [{ type: Output }],
    showSoftwareChanges: [{ type: Output }]
};

class SoftwareDeviceTabComponent {
    constructor(route, repository, inventory, advancedSoftwareService) {
        this.route = route;
        this.repository = repository;
        this.inventory = inventory;
        this.advancedSoftwareService = advancedSoftwareService;
        this.deviceId = this.route.snapshot.parent.data.contextData.id;
        this.device$ = new BehaviorSubject(this.route.snapshot.parent.data.contextData);
        this.deviceTypeQuery$ = this.device$.pipe(map(device => this.repository.getDeviceTypeQuery(RepositoryType.SOFTWARE, device)));
        this.list$ = this.device$.pipe(switchMap(device => this.advancedSoftwareService
            .isASMAvailable()
            .then(isASMAvailable => ({ isASMAvailable, device }))), map(({ isASMAvailable, device }) => 
        // with ASM available software items will be retrieved directly in the
        // device-software-list component
        isASMAvailable ? undefined : this.repository.getDeviceSoftwareList(device)));
        this.changes$ = new BehaviorSubject([]);
        this.changesOperation$ = new BehaviorSubject(null);
        this.changesInProgress$ = this.changesOperation$.pipe(map(operation => this.isInProgress(operation)));
        this.reloading = false;
        this.showSoftwareChanges = false;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadDevice();
            yield this.loadOperation();
        });
    }
    addChanges(requestedChanges) {
        let stagedChanges = [...this.changes$.value];
        requestedChanges.forEach(requestedChange => {
            const alreadyStaged = stagedChanges.some(stagedChange => this.areSameChanges(stagedChange, requestedChange));
            if (!alreadyStaged) {
                stagedChanges = [...stagedChanges, requestedChange];
            }
        });
        this.changes$.next(stagedChanges);
    }
    dropChange(changeToBeDropped) {
        let stagedChanges = [...this.changes$.value];
        stagedChanges = stagedChanges.filter(stagedChange => !this.areSameChanges(stagedChange, changeToBeDropped));
        this.changes$.next(stagedChanges);
    }
    areSameChanges(change1, change2) {
        return change1.name === change2.name &&
            change1.version === change2.version &&
            change1.action === change2.action;
    }
    clearChanges() {
        this.changes$.next([]);
    }
    loadDevice() {
        return __awaiter(this, void 0, void 0, function* () {
            this.reloading = true;
            const device = (yield this.inventory.detail(this.deviceId, { withChildren: false })).data;
            this.device$.next(device);
            this.reloading = false;
        });
    }
    applyChanges() {
        return __awaiter(this, void 0, void 0, function* () {
            const operation = yield this.repository.createSoftwareUpdateOperation(this.device$.value, this.changes$.value);
            this.trackOperation(operation);
        });
    }
    loadOperation() {
        return __awaiter(this, void 0, void 0, function* () {
            const operation = yield this.repository.getLastSoftwareUpdateOperation(this.deviceId);
            this.trackOperation(operation);
        });
    }
    trackOperation(operation) {
        this.changesOperation$.next(operation);
        if (this.isInProgress(operation)) {
            this.displayChangesFromOperation(operation);
            this.repository.observeOperation(operation).subscribe(operationUpdate => {
                this.changesOperation$.next(operationUpdate);
                if (operationUpdate.status === OperationStatus.SUCCESSFUL) {
                    this.clearChanges();
                    this.loadDevice();
                }
            }, operationUpdate => {
                this.changesOperation$.next(operationUpdate);
            });
        }
    }
    displayChangesFromOperation(operation) {
        const changes = this.repository.getDeviceSoftwareChangesFromOperation(operation, this.device$.value);
        this.changes$.next(changes);
    }
    isInProgress(operation) {
        return (operation && [OperationStatus.PENDING, OperationStatus.EXECUTING].includes(operation.status));
    }
}
SoftwareDeviceTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-software-device-tab',
                template: "<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\" title=\"{{ 'Reload' | translate }}\" (click)=\"loadDevice()\">\n    <i c8yIcon=\"refresh\" [ngClass]=\"{ 'icon-spin': reloading }\"></i>\n    {{ 'Reload' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<div class=\"card split-view--8-4 m-b-0\">\n  <c8y-installed-software\n    class=\"split-view__list\"\n    [device]=\"device$ | async\"\n    [deviceTypeQuery]=\"deviceTypeQuery$ | async\"\n    [softwareList]=\"list$ | async\"\n    [deviceSoftwareChanges]=\"changes$ | async\"\n    [deviceSoftwareChangesOperation]=\"changesOperation$ | async\"\n    [deviceSoftwareChangesInProgress]=\"changesInProgress$ | async\"\n    (changes)=\"addChanges($event)\"\n    (showSoftwareChanges)=\"showSoftwareChanges = true\"\n  ></c8y-installed-software>\n  <c8y-device-software-changes\n    class=\"bg-gray-white split-view__detail\"\n    [ngClass]=\"{ 'split-view__detail--selected': showSoftwareChanges }\"\n    [changes]=\"changes$ | async\"\n    [changesInProgress]=\"changesInProgress$ | async\"\n    (clear)=\"clearChanges()\"\n    (drop)=\"dropChange($event)\"\n    (apply)=\"applyChanges()\"\n    (hideSoftwareChanges)=\"showSoftwareChanges = false\"\n  ></c8y-device-software-changes>\n</div>\n"
            },] }
];
SoftwareDeviceTabComponent.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: RepositoryService },
    { type: InventoryService },
    { type: AdvancedSoftwareService }
];

class SoftwareDeviceTabGuard {
    constructor() {
        this.operations = ['c8y_SoftwareUpdate', 'c8y_SoftwareList', 'c8y_Software'];
    }
    canActivate(route) {
        const device = get(route, 'data.contextData') || get(route, 'parent.data.contextData');
        return (this.isAnyOperationSupported(device) ||
            has(device, 'c8y_Software') ||
            has(device, 'c8y_SoftwareList') ||
            has(device, 'c8y_SupportedSoftwareTypes'));
    }
    isAnyOperationSupported(device) {
        const supportedOperations = (device === null || device === void 0 ? void 0 : device.c8y_SupportedOperations) || [];
        return this.operations.some(operation => supportedOperations.indexOf(operation) >= 0);
    }
}
SoftwareDeviceTabGuard.decorators = [
    { type: Injectable }
];

class AddSoftwareModalComponent {
    constructor(modal, repositoryService, alert) {
        this.modal = modal;
        this.repositoryService = repositoryService;
        this.alert = alert;
        this.saved = new EventEmitter();
        this.onInput = new BehaviorSubject('');
        this.model = {
            selected: undefined,
            version: undefined,
            description: undefined,
            deviceType: undefined,
            softwareType: undefined,
            binary: {
                file: undefined,
                url: undefined
            }
        };
        this.saving = false;
        this.softwarePreselected = false;
        this.textForSoftwareUrlPopover = gettext(`Path for binaries can vary depending on device agent implementation, e.g.:
    /software/binaries/software1.bin
    https://software/binary/123
    ftp://software/binary/123.tar.gz
  `);
    }
    ngOnInit() {
        this.setInitialState();
        this.loadSoftwares();
    }
    setInitialState() {
        if (this.model.selected) {
            this.softwarePreselected = true;
        }
    }
    loadSoftwares() {
        this.inputSubscription$ = this.onInput
            .pipe(tap(() => {
            if (!this.softwarePreselected) {
                this.model.description = null;
                if (this.form) {
                    this.form.form.get('description').reset();
                }
            }
        }), debounceTime(300), distinctUntilChanged(), switchMap(searchStr => this.getSoftwareResult(searchStr)))
            .subscribe(result => {
            this.softwaresResult = result;
        });
    }
    getSoftwareResult(searchStr) {
        return from(this.repositoryService.listRepositoryEntries(RepositoryType.SOFTWARE, {
            partialName: searchStr,
            skipLegacy: true
        }));
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            this.saving = true;
            this.repositoryService
                .create(this.model, RepositoryType.SOFTWARE)
                .then(savedSoftware => {
                this.successMsg();
                this.saving = false;
                this.saved.next(savedSoftware);
                this.cancel();
            })
                .catch(e => {
                this.saving = false;
                this.saved.error(e);
                this.cancel();
            });
        });
    }
    successMsg() {
        const msg = gettext('Software added.');
        this.alert.success(msg);
    }
    cancel() {
        this.modal.hide();
        this.saved.complete();
    }
    ngOnDestroy() {
        this.inputSubscription$.unsubscribe();
    }
    onFile(dropped) {
        if (!isUndefined(dropped.url)) {
            this.model.binary = {
                url: dropped.url
            };
            return;
        }
        else if (!isUndefined(dropped.droppedFiles)) {
            this.model.binary = {
                file: dropped.droppedFiles[0].file
            };
            return;
        }
        else {
            this.model.binary = {
                file: undefined,
                url: undefined
            };
        }
    }
    onSoftwareSelect(software) {
        assign(this.model, {
            selected: software,
            description: software.description,
            deviceType: get(software, 'c8y_Filter.type'),
            softwareType: software
        });
    }
}
AddSoftwareModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-add-software-software-modal',
                template: "<div class=\"viewport-modal\">\n  <div class=\"modal-header dialog-header\">\n    <i [c8yIcon]=\"'c8y-tools'\"></i>\n    <h4 translate>Add software</h4>\n  </div>\n  <div class=\"p-16 text-center separator-bottom\" *ngIf=\"!softwarePreselected\">\n    <p class=\"lead m-0\" translate>Select or create new software</p>\n  </div>\n  <form\n    class=\"d-contents\"\n    autocomplete=\"off\"\n    #softwareForm=\"ngForm\"\n    (ngSubmit)=\"softwareForm.form.valid && save()\"\n  >\n    <div class=\"modal-inner-scroll\">\n      <div class=\"modal-body\">\n        <div [hidden]=\"softwarePreselected\">\n          <c8y-form-group>\n            <label for=\"softwareName\" translate>Software</label>\n            <c8y-typeahead\n              [(ngModel)]=\"model.selected\"\n              name=\"softwareName\"\n              placeholder=\"{{ 'Select or enter' | translate }}\"\n              (onSearch)=\"onInput.next($event)\"\n              [required]=\"true\"\n            >\n              <c8y-li\n                *c8yFor=\"\n                  let software of softwaresResult;\n                  loadMore: 'auto';\n                  notFound: notFoundTemplate\n                \"\n                class=\"p-l-8 p-r-8 c8y-list__item--link\"\n                (click)=\"onSoftwareSelect(software)\"\n                [active]=\"model.selected === software\"\n              >\n                <c8y-highlight\n                  [text]=\"software.name || '--'\"\n                  [pattern]=\"onInput | async\"\n                ></c8y-highlight>\n              </c8y-li>\n              <ng-template #notFoundTemplate>\n                <c8y-li class=\"bg-gray-lighter p-8\" *ngIf=\"(onInput | async)?.length > 0\">\n                  <span translate>No match found.</span>\n                  <button\n                    title=\"{{ 'Add new`software`' | translate }}\"\n                    type=\"button\"\n                    class=\"btn btn-primary btn-xs m-l-16\"\n                    translate\n                  >\n                    Add new`software`\n                  </button>\n                </c8y-li>\n              </ng-template>\n            </c8y-typeahead>\n          </c8y-form-group>\n\n          <c8y-form-group>\n            <label for=\"softwareDescription\" translate>Description</label>\n            <input\n              id=\"softwareDescription\"\n              class=\"form-control\"\n              autocomplete=\"off\"\n              name=\"description\"\n              [(ngModel)]=\"model.description\"\n              placeholder=\"{{ 'e.g. Cloud connectivity software' | translate }}\"\n              [disabled]=\"model.selected?.id\"\n              [required]=\"true\"\n            />\n          </c8y-form-group>\n\n          <c8y-form-group>\n            <label class=\"control-label\" for=\"softwareDeviceTypeFilter\">\n              {{ 'Device type filter' | translate }}\n              <button\n                class=\"btn btn-clean text-primary\"\n                popover=\"{{\n                  'If the filter is set, the software will show up for installation only for devices of that type. If no filter is set, it will be available for all devices.'\n                    | translate\n                }}\"\n                triggers=\"focus\"\n                container=\"body\"\n                placement=\"right\"\n              >\n                <i [c8yIcon]=\"'question-circle-o'\"></i>\n              </button>\n            </label>\n            <input\n              id=\"softwareDeviceTypeFilter\"\n              class=\"form-control\"\n              name=\"softwareDeviceTypeFilter\"\n              [(ngModel)]=\"model.deviceType\"\n              placeholder=\"{{ 'e.g.' | translate }} c8y_Linux\"\n              [disabled]=\"model.selected?.id\"\n            />\n          </c8y-form-group>\n\n          <c8y-form-group>\n            <label for=\"softwareType\" translate>Software type</label>\n            <c8y-software-type\n              [softwareTypeMO]=\"model.softwareType\"\n              [disabled]=\"model.selected?.id\"\n              (onSelectSoftware)=\"model.softwareType = $event\"\n            >\n            </c8y-software-type>\n          </c8y-form-group>\n        </div>\n\n        <c8y-form-group>\n          <label for=\"softwareVersion\" translate>Version</label>\n          <input\n            id=\"softwareVersion\"\n            class=\"form-control\"\n            autocomplete=\"off\"\n            name=\"version\"\n            [(ngModel)]=\"model.version\"\n            placeholder=\"{{ 'e.g.' | translate }} 1.0.0\"\n            [required]=\"true\"\n          />\n        </c8y-form-group>\n\n        <c8y-form-group>\n          <div class=\"legend form-block m-t-40\" translate>Software file</div>\n          <c8y-file-picker\n            [maxAllowedFiles]=\"1\"\n            (onFilesPicked)=\"onFile($event)\"\n            [fileUrlPopover]=\"textForSoftwareUrlPopover\"\n          >\n          </c8y-file-picker>\n        </c8y-form-group>\n      </div>\n    </div>\n    <div class=\"modal-footer\">\n      <button\n        title=\"{{ 'Cancel' | translate }}\"\n        class=\"btn btn-default\"\n        type=\"button\"\n        (click)=\"cancel()\"\n        [disabled]=\"saving\"\n        translate\n      >\n        Cancel\n      </button>\n\n      <button\n        title=\"{{ 'Add software' | translate }}\"\n        class=\"btn btn-primary\"\n        type=\"submit\"\n        [ngClass]=\"{ 'btn-pending': saving }\"\n        [disabled]=\"\n          !softwareForm.form.valid ||\n          softwareForm.form.pristine ||\n          saving ||\n          (!model.binary?.url && !model.binary?.file)\n        \"\n        translate\n      >\n        Add software\n      </button>\n    </div>\n  </form>\n</div>\n"
            },] }
];
AddSoftwareModalComponent.ctorParameters = () => [
    { type: BsModalRef },
    { type: RepositoryService },
    { type: AlertService }
];
AddSoftwareModalComponent.propDecorators = {
    form: [{ type: ViewChild, args: ['softwareForm', { static: false },] }],
    saved: [{ type: Output }]
};

class DeviceTypeCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
}
DeviceTypeCellRendererComponent.decorators = [
    { type: Component, args: [{
                template: "<span *ngIf=\"context.item.c8y_Filter?.type; else emptyText\">\n  {{ context.item.c8y_Filter?.type }}\n</span>\n<ng-template #emptyText>\n  <small class=\"text-muted\">\n    <em translate>Undefined`device type`</em>\n  </small>\n</ng-template>\n"
            },] }
];
DeviceTypeCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext }
];

class NameCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
}
NameCellRendererComponent.decorators = [
    { type: Component, args: [{
                template: `
    <a [routerLink]="[context.item.id]" [title]="context.item.name" class="interact">
      {{ context.item.name }}
    </a>
  `
            },] }
];
NameCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext }
];

class SoftwareTypeCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
}
SoftwareTypeCellRendererComponent.decorators = [
    { type: Component, args: [{
                template: "<span *ngIf=\"!!context?.item?.softwareType; else emptyText\" class=\"label label-info\">{{\n  context.item.softwareType\n}}</span>\n<ng-template #emptyText>\n  <small class=\"text-muted\">\n    <em translate>Undefined`software type`</em>\n  </small> </ng-template\n>`\n"
            },] }
];
SoftwareTypeCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext }
];

class SoftwareTypeFilteringFormRendererComponent {
    constructor(context, changeDetectorRef, repositoryService, elementRef) {
        this.context = context;
        this.changeDetectorRef = changeDetectorRef;
        this.repositoryService = repositoryService;
        this.elementRef = elementRef;
        this.softwareWithType$ = NEVER;
        this.search$ = new BehaviorSubject(null);
        this.filterPipe = pipe(tap());
        this.typeaheadPlaceholder = gettext('Start typing to search, e.g. {{ example }}');
        this.queriesUtil = new QueriesUtil();
        this.softwareTypes = new Set();
        this.softwareWithType$ = this.search$.pipe(debounceTime(300), tap(() => this.softwareTypes.clear()), switchMap((searchString) => {
            let query = this.queriesUtil.prependOrderbys({}, [{ softwareType: 1 }]);
            const filter = !!searchString
                ? {
                    softwareType: {
                        __eq: `*${searchString}*`
                    }
                }
                : {
                    __has: 'softwareType'
                };
            query = this.queriesUtil.addAndFilter(query, filter);
            return this.repositoryService.listRepositoryEntries(RepositoryType.SOFTWARE, {
                skipDefaultOrder: true,
                query,
                params: {
                    pageSize: 200
                }
            });
        }));
        this.filterPipe = pipe(map(this.removeDuplicatesBySoftwareType.bind(this)), tap(() => this.changeDetectorRef.detectChanges()));
    }
    onEnterKeyDown(event) {
        event.stopPropagation();
        this.applyFilter();
    }
    onEscapeKeyDown(event) {
        event.stopPropagation();
        this.context.resetFilter();
    }
    ngOnInit() {
        const column = this.context.property;
        this.selectedType = cloneDeep(column.externalFilterQuery || {});
    }
    ngAfterViewInit() {
        var _a, _b, _c;
        (_c = (_b = (_a = this.typeahead) === null || _a === void 0 ? void 0 : _a.searchControl) === null || _b === void 0 ? void 0 : _b.nativeElement) === null || _c === void 0 ? void 0 : _c.focus();
        try {
            this.elementRef.nativeElement.parentElement.parentElement.style.overflow = 'visible';
        }
        catch (ex) {
            // intentionally empty
        }
    }
    applyFilter() {
        this.context.applyFilter({
            externalFilterQuery: this.selectedType
        });
    }
    removeDuplicatesBySoftwareType(list) {
        const uniqueBySoftwareType = uniqBy(list, 'softwareType').filter((sw) => !this.softwareTypes.has(sw.softwareType));
        uniqueBySoftwareType.forEach((sw) => this.softwareTypes.add(sw.softwareType));
        return uniqueBySoftwareType;
    }
}
SoftwareTypeFilteringFormRendererComponent.decorators = [
    { type: Component, args: [{
                template: "<c8y-form-group>\n  <label translate>Filter by software type</label>\n  <c8y-typeahead\n    [(ngModel)]=\"selectedType\"\n    name=\"softwareType\"\n    placeholder=\"{{ typeaheadPlaceholder | translate: { example: 'yum' } }}\"\n    displayProperty=\"softwareType\"\n    (onSearch)=\"search$.next($event)\"\n  >\n    <c8y-li\n      *c8yFor=\"let software of softwareWithType$; pipe: filterPipe; loadMore: 'auto'\"\n      class=\"p-l-8 p-r-8 c8y-list__item--link\"\n      (click)=\"\n        selectedType = software; typeahead.dropdown.hide(); changeDetectorRef.detectChanges()\n      \"\n      [active]=\"selectedType?.softwareType === software?.softwareType\"\n    >\n      <c8y-highlight\n        [text]=\"software?.softwareType || '--'\"\n        [pattern]=\"search$.value\"\n      ></c8y-highlight>\n    </c8y-li>\n  </c8y-typeahead>\n</c8y-form-group>\n\n<div class=\"data-grid__dropdown__footer d-flex separator-top\">\n  <button\n    class=\"btn btn-default btn-sm m-r-8 flex-grow\"\n    (click)=\"context.resetFilter()\"\n    title=\"{{ 'Reset' | translate }}\"\n    translate\n  >\n    Reset\n  </button>\n\n  <button\n    class=\"btn btn-primary btn-sm flex-grow\"\n    (click)=\"applyFilter()\"\n    title=\"{{ 'Apply' | translate }}\"\n    translate\n  >\n    Apply\n  </button>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.Default
            },] }
];
SoftwareTypeFilteringFormRendererComponent.ctorParameters = () => [
    { type: FilteringFormRendererContext },
    { type: ChangeDetectorRef },
    { type: RepositoryService },
    { type: ElementRef }
];
SoftwareTypeFilteringFormRendererComponent.propDecorators = {
    typeahead: [{ type: ViewChild, args: [TypeaheadComponent, { static: false },] }],
    onEnterKeyDown: [{ type: HostListener, args: ['keydown.enter', ['$event'],] }],
    onEscapeKeyDown: [{ type: HostListener, args: ['keydown.escape', ['$event'],] }]
};

class VersionsCellRendererComponent {
    constructor(context, repositoryService) {
        this.context = context;
        this.repositoryService = repositoryService;
        this.isLegacy = this.repositoryService.isLegacyEntry.bind(this.repositoryService);
        this.software = context.item;
    }
    getBaseVersionsCount$(software) {
        return this.repositoryService.getBaseVersionsCount$(software).pipe(shareReplay(1));
    }
}
VersionsCellRendererComponent.decorators = [
    { type: Component, args: [{
                template: "<span class=\"label label-warning flex-item-right-sm\" *ngIf=\"isLegacy(software)\">\n  <span translate> Legacy </span>\n</span>\n<span *ngIf=\"!isLegacy(software)\">\n  <span *ngIf=\"(getBaseVersionsCount$(software) | async) === null\">\n    <span class=\"badge badge-info flex-item-right-sm\">\n      <i class=\"icon-spin\" c8yIcon=\"circle-o-notch\"></i>\n    </span>\n  </span>\n  <span *ngIf=\"(getBaseVersionsCount$(software) | async) !== null\">\n    <span class=\"badge badge-info flex-item-right-sm\">\n      {{ getBaseVersionsCount$(software) | async }}\n    </span>\n  </span>\n</span>\n"
            },] }
];
VersionsCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: RepositoryService }
];
__decorate([
    memoize(property('id'))
], VersionsCellRendererComponent.prototype, "getBaseVersionsCount$", null);

class SoftwareTypeComponent {
    constructor(repositoryService, changeDetectorRef, translateService) {
        this.repositoryService = repositoryService;
        this.changeDetectorRef = changeDetectorRef;
        this.translateService = translateService;
        this.required = true;
        this.placeholder = this.translateService.instant(gettext('e.g. {{ example }}'), { example: 'yum' });
        this.emitResultsOnly = false;
        this.showBtnInNotFoundMessage = true;
        this.allowFreeEntries = true;
        this.onSelectSoftware = new EventEmitter();
        this.filterPipe = pipe(tap());
        this.search$ = new BehaviorSubject(null);
        this.queriesUtil = new QueriesUtil();
        this.softwareTypes = new Set();
        this.softwaresResult$ = this.search$.pipe(debounceTime(300), tap(() => this.softwareTypes.clear()), switchMap((searchString) => {
            if (!this.emitResultsOnly || !searchString) {
                this.onSelectSoftware.emit(this.softwareTypeMO);
            }
            return this.getSoftwareByTypeResult(searchString);
        }));
        this.filterPipe = pipe(map(this.removeDuplicatesBySoftwareType.bind(this)));
    }
    ngOnInit() {
        this.notFoundTemplateToUse = this.showBtnInNotFoundMessage
            ? this.notFoundTypeAddNewTemplate
            : this.notFoundTypeTemplate;
    }
    getSoftwareByTypeResult(searchString) {
        let query = this.queriesUtil.prependOrderbys({}, [{ softwareType: 1 }]);
        const filter = !!searchString
            ? {
                softwareType: {
                    __eq: `*${searchString}*`
                }
            }
            : {
                __has: 'softwareType'
            };
        query = this.queriesUtil.addAndFilter(query, filter);
        return this.repositoryService.listRepositoryEntries(RepositoryType.SOFTWARE, {
            query,
            params: {
                pageSize: 200
            }
        });
    }
    selectSoftware(software) {
        this.softwareTypeMO = software;
        this.onSelectSoftware.emit(software);
        this.deviceSoftwareTypeModel.searchControlModel.control.markAsDirty();
    }
    resetInput() {
        this.deviceSoftwareTypeModel.reset();
    }
    removeDuplicatesBySoftwareType(list) {
        const uniqueBySoftwareType = uniqBy(list, 'softwareType').filter((sw) => !this.softwareTypes.has(sw.softwareType));
        uniqueBySoftwareType.forEach((sw) => this.softwareTypes.add(sw.softwareType));
        return uniqueBySoftwareType;
    }
}
SoftwareTypeComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-software-type',
                template: "<c8y-typeahead\n  [(ngModel)]=\"softwareTypeMO\"\n  [required]=\"required\"\n  [disabled]=\"disabled\"\n  name=\"softwareType\"\n  [placeholder]=\"placeholder\"\n  [allowFreeEntries]=\"allowFreeEntries\"\n  #deviceSoftwareTypeModel\n  (onSearch)=\"search$.next($event)\"\n  displayProperty=\"softwareType\"\n  [ngStyle]=\"style\"\n>\n  <c8y-li\n    *c8yFor=\"\n      let software of softwaresResult$;\n      pipe: filterPipe;\n      loadMore: 'auto';\n      notFound: notFoundTemplateToUse\n    \"\n    class=\"p-l-8 p-r-8 c8y-list__item--link\"\n    (click)=\"selectSoftware(software)\"\n    [active]=\"softwareTypeMO?.softwareType === software.softwareType\"\n  >\n    <c8y-highlight\n      [text]=\"software.softwareType || '--'\"\n      [pattern]=\"search$ | async\"\n    ></c8y-highlight>\n  </c8y-li>\n  <ng-template #notFoundTypeAddNewTemplate>\n    <c8y-li class=\"bg-gray-lighter p-8\" *ngIf=\"(search$ | async)?.length > 0\">\n      <span translate>No match found.</span>\n      <button\n        title=\"{{ 'Add new`software type`' | translate }}\"\n        type=\"button\"\n        class=\"btn btn-primary btn-xs m-l-16\"\n        translate\n      >\n        Add new`software type`\n      </button>\n    </c8y-li>\n  </ng-template>\n  <ng-template #notFoundTypeTemplate>\n    <c8y-li\n      class=\"bg-gray-lighter p-8\"\n      *ngIf=\"(search$ | async)?.length > 0 && (softwaresResult$ | async)?.data?.length === 0\"\n    >\n      <span translate>No match found. Refine your search terms or check your spelling.</span>\n    </c8y-li>\n  </ng-template>\n</c8y-typeahead>\n"
            },] }
];
SoftwareTypeComponent.ctorParameters = () => [
    { type: RepositoryService },
    { type: ChangeDetectorRef },
    { type: TranslateService }
];
SoftwareTypeComponent.propDecorators = {
    softwareTypeMO: [{ type: Input }],
    disabled: [{ type: Input }],
    style: [{ type: Input }],
    required: [{ type: Input }],
    placeholder: [{ type: Input }],
    emitResultsOnly: [{ type: Input }],
    showBtnInNotFoundMessage: [{ type: Input }],
    allowFreeEntries: [{ type: Input }],
    deviceSoftwareTypeModel: [{ type: ViewChild, args: ['deviceSoftwareTypeModel',] }],
    notFoundTypeAddNewTemplate: [{ type: ViewChild, args: ['notFoundTypeAddNewTemplate', { static: true },] }],
    notFoundTypeTemplate: [{ type: ViewChild, args: ['notFoundTypeTemplate', { static: true },] }],
    onSelectSoftware: [{ type: Output }]
};

class SoftwareDetailsComponent {
    constructor(activatedRoute, inventoryService, repositoryService, alertService, translateService, modalService, bsModalService) {
        this.activatedRoute = activatedRoute;
        this.inventoryService = inventoryService;
        this.repositoryService = repositoryService;
        this.alertService = alertService;
        this.translateService = translateService;
        this.modalService = modalService;
        this.bsModalService = bsModalService;
        this.reload$ = new Subject();
        this.reloading$ = new BehaviorSubject(false);
        this.isSoftwareTypeChanged = false;
        this.updateSoftware$ = new Subject();
        this.softwareUpdated$ = new Subject();
        this.baseVersionsUpdated$ = new Subject();
        this.software$ = merge(this.activatedRoute.params.pipe(map(params => params.id), switchMap(id => from(this.inventoryService.detail(id).then(result => result.data)))), this.reload$.pipe(tap(() => this.reloading$.next(true)), switchMap(() => this.activatedRoute.params), map(params => params.id), switchMap(id => from(this.inventoryService.detail(id).then(result => result.data))), tap(() => this.reloading$.next(false))), this.softwareUpdated$).pipe(shareReplay(1));
        this.baseVersions$ = merge(this.software$.pipe(distinctUntilKeyChanged('id')), this.baseVersionsUpdated$, this.reload$).pipe(switchMap(() => this.software$), switchMap(software => this.repositoryService.listBaseVersions(software)), shareReplay(1));
        this.isLegacy$ = this.software$.pipe(map(software => this.repositoryService.isLegacyEntry(software)), shareReplay(1));
        this.destroy$ = new Subject();
    }
    ngOnInit() {
        this.updateSoftware$
            .pipe(withLatestFrom(this.software$), switchMap(([softwarePartial, software]) => this.inventoryService.update(Object.assign({ id: software.id }, softwarePartial))), map(({ data }) => data), tap(software => this.softwareUpdated$.next(software)), tap(() => this.alertService.success(gettext('Saved.'))), takeUntil(this.destroy$))
            .subscribe();
        this.software$.subscribe(software => {
            this.softwareTypeObject = software;
        });
    }
    getBinaryName$(binaryUrl) {
        return this.repositoryService.getBinaryName$(binaryUrl);
    }
    addBaseVersion() {
        this.software$
            .pipe(take(1), switchMap(software => {
            const initialState = {
                model: {
                    selected: software,
                    description: software.description
                }
            };
            const config = {
                class: 'modal-sm',
                ignoreBackdropClick: true,
                initialState
            };
            const modalRef = this.bsModalService.show(AddSoftwareModalComponent, config);
            return modalRef.content.saved;
        }))
            .subscribe(() => this.baseVersionsUpdated$.next());
    }
    deleteBaseVersion(baseVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const title = gettext('Delete software');
                const body = `
        ${this.translateService.instant(gettext('You are about to delete software {{ version }}.'), { version: baseVersion.c8y_Software.version })}
        ${this.translateService.instant(gettext('This operation is irreversible.'))}
        ${this.translateService.instant(gettext('Do you want to proceed?'))}
      `;
                const labels = {
                    ok: gettext('Delete')
                };
                yield this.modalService.confirm(title, body, Status.DANGER, labels);
                yield this.repositoryService.delete(baseVersion);
                this.alertService.success(gettext('Software deleted.'));
                this.baseVersionsUpdated$.next();
            }
            catch (ex) {
                // only if not cancel from modal
                if (ex) {
                    this.alertService.addServerFailure(ex);
                }
            }
        });
    }
    onSelectSoftwareType(software) {
        var _a;
        this.isSoftwareTypeChanged = !(((_a = this.softwareTypeObject) === null || _a === void 0 ? void 0 : _a.softwareType) === (software === null || software === void 0 ? void 0 : software.softwareType));
        this.softwareTypeObject = software;
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.unsubscribe();
    }
}
SoftwareDetailsComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-software-details',
                template: "<c8y-title>\n  {{ (software$ | async)?.name }}\n</c8y-title>\n\n<c8y-breadcrumb>\n  <c8y-breadcrumb-item\n    path=\"#/software\"\n    label=\"{{ 'Software repository' | translate }}\"\n    icon=\"c8y-tools\"\n  >\n  </c8y-breadcrumb-item>\n</c8y-breadcrumb>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button\n    *ngIf=\"!(isLegacy$ | async)\"\n    class=\"btn btn-link\"\n    title=\"{{ 'Add software' | translate }}\"\n    (click)=\"addBaseVersion()\"\n  >\n    <i c8yIcon=\"plus-circle\"></i>\n    {{ 'Add software' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\" title=\"{{ 'Reload' | translate }}\" (click)=\"reload$.next()\">\n    <i c8yIcon=\"refresh\" [ngClass]=\"{ 'icon-spin': reloading$ | async }\"></i>\n    {{ 'Reload' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<div class=\"row\">\n  <div class=\"col-lg-12 col-lg-max\">\n    <div class=\"card m-b-4\">\n      <div class=\"card-header separator\">\n        <h4 class=\"card-title\" translate>Software info</h4>\n      </div>\n      <div class=\"card-block overflow-visible\">\n        <div class=\"row\">\n          <div class=\"col-sm-6\">\n            <c8y-form-group>\n              <label class=\"control-label\">\n                {{ 'Name' | translate }}\n              </label>\n              <div class=\"input-group input-group-editable\">\n                <input\n                  #nameInput\n                  type=\"text\"\n                  class=\"form-control\"\n                  [ngModel]=\"(software$ | async)?.name\"\n                  #nameModel=\"ngModel\"\n                  placeholder=\"{{ 'e.g. My software' | translate }}\"\n                  [ngStyle]=\"{ 'width.ch': (software$ | async)?.name?.length + 2 || 31 }\"\n                  required\n                />\n                <span></span>\n                <div class=\"input-group-btn\">\n                  <button\n                    class=\"btn btn-primary\"\n                    title=\"{{ 'Save' | translate }}\"\n                    (click)=\"updateSoftware$.next({ name: nameInput.value }); nameModel.reset()\"\n                    [disabled]=\"nameInput.value.length === 0\"\n                  >\n                    {{ 'Save' | translate }}\n                  </button>\n                </div>\n              </div>\n            </c8y-form-group>\n          </div>\n          <div class=\"col-sm-6\">\n            <c8y-form-group>\n              <label class=\"control-label\">\n                {{ 'Description' | translate }}\n              </label>\n              <div class=\"input-group input-group-editable\">\n                <input\n                  #descriptionInput\n                  type=\"text\"\n                  class=\"form-control\"\n                  [ngModel]=\"(software$ | async)?.description\"\n                  #descriptionModel=\"ngModel\"\n                  placeholder=\"{{ 'e.g. Cloud connectivity software' | translate }}\"\n                  [ngStyle]=\"{ 'width.ch': (software$ | async)?.description?.length + 2 || 31 }\"\n                />\n                <span></span>\n                <div class=\"input-group-btn\">\n                  <button\n                    class=\"btn btn-primary\"\n                    title=\"{{ 'Save' | translate }}\"\n                    (click)=\"\n                      updateSoftware$.next({ description: descriptionInput.value });\n                      descriptionModel.reset()\n                    \"\n                  >\n                    {{ 'Save' | translate }}\n                  </button>\n                </div>\n              </div>\n            </c8y-form-group>\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"col-sm-6\">\n            <c8y-form-group>\n              <label class=\"control-label\">\n                {{ 'Device type' | translate }}\n                <button\n                  class=\"btn-clean\"\n                  popover=\"{{\n                    'If the filter is set, the software will show up for installation only for devices of that type. If no filter is set, it will be available for all devices.'\n                      | translate\n                  }}\"\n                  [outsideClick]=\"true\"\n                  container=\"body\"\n                >\n                  <i c8yIcon=\"question-circle-o\" class=\"text-info\"></i>\n                </button>\n              </label>\n              <div class=\"input-group input-group-editable\">\n                <input\n                  #deviceTypeInput\n                  type=\"text\"\n                  class=\"form-control\"\n                  [ngModel]=\"(software$ | async)?.c8y_Filter?.type\"\n                  #deviceTypeModel=\"ngModel\"\n                  placeholder=\"{{ 'e.g.' | translate }} c8y_Linux\"\n                  [ngStyle]=\"{ 'width.ch': (software$ | async)?.type?.length + 2 || 31 }\"\n                />\n                <span></span>\n                <div class=\"input-group-btn\">\n                  <button\n                    class=\"btn btn-primary\"\n                    title=\"{{ 'Save' | translate }}\"\n                    (click)=\"\n                      updateSoftware$.next({ c8y_Filter: { type: deviceTypeInput.value } });\n                      deviceTypeModel.reset()\n                    \"\n                  >\n                    {{ 'Save' | translate }}\n                  </button>\n                </div>\n              </div>\n            </c8y-form-group>\n          </div>\n          <div class=\"col-sm-6\">\n            <c8y-form-group>\n              <label class=\"control-label\">\n                {{ 'Software type' | translate }}\n              </label>\n              <div class=\"input-group input-group-editable\">\n                <c8y-software-type\n                  [softwareTypeMO]=\"softwareTypeObject\"\n                  [style]=\"{ 'width.ch': softwareTypeObject?.softwareType?.length + 2 || 31 }\"\n                  (onSelectSoftware)=\"onSelectSoftwareType($event)\"\n                >\n                </c8y-software-type>\n                <div class=\"input-group-btn\">\n                  <button\n                    class=\"btn btn-primary\"\n                    [ngClass]=\"isSoftwareTypeChanged ? '' : 'hidden'\"\n                    title=\"{{ 'Save' | translate }}\"\n                    [disabled]=\"softwareTypeObject?.softwareType === ''\"\n                    (click)=\"\n                      updateSoftware$.next({ softwareType: softwareTypeObject.softwareType });\n                      softwareType.resetInput();\n                      isSoftwareTypeChanged = false\n                    \"\n                  >\n                    {{ 'Save' | translate }}\n                  </button>\n                </div>\n              </div>\n            </c8y-form-group>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class=\"row\">\n  <div class=\"col-lg-12 col-lg-max\">\n    <div class=\"card\">\n      <div class=\"card-header separator\">\n        <h4 class=\"card-title\" translate>Versions</h4>\n      </div>\n\n      <div class=\"card-block p-t-0 p-b-24\">\n        <div *ngIf=\"(baseVersions$ | async)?.data.length === 0\">\n          <div class=\"c8y-empty-state text-center\">\n            <h1 c8yIcon=\"c8y-tools\" class=\"c8y-icon-duocolor\"></h1>\n            <h3 translate>No versions to display.</h3>\n            <p translate>Add a new version by clicking below.</p>\n            <p>\n              <button\n                class=\"btn btn-primary\"\n                title=\"{{ 'Add software' | translate }}\"\n                (click)=\"addBaseVersion()\"\n              >\n                {{ 'Add software' | translate }}\n              </button>\n            </p>\n          </div>\n        </div>\n\n        <c8y-list-group\n          [ngClass]=\"{ 'dd-low': (baseVersions$ | async)?.data.length < 10 }\"\n          *ngIf=\"(baseVersions$ | async)?.data.length > 0\"\n        >\n          <c8y-li\n            *c8yFor=\"let baseVersion of baseVersions$ | async; let i = index; loadMore: 'auto'\"\n          >\n            <c8y-li-icon>\n              <i c8yIcon=\"c8y-tools\"></i>\n            </c8y-li-icon>\n\n            <c8y-li-body class=\"content-flex-50\">\n              <div class=\"col-4\">\n                <p class=\"text-truncate-wrap\" title=\"{{ baseVersion.c8y_Software.version }}\">\n                  {{ baseVersion.c8y_Software.version }}\n                </p>\n              </div>\n              <div class=\"col-5\">\n                <p class=\"text-truncate-wrap\">\n                  <span class=\"text-label-small m-r-8\" translate> File </span>\n                  <span title=\" {{ getBinaryName$(baseVersion.c8y_Software.url) | async }}\">\n                    <c8y-file-download url=\"{{ baseVersion.c8y_Software.url }}\"></c8y-file-download>\n                  </span>\n                </p>\n              </div>\n              <div class=\"col-2 flex-row a-i-start\">\n                <span *ngIf=\"isLegacy$ | async\" class=\"label label-warning flex-item-right-sm\">\n                  {{ 'Legacy' | translate }}\n                </span>\n\n                <div class=\"fit-h-20\" *ngIf=\"!(isLegacy$ | async)\">\n                  <button\n                    class=\"btn btn-danger btn-xs visible-xs flex-item-right m-r-8 m-t-8\"\n                    (click)=\"deleteBaseVersion(baseVersion)\"\n                    title=\"{{ 'Delete' | translate }}\"\n                  >\n                    <i c8yIcon=\"minus-circle\"></i>\n                    {{ 'Delete' | translate }}\n                  </button>\n                </div>\n              </div>\n              <div *ngIf=\"!(isLegacy$ | async)\" class=\"flex-item-right fit-h-20 p-r-8 hidden-xs\">\n                <button\n                  class=\"btn btn-dot text-danger showOnHover\"\n                  (click)=\"deleteBaseVersion(baseVersion)\"\n                  title=\"{{ 'Delete' | translate }}\"\n                >\n                  <i c8yIcon=\"minus-circle\"></i>\n                </button>\n              </div>\n            </c8y-li-body>\n          </c8y-li>\n        </c8y-list-group>\n      </div>\n    </div>\n  </div>\n</div>\n"
            },] }
];
SoftwareDetailsComponent.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: InventoryService },
    { type: RepositoryService },
    { type: AlertService },
    { type: TranslateService },
    { type: ModalService },
    { type: BsModalService }
];
SoftwareDetailsComponent.propDecorators = {
    softwareType: [{ type: ViewChild, args: [SoftwareTypeComponent, { static: true },] }]
};
__decorate([
    memoize()
], SoftwareDetailsComponent.prototype, "getBinaryName$", null);

class DescriptionGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'description';
        this.path = 'description';
        this.header = gettext('Description');
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    descriptions: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    type: 'template',
                    template: this.getLabelTemplate(gettext('Filter software by description'), {
                        showWildcardTooltip: true
                    })
                },
                {
                    key: 'descriptions',
                    notitle: true,
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'descriptions[]',
                            notitle: true,
                            placeholder: gettext('e.g. Cloud connectivity')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.descriptions.length) {
                    filter.description = { __in: model.descriptions };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

class DeviceTypeGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'deviceType';
        this.path = 'c8yFilter.type';
        this.header = gettext('Device type');
        this.cellRendererComponent = DeviceTypeCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    types: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    type: 'template',
                    template: this.getLabelTemplate(gettext('Filter software by device type'), {
                        showWildcardTooltip: true
                    })
                },
                {
                    key: 'types',
                    notitle: true,
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'types[]',
                            notitle: true,
                            placeholder: gettext('e.g. c8y_Linux')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.types.length) {
                    filter['c8y_Filter.type'] = { __in: model.types };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

class SoftwareNameGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'name';
        this.path = 'name';
        this.header = gettext('Name');
        this.cellRendererComponent = NameCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    names: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    type: 'template',
                    template: this.getLabelTemplate(gettext('Filter software by name'), {
                        showWildcardTooltip: true
                    })
                },
                {
                    key: 'names',
                    notitle: true,
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'names[]',
                            notitle: true,
                            placeholder: gettext('e.g. Cloud connectivity')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.names.length) {
                    filter.name = { __in: model.names };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

class SoftwareTypeGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'type';
        this.path = 'softwareType';
        this.header = gettext('Software type');
        this.cellRendererComponent = SoftwareTypeCellRendererComponent;
        this.filterable = true;
        this.filteringFormRendererComponent = SoftwareTypeFilteringFormRendererComponent;
        this.filteringConfig = {
            getFilter(model) {
                const filter = {};
                if (model.softwareType) {
                    filter.softwareType = { __eq: model.softwareType };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

class VersionsGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'versions';
        this.header = gettext('Versions');
        this.cellRendererComponent = VersionsCellRendererComponent;
        this.sortable = false;
    }
}

class SoftwareListComponent {
    constructor(repositoryService, gridService, modalService, bsModalService, translateService, alertService, router, activatedRoute) {
        this.repositoryService = repositoryService;
        this.gridService = gridService;
        this.modalService = modalService;
        this.bsModalService = bsModalService;
        this.translateService = translateService;
        this.alertService = alertService;
        this.router = router;
        this.activatedRoute = activatedRoute;
        this.sizeRequestDone = false;
        this.refresh$ = new EventEmitter();
        this.columns = [
            new SoftwareNameGridColumn(),
            new DescriptionGridColumn(),
            new DeviceTypeGridColumn(),
            new SoftwareTypeGridColumn(),
            new VersionsGridColumn()
        ];
        this.actionControls = [];
        this.pagination = {
            pageSize: 50,
            currentPage: 1
        };
        this.serverSideDataCallback = this.onDataSourceModifier.bind(this);
        this.sizeRequest = this.repositoryService
            .listRepositoryEntries(RepositoryType.SOFTWARE, {
            skipDefaultOrder: true,
            params: { pageSize: 1 }
        })
            .then(response => {
            var _a;
            this.sizeRequestDone = true;
            return (_a = response === null || response === void 0 ? void 0 : response.paging) === null || _a === void 0 ? void 0 : _a.totalPages;
        });
    }
    ngOnInit() {
        this.actionControls.push({
            type: "EDIT" /* Edit */,
            callback: this.editSoftware.bind(this)
        });
        this.actionControls.push({
            type: "DELETE" /* Delete */,
            callback: this.deleteSoftware.bind(this)
        });
    }
    onDataSourceModifier(dataSourceModifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let serverSideDataResult;
            const dataRequest = this.repositoryService.listRepositoryEntries(RepositoryType.SOFTWARE, {
                query: this.gridService.getQueryObj(dataSourceModifier.columns),
                skipDefaultOrder: true,
                params: {
                    pageSize: dataSourceModifier.pagination.pageSize,
                    currentPage: dataSourceModifier.pagination.currentPage
                }
            });
            const filtererdSizeRequest = this.repositoryService
                .listRepositoryEntries(RepositoryType.SOFTWARE, {
                skipDefaultOrder: true,
                query: this.gridService.getQueryObj(dataSourceModifier.columns),
                params: { pageSize: 1 }
            })
                .then(response => { var _a; return (_a = response === null || response === void 0 ? void 0 : response.paging) === null || _a === void 0 ? void 0 : _a.totalPages; });
            const [dataResponse, size, filteredSize] = yield Promise.all([
                dataRequest,
                this.sizeRequest,
                filtererdSizeRequest
            ]);
            const { res, data, paging } = dataResponse;
            serverSideDataResult = {
                res,
                data,
                paging,
                filteredSize,
                size
            };
            return serverSideDataResult;
        });
    }
    addSoftware() {
        const config = {
            class: 'modal-sm',
            ignoreBackdropClick: true
        };
        const modalRef = this.bsModalService.show(AddSoftwareModalComponent, config);
        modalRef.content.saved.subscribe(savedSoftware => this.editSoftware(savedSoftware));
    }
    editSoftware(software) {
        this.router.navigate([software.id], { relativeTo: this.activatedRoute });
    }
    deleteSoftware(software) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const title = gettext('Delete software');
                const body = `
        ${this.translateService.instant(gettext('You are about to delete software "{{ name }}" with all its versions.'), { name: software.name })}
        ${this.translateService.instant(gettext('This operation is irreversible.'))}
        ${this.translateService.instant(gettext('Do you want to proceed?'))}
      `;
                const labels = {
                    ok: gettext('Delete')
                };
                yield this.modalService.confirm(title, body, Status.DANGER, labels);
                yield this.repositoryService.delete(software);
                this.alertService.success(gettext('Software deleted.'));
                this.refresh$.next();
            }
            catch (ex) {
                // only if not cancel from modal
                if (ex) {
                    this.alertService.addServerFailure(ex);
                }
            }
        });
    }
    trackByName(_index, column) {
        return column.name;
    }
}
SoftwareListComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-software-list',
                template: "<c8y-title>\n  {{ 'Software repository' | translate }}\n</c8y-title>\n\n<c8y-action-bar-item [placement]=\"'right'\">\n  <button class=\"btn btn-link\" title=\"{{ 'Add software' | translate }}\" (click)=\"addSoftware()\">\n    <i c8yIcon=\"plus-circle\"></i>\n    {{ 'Add software' | translate }}\n  </button>\n</c8y-action-bar-item>\n\n<div class=\"content-fullpage\">\n  <c8y-data-grid\n    [title]=\"'Software' | translate\"\n    [refresh]=\"refresh$\"\n    [actionControls]=\"[]\"\n    [pagination]=\"pagination\"\n    [columns]=\"columns\"\n    [actionControls]=\"actionControls\"\n    [infiniteScroll]=\"'auto'\"\n    [serverSideDataCallback]=\"serverSideDataCallback\"\n  >\n    <div class=\"c8y-empty-state\">\n      <ng-container *ngIf=\"!sizeRequestDone\">\n        <c8y-loading></c8y-loading>\n      </ng-container>\n      <ng-container *ngIf=\"sizeRequestDone\">\n        <ng-container *ngIf=\"(sizeRequest | async) === 0; else noResults\">\n          <div class=\"text-center\">\n            <h1 class=\"c8y-icon-duocolor\" c8yIcon=\"c8y-tools\"></h1>\n            <h3 translate>No software to display.</h3>\n            <p translate>Add a new software by clicking below.</p>\n            <p>\n              <button\n                class=\"btn btn-primary\"\n                title=\"{{ 'Add software' | translate }}\"\n                (click)=\"addSoftware()\"\n                translate\n              >\n                Add software\n              </button>\n            </p>\n          </div>\n        </ng-container>\n        <ng-template #noResults>\n          <h1 c8yIcon=\"search\"></h1>\n          <div>\n            <p>\n              <strong>{{ 'No results to display.' | translate }}</strong>\n            </p>\n            <small>{{ 'Refine your search terms or check your spelling.' | translate }}</small>\n          </div>\n        </ng-template>\n      </ng-container>\n    </div>\n    <ng-container *ngFor=\"let column of columns; trackBy: trackByName\">\n      <c8y-column [name]=\"column.name\"></c8y-column>\n    </ng-container>\n  </c8y-data-grid>\n</div>\n"
            },] }
];
SoftwareListComponent.ctorParameters = () => [
    { type: RepositoryService },
    { type: DeviceGridService },
    { type: ModalService },
    { type: BsModalService },
    { type: TranslateService },
    { type: AlertService },
    { type: Router },
    { type: ActivatedRoute }
];

const ɵ0 = [
    {
        path: 'firmware',
        component: FirmwareListComponent
    },
    {
        path: 'firmware/:id',
        component: FirmwareDetailsComponent
    },
    {
        context: ViewContext.Device,
        path: 'firmware',
        component: FirmwareDeviceTabComponent,
        label: gettext('Firmware'),
        icon: 'c8y-firmware',
        priority: 500,
        canActivate: [FirmwareDeviceTabGuard]
    },
    {
        path: 'software',
        component: SoftwareListComponent
    },
    {
        path: 'software/:id',
        component: SoftwareDetailsComponent
    },
    {
        context: ViewContext.Device,
        path: 'software',
        component: SoftwareDeviceTabComponent,
        label: gettext('Software'),
        icon: 'c8y-tools',
        priority: 499,
        canActivate: [SoftwareDeviceTabGuard]
    },
    {
        path: 'configuration',
        component: ConfigurationListComponent
    },
    {
        context: ViewContext.Device,
        path: 'device-configuration',
        component: DeviceConfigurationComponent,
        label: gettext('Configuration'),
        icon: 'gears',
        priority: 600,
        canActivate: [DeviceConfigurationGuard]
    }
];
class RepositoryModule {
}
RepositoryModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule,
                    FormsModule,
                    RouterModule,
                    SingleOperationDetailsModule,
                    BsDropdownModule.forRoot(),
                    TooltipModule,
                    PopoverModule,
                    TabsModule.forRoot()
                ],
                exports: [SoftwareTypeComponent, FileDownloadComponent],
                declarations: [
                    FirmwareListComponent,
                    FirmwareDetailsComponent,
                    AddFirmwareModalComponent,
                    AddFirmwarePatchModalComponent,
                    SoftwareListComponent,
                    SoftwareDetailsComponent,
                    AddSoftwareModalComponent,
                    SoftwareTypeComponent,
                    FirmwareDeviceTabComponent,
                    SoftwareDeviceTabComponent,
                    InstalledSoftwareComponent,
                    RepositorySelectModalComponent,
                    DeviceSoftwareListComponent,
                    DeviceSoftwareChangesComponent,
                    ConfigurationListComponent,
                    ConfigurationDetailComponent,
                    DeviceConfigurationComponent,
                    DeviceConfigurationListComponent,
                    SourceCodePreviewComponent,
                    ConfigurationPreviewComponent,
                    ConfigurationFilterPipe,
                    SaveToRepositoryComponent,
                    TextBasedConfigurationComponent,
                    FileDownloadComponent,
                    NameCellRendererComponent,
                    SoftwareTypeCellRendererComponent,
                    SoftwareTypeFilteringFormRendererComponent,
                    DeviceTypeCellRendererComponent,
                    VersionsCellRendererComponent
                ],
                entryComponents: [
                    FirmwareListComponent,
                    FirmwareDetailsComponent,
                    AddFirmwareModalComponent,
                    AddFirmwarePatchModalComponent,
                    SoftwareListComponent,
                    SoftwareDetailsComponent,
                    AddSoftwareModalComponent,
                    FirmwareDeviceTabComponent,
                    SoftwareDeviceTabComponent,
                    DeviceSoftwareListComponent,
                    RepositorySelectModalComponent,
                    DeviceSoftwareChangesComponent,
                    ConfigurationListComponent,
                    ConfigurationDetailComponent,
                    DeviceConfigurationComponent,
                    SaveToRepositoryComponent,
                    TextBasedConfigurationComponent
                ],
                providers: [
                    RepositoryService,
                    OperationRealtimeService,
                    DeviceConfigurationService,
                    FirmwareDeviceTabGuard,
                    SoftwareDeviceTabGuard,
                    DeviceConfigurationGuard,
                    AdvancedSoftwareService,
                    {
                        provide: HOOK_NAVIGATOR_NODES,
                        useClass: RepositoryNavigationFactory,
                        multi: true
                    },
                    {
                        provide: HOOK_ROUTE,
                        useValue: ɵ0,
                        multi: true
                    }
                ]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { AddFirmwareModalComponent, AddFirmwarePatchModalComponent, AddSoftwareModalComponent, ConfigurationDetailComponent, ConfigurationFilterPipe, ConfigurationListComponent, ConfigurationPreviewComponent, DeviceConfigurationComponent, DeviceConfigurationGuard, DeviceConfigurationListComponent, DeviceConfigurationOperation, DeviceConfigurationService, DeviceSoftwareChangesComponent, DeviceSoftwareListComponent, FirmwareDetailsComponent, FirmwareDeviceTabComponent, FirmwareDeviceTabGuard, FirmwareListComponent, InstalledSoftwareComponent, REPOSITORY_BINARY_TYPES, RepositoryModule, RepositoryNavigationFactory, RepositorySelectModalComponent, RepositoryService, RepositoryType, SaveToRepositoryComponent, SoftwareDetailsComponent, SoftwareDeviceTabComponent, SoftwareDeviceTabGuard, SoftwareListComponent, SourceCodePreviewComponent, TextBasedConfigurationComponent, ɵ0, SoftwareTypeComponent as ɵa, FileDownloadComponent as ɵb, AdvancedSoftwareService as ɵc, NameCellRendererComponent as ɵd, SoftwareTypeCellRendererComponent as ɵe, SoftwareTypeFilteringFormRendererComponent as ɵf, DeviceTypeCellRendererComponent as ɵg, VersionsCellRendererComponent as ɵh };
//# sourceMappingURL=c8y-ngx-components-repository.js.map
