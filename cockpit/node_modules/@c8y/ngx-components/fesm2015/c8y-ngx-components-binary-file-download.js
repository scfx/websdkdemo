import { __awaiter } from 'tslib';
import { Injectable, NgModule } from '@angular/core';
import { NavigationEnd, Router, ActivatedRoute, RouterModule } from '@angular/router';
import { filter, map } from 'rxjs/operators';
import { InventoryService, InventoryBinaryService } from '@c8y/client';
import { gettext, Status, AlertService, ModalService, CommonModule } from '@c8y/ngx-components';
import { saveAs } from 'file-saver';
import { isUndefined } from 'lodash-es';
import { TranslateService } from '@ngx-translate/core';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/router';
import * as ɵngcc2 from '@c8y/client';
import * as ɵngcc3 from '@c8y/ngx-components';
import * as ɵngcc4 from '@ngx-translate/core';
class BinaryFileDownloadService {
    constructor(router, route, inventoryService, alertService, modalService, translate, inventoryBinary) {
        this.router = router;
        this.route = route;
        this.inventoryService = inventoryService;
        this.alertService = alertService;
        this.modalService = modalService;
        this.translate = translate;
        this.inventoryBinary = inventoryBinary;
    }
    run() {
        this.router.events
            .pipe(filter(event => {
            return event instanceof NavigationEnd && this.route.snapshot.queryParams.download;
        }), map(() => this.route.snapshot.queryParams.download))
            .subscribe((downloadId) => __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield this.inventoryService.detail(downloadId);
                if (!isUndefined(data.c8y_IsBinary)) {
                    this.showDownloadModal(data);
                }
                else {
                    const alertMessage = this.translate.instant(gettext('Could not download the file: object with ID "{{ id }}" is not a valid binary.'), { id: data.id });
                    this.alertService.danger(alertMessage);
                }
            }
            catch (ex) {
                this.alertService.addServerFailure(ex);
            }
        }));
    }
    showDownloadModal(binaryMo) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const modalBody = this.translate.instant(gettext('You are about to download file "{{ fileName }}". Do you want to proceed?'), { fileName: binaryMo.name });
                yield this.modalService.confirm(gettext('File download'), modalBody, Status.INFO, {
                    ok: gettext('Download')
                });
                const arrayBuffer = yield this.getArrayBuffer(binaryMo.id);
                const fileBinary = new File([arrayBuffer], binaryMo.name, { type: binaryMo.contentType });
                saveAs(fileBinary);
            }
            catch (e) {
                // empty body :(
                console.log({ e });
            }
        });
    }
    getArrayBuffer(binaryId) {
        return __awaiter(this, void 0, void 0, function* () {
            let arrayBuffer;
            try {
                const res = yield this.inventoryBinary.download(binaryId);
                arrayBuffer = yield res.arrayBuffer();
            }
            catch (ex) {
                const msg = gettext('Could not get the binary.');
                this.alertService.danger(msg);
            }
            return arrayBuffer;
        });
    }
}
BinaryFileDownloadService.ɵfac = function BinaryFileDownloadService_Factory(t) { return new (t || BinaryFileDownloadService)(ɵngcc0.ɵɵinject(ɵngcc1.Router), ɵngcc0.ɵɵinject(ɵngcc1.ActivatedRoute), ɵngcc0.ɵɵinject(ɵngcc2.InventoryService), ɵngcc0.ɵɵinject(ɵngcc3.AlertService), ɵngcc0.ɵɵinject(ɵngcc3.ModalService), ɵngcc0.ɵɵinject(ɵngcc4.TranslateService), ɵngcc0.ɵɵinject(ɵngcc2.InventoryBinaryService)); };
BinaryFileDownloadService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: BinaryFileDownloadService, factory: BinaryFileDownloadService.ɵfac });
BinaryFileDownloadService.ctorParameters = () => [
    { type: Router },
    { type: ActivatedRoute },
    { type: InventoryService },
    { type: AlertService },
    { type: ModalService },
    { type: TranslateService },
    { type: InventoryBinaryService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BinaryFileDownloadService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.Router }, { type: ɵngcc1.ActivatedRoute }, { type: ɵngcc2.InventoryService }, { type: ɵngcc3.AlertService }, { type: ɵngcc3.ModalService }, { type: ɵngcc4.TranslateService }, { type: ɵngcc2.InventoryBinaryService }]; }, null); })();

class BinaryFileDownloadModule {
    constructor(binaryFileDownloadService) {
        binaryFileDownloadService.run();
    }
}
BinaryFileDownloadModule.ɵfac = function BinaryFileDownloadModule_Factory(t) { return new (t || BinaryFileDownloadModule)(ɵngcc0.ɵɵinject(BinaryFileDownloadService)); };
BinaryFileDownloadModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: BinaryFileDownloadModule });
BinaryFileDownloadModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [BinaryFileDownloadService], imports: [[CommonModule, RouterModule]] });
BinaryFileDownloadModule.ctorParameters = () => [
    { type: BinaryFileDownloadService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BinaryFileDownloadModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, RouterModule],
                providers: [BinaryFileDownloadService]
            }]
    }], function () { return [{ type: BinaryFileDownloadService }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BinaryFileDownloadModule, { imports: function () { return [CommonModule, RouterModule]; } }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { BinaryFileDownloadModule, BinaryFileDownloadService };

//# sourceMappingURL=c8y-ngx-components-binary-file-download.js.map