import { TranslateDirective, TranslateService } from '@ngx-translate/core';
import { ChangeDetectorRef, ElementRef, EventEmitter } from '@angular/core';
export declare class C8yTranslateDirective extends TranslateDirective {
    /**
     * Used to get private element property from TranslateDirective, so it doesn't throw tsErrors
     */
    private get _elementRef();
    /**
     * Used to get private translateService property from TranslateDirective, so it doesn't throw tsErrors
     */
    private get _translateService();
    /**
     * Used to trigger events when html is replaced by directive.
     */
    htmlUpdateEvent: EventEmitter<void>;
    /**
     * When this directive successfully translates node, it stores its value in this property.
     * Another translation will be performed only if new translation value differs from stored one.
     */
    lastTranslation: string;
    /**
     * When this directive encounters element that is HTML, it should switch to Html mode even if
     * new translated element does not contain any HTML.
     */
    htmlMode: boolean;
    constructor(translateService: TranslateService, element: ElementRef, _ref: ChangeDetectorRef);
    /**
     * Overridden method from original directive.
     * For simple text nodes, it just invokes the base method.
     * For complex nodes, it builds translation key from whole inner HTML
     * and replaces it with its translation.
     * This prevents splitting HTML into pieces and attempting to translate each one separately
     * which doesn't work, because we extract strings in whole.
     */
    checkNodes(forceUpdate?: boolean, translations?: any): void;
    ngOnDestroy(): void;
    /**
     * Builds lookup key from innerHTML, removes comments (that might be added by Angular) and trims it.
     */
    private getLookupKey;
    private isElementSimpleTextType;
    private isElementInnerHtmlEmpty;
    private isLookupKeyMissing;
    private lookupKeyExist;
    private getNewTranslation;
    private updateHtmlContent;
}
