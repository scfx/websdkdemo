import { ActivatedRoute, Router } from '@angular/router';
import { Observable } from 'rxjs';
export declare function fromTrigger<T>(router: any, refresh: any, factories: any): Observable<T[]>;
export declare function fromTriggerOnce<T>(router: any, refresh: any, factories: any): Observable<T[]>;
export declare function fromFactories<T>(factories?: any, router?: Router, withFirstEmpty?: boolean): Observable<T[]>;
export declare function resolveInjectedFactories(factories: any): any;
export declare function stateToFactory<T>(componentsState: any): ExtensionFactory<T>;
export declare function sortByPriority(items: any): any;
export declare function toObservableOfArrays(factoryResult: any, withFirstEmpty: any): any;
export declare function isPromise<T = any>(obj: any): obj is Promise<T>;
/**
 * Converts any value provided to an Observable that emits this value once and then completes.
 * A convienience method to represent all the data as Observables rather than
 * a mixture of Observables and other types.
 *
 * @param value The value the resulting Observable will emit.
 */
export declare function toObservable<T>(value: T | Promise<T> | Observable<T>): Observable<T>;
/**
 * Allows to extend the existing applications from a module.
 */
export interface ExtensionFactory<T> {
    /**
     * Allows to resolve the data of an extension point.
     * The return value can be a Promise or Observable
     * (allowing for asynchronous data resolution).
     *
     * @param activatedRoute The current activated route (if possible to resolve).
     */
    get(activatedRoute?: ActivatedRoute): Observable<T[] | T> | Promise<T[] | T> | T[] | T;
}
/**
 * Extension points allow to extend the application from
 * any module
 */
export interface ExtensionPoint<T> {
    /**
     * Observable that emits of array of extensions active at any give time
     */
    readonly items$: Observable<T[]>;
    /**
     * Additional factories that can be added dynamically. (without hook)
     */
    factories: T[];
    /**
     * Call the extension factories to refresh them.
     */
    refresh(): any;
}
/**
 * Helper function to get the activated route in
 * a service (as ActivatedRoute injection only
 * works in components). Works as long as we only use
 * a tree and no child is active at the same time.
 *
 * @param router The current router
 */
export declare function getActivatedRoute(router: Router): ActivatedRoute;
