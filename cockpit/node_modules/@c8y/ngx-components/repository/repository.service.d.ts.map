{"version":3,"file":"repository.service.d.ts","sources":["repository.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { EventBinaryService, EventService, IdReference, IEvent, IFetchResponse, IIdentified, IManagedObject, IManagedObjectBinary, InventoryBinaryService, InventoryService, IOperation, IResult, IResultList, OperationService } from '@c8y/client';\nimport { AlertService, OperationRealtimeService } from '@c8y/ngx-components';\nimport { Observable } from 'rxjs';\nimport { ConfigurationSnapshot, DeviceFirmware, DeviceSoftware, DeviceSoftwareChange, FirmwareBinary, FirmwarePatchBinary, ModalModel, RepositoryBinary, RepositoryCategory, RepositoryType, SelectedRepositoryBinary, SoftwareBinary } from './repository.model';\nexport declare class RepositoryService {\n    private inventory;\n    private inventoryBinary;\n    private operation;\n    private alert;\n    private event;\n    private operationRealtime;\n    private eventBinary;\n    readonly dateFrom: Date;\n    readonly dateTo: Date;\n    private queriesUtil;\n    constructor(inventory: InventoryService, inventoryBinary: InventoryBinaryService, operation: OperationService, alert: AlertService, event: EventService, operationRealtime: OperationRealtimeService, eventBinary: EventBinaryService);\n    /**\n     * Lists repository entries of given type.\n     * @param type The type of repository entries to list.\n     * @param options Extra listing options.\n     */\n    listRepositoryEntries(type: RepositoryType, options?: {\n        /** Additional query. */\n        query?: any;\n        /** (deprecated - to be removed) Only include entries with matching partial names. */\n        partialName?: string;\n        /** Include entries with matching partial text in the specified properties. */\n        partialTextFilter?: {\n            partialText: string;\n            properties: string[];\n        };\n        /** Exclude legacy entries. */\n        skipLegacy?: boolean;\n        /** Exclude default ordering. */\n        skipDefaultOrder?: boolean;\n        /** Other request params. */\n        params?: any;\n    }): Promise<IResultList<IManagedObject>>;\n    save(data: ModalModel, type: RepositoryType, mo?: Partial<IManagedObject>): Promise<IResult<IManagedObject>>;\n    create(modal: ModalModel, type: RepositoryType): Promise<RepositoryCategory>;\n    createFirmwareOrSoftware(modal: ModalModel, type: RepositoryType): Promise<RepositoryCategory>;\n    saveBinary(file: File): Promise<IResult<IManagedObjectBinary>>;\n    createOrUpdateRepositoryEntry(modal: ModalModel, type: RepositoryType): Promise<IResult<RepositoryCategory>>;\n    createRepositoryBinary(modal: ModalModel, binaryURL: string, type: RepositoryType, parent: RepositoryCategory): Promise<IResult<FirmwareBinary | SoftwareBinary | FirmwarePatchBinary>>;\n    prepareRepositoryBinaryMO(modal: ModalModel, binaryURL: string, type: RepositoryType): {\n        [x: string]: string | {\n            url: string;\n        } | {\n            url?: undefined;\n        };\n        type: string;\n        c8y_Global: {};\n    };\n    linkBinary(repositoryBinary: FirmwareBinary | SoftwareBinary, binary: IManagedObjectBinary): Promise<IResult<IIdentified>>;\n    cleanUp(mosToDelete: IIdentified[]): void;\n    delete(entity: IIdentified): Promise<IResult<null>>;\n    errorMsg(): void;\n    getBaseVersionsCount$(entry: IManagedObject): Observable<number>;\n    getBaseVersionFromMO(mo: RepositoryBinary): string;\n    isPatch(mo: RepositoryBinary): boolean;\n    getPatchVersionsCount$(entry: IManagedObject, baseVersion: FirmwareBinary): Observable<number>;\n    isLegacyEntry(entry: Partial<IManagedObject>): boolean;\n    /**\n     * Lists all versions (base and patch ones) of given top level entry.\n     * Versions are ordered by creation time (assuming the earlier created, the older the version).\n     * @param entry Top level repository entry.\n     * @param params Additional query params.\n     */\n    listAllVersions(entry: Partial<IManagedObject>, params?: {}): Promise<IResultList<IManagedObject>>;\n    /**\n     * Lists base versions of given top level entry.\n     * Versions are ordered by creation time (assuming the earlier created, the older the version).\n     * @param entry Top level repository entry.\n     * @param params Additional query params.\n     */\n    listBaseVersions(entry: Partial<IManagedObject>, params?: {}): Promise<IResultList<IManagedObject>>;\n    /**\n     * Lists patch versions of given base version under the entry.\n     * Versions are ordered by creation time (assuming the earlier created, the older the version).\n     * @param entry Top level repository entry.\n     * @param baseVersion Base version.\n     * @param params Additional query params.\n     */\n    listPatchVersions(entry: IManagedObject, baseVersion: FirmwareBinary | string, params?: {}): Promise<IResultList<IManagedObject>>;\n    /**\n     * Lists patch versions of given base version under the entry including the base version.\n     * Versions are ordered by creation time (assuming the earlier created, the older the version).\n     * In terms of legacy base version the entry gets transformed to fit the needed data model.\n     * @param entry Top level repository entry.\n     * @param baseVersion Base version.\n     * @param params Additional query params.\n     */\n    listBaseVersionAndPatches(entry: IManagedObject, baseVersion: IManagedObject, params?: {}): Promise<IResultList<IManagedObject>> | Promise<{\n        data: ({\n            c8y_Firmware: {\n                version: any;\n                url: any;\n            };\n        } & IManagedObject)[];\n    }>;\n    listChildren(entry: Partial<IManagedObject>, filters?: {}, params?: any): Promise<IResultList<IManagedObject>>;\n    /**\n     * Fetches all items from the list starting with the provided page.\n     * @param firstPage The first page of the list to fetch all items for.\n     */\n    fetchAllItemsFromList(firstPage: any): Promise<any>;\n    /**\n     * Gets top level repository entry managed object for base or patch version.\n     * @param mo Base or patch version managed object with parents.\n     */\n    getRepositoryEntryMO$(mo: IManagedObject): Observable<IManagedObject | undefined>;\n    /**\n     * Gets base or patch version managed object.\n     * @param deviceRepositoryFragment Device repository fragment.\n     * @param type Top level repository entry type.\n     * @param configuration Configuration object with options:\n     * - **skipLegacy** - `boolean` - Exclude legacy entries.\n     * - **filters** - `object` - Filter object.\n     *\n     * @deprecated as it doesn't support 'missing url' case\n     */\n    getRepositoryBinaryMoByVersion(deviceRepositoryFragment: DeviceFirmware | DeviceSoftware, type: RepositoryType, { skipLegacy, filters }?: {\n        skipLegacy?: boolean;\n        filters?: object;\n    }): Promise<IManagedObject>;\n    getBinaryName$(binaryUrl: string): Observable<string>;\n    /**\n     * Generates an inventory query object which can be used to find\n     * repository entries of specified type matching the type of provided device.\n     * @param repositoryType The type of repository entries which will be queried with the generated query.\n     * @param device The device for which matching repository entries will be queried with the generated query.\n     */\n    getDeviceTypeQuery(repositoryType: RepositoryType, device: IManagedObject): object;\n    /**\n     * Generates an inventory query object which can be used to find configuration repository entries\n     * matching the type of provided device and specified configuration type.\n     * @param device The device for which matching repository entries will be queried with the generated query.\n     * @param configurationType Configuration type for which matching repository entries will be queried with the generated query.\n     */\n    getConfigurationTypeQuery(device: IManagedObject, configurationType: string): object;\n    /**\n     * Gets the list of software installed in the device in the uniform format.\n     * Supports c8y_SoftwareList and c8y_Software fragments.\n     * @param device The device whose software list should be returned.\n     */\n    getDeviceSoftwareList(device: IManagedObject): DeviceSoftware[];\n    /**\n     * Prepares a software update operation for given device and the list of changes, and sends it to the device.\n     * @param device The device which the operation should be prepared for and sent to.\n     * @param changes The list of software changes which should be applied.\n     */\n    createSoftwareUpdateOperation(device: IManagedObject, changes: DeviceSoftwareChange[]): Promise<IOperation>;\n    /**\n     * Prepares a software update operation for given device and changes.\n     * Returned operation type depends on device's supported operations.\n     * Supports c8y_SoftwareUpdate, c8y_SoftwareList, and c8y_Software operations.\n     * @param device The device for which operation should be prepared.\n     * @param changes The list of software changes which should be applied.\n     */\n    getSoftwareUpdateOperation(device: IManagedObject, changes: DeviceSoftwareChange[]): IOperation;\n    /**\n     * Extracts the list of device software changes from given operation in the context of given device.\n     * @param operation The operation from which the list should be extracted.\n     * @param device The target device of the operation.\n     */\n    getDeviceSoftwareChangesFromOperation(operation: IOperation, device: IManagedObject): DeviceSoftwareChange[];\n    /**\n     * Prepares a firmware update operation for given device and the selected repository binary, and sends it to the device.\n     * @param device The device which the operation should be prepared for and sent to.\n     * @param selectedOption The selected repository binary option.\n     */\n    createFirmwareUpdateOperation(device: IManagedObject, selectedOption: SelectedRepositoryBinary): Promise<IOperation>;\n    /**\n     * Prepares a firmware update operation for given device and selected version.\n     * Supports c8y_Firmware operation.\n     * @param device The device for which operation should be prepared.\n     * @param selectedOption Selected firmware version.\n     */\n    getFirmwareUpdateOperation(device: IManagedObject, selectedOption: SelectedRepositoryBinary): IOperation;\n    /**\n     * Prepares a configuration file upload operation for given device and configuration type.\n     * @param device The device for which operation should be prepared.\n     * @param configurationType Selected configuration type.\n     * @param isLegacy  A legacy operation is created without a configurationType.\n     */\n    getUploadConfigurationFileOperation(device: IManagedObject, configurationType: string, isLegacy?: boolean): IOperation;\n    /**\n     * Prepares a configuration file download operation for given device and configuration type.\n     * @param device The device for which operation should be prepared.\n     * @param configurationType Selected configuration type.\n     * @param binaryUrl The url of a binary to be downloaded.\n     * @param isLegacy A legacy operation is created without a configurationType.\n     */\n    getDownloadConfigurationFileOperation(device: IManagedObject, configurationType: string, configSnapshot: ConfigurationSnapshot, isLegacy?: boolean): IOperation;\n    /**\n     * Gets the last firmware update operation for given device.\n     * Looks for c8y_Firmware operations.\n     * @param deviceId The ID of the device to find an operation for.\n     */\n    getLastFirmwareUpdateOperation(deviceId: string | number): Promise<IOperation>;\n    /**\n     * Gets the last software update operation for given device.\n     * Looks for c8y_SoftwareUpdate, c8y_SoftwareList, or c8y_Software operations.\n     * @param deviceId The ID of the device to find an operation for.\n     */\n    getLastSoftwareUpdateOperation(deviceId: string | number): Promise<IOperation>;\n    /**\n     * Iterates over the list of filters and queries the operations.\n     * If a query returns at least one operation, the first one will be returned.\n     * Otherwise the next query will be performed.\n     * If none of the queries returns any operation, null will be returned.\n     * @param filtersList The list of filters for the queries.\n     */\n    getFirstMatchingOperation(filtersList: any[]): Promise<IOperation>;\n    /**\n     * Iterates over the list of filters and queries the operations.\n     * It compares the operations retrieved by the queries by 'creationTime'\n     * and return the latest one.\n     * If none of the queries returns any operation, null will be returned.\n     * @param filtersList The list of filters for the queries.\n     */\n    getLatestMatchingOperation(filtersList: any[]): Promise<IOperation>;\n    /**\n     * Creates the operation and returns an observable to track its progress.\n     * Fails the observable when the operation returns FAILED status.\n     * Completes the observable when the operation returns SUCCESSFUL status.\n     * @param operation The operation to create and track.\n     */\n    createObservedOperation(operation: IOperation): Observable<IOperation>;\n    /**\n     * Returns an observable to track progress of given operation.\n     * Fails the observable when the operation returns FAILED status.\n     * Completes the observable when the operation returns SUCCESSFUL status.\n     * @param operation The operation to be observed.\n     */\n    observeOperation(operation: IOperation): Observable<IOperation>;\n    /**\n     * Gets a single event with latest creationTime for the given device Id and event type.\n     * @param deviceId The device Id for which the events should be queried.\n     * @param type Event type.\n     */\n    getLatestConfigurationEvent(deviceId: string | number, type: string): Promise<IEvent | undefined>;\n    /**\n     * Gets a list of operations for the given device Id, and operation type.\n     * @param deviceId The device Id for which the operation should be queried.\n     * @param operationType Operation type fragment.\n     */\n    getConfigFileOperationList(deviceId: string | number, operationType: string): Promise<IOperation[]>;\n    /**\n     * Gets latest uploaded configuration snapshot for the given device, and configuration type.\n     * @param device The device for which the configuration snapshot was uploaded.\n     * @param configurationType Selected configuration type.\n     */\n    getConfigSnapshot(device: IManagedObject, configurationType: string): Promise<ConfigurationSnapshot | undefined>;\n    getLegacyConfigSnapshot(deviceId: any): Promise<ConfigurationSnapshot>;\n    /**\n     * Returns a binary object as text.\n     * @param binaryUrl The URL to find binary\n     * @param options The object with additional options:\n     * - **allowExternal** - `boolean` - allows downloading external binary file\n     * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`\n     */\n    getBinaryText(binaryUrl: string, options: {\n        allowExternal: boolean;\n        noAlerts?: boolean;\n    }): Promise<string>;\n    /**\n     * Returns a binary object as File.\n     * @param binaryUrl The URL to find binary\n     * @param options The object with additional options:\n     * - **allowExternal** - `boolean` - allows downloading external binary file\n     */\n    getBinaryFile(binaryUrl: string, options: {\n        allowExternal: boolean;\n    }): Promise<File>;\n    /**\n     * Gets the last configuration update operation for given device.\n     * Looks for c8y_Configuration and c8y_SendConfiguration operations.\n     * @param deviceId The ID of the device to find an operation for.\n     */\n    getLastConfigUpdateOperation(deviceId: string | number): Promise<IOperation>;\n    /**\n     * Prepares a configuration download operation for given device and its current configuration.\n     * Supports c8y_SendConfiguration operation.\n     * @param device The device for which operation should be prepared.\n     */\n    createTextBasedConfigurationReloadOperation(device: IManagedObject): IOperation;\n    /**\n     * Prepares a configuration update operation for the given device.\n     * Supports c8y_Configuration operation.\n     * @param device The device for which operation should be prepared.\n     * @param config The configuration which will update the existing one.\n     */\n    createTextBasedConfigurationUpdateOperation(device: IManagedObject, config: string): IOperation;\n    getBinary(binaryId: IdReference): Promise<IFetchResponse>;\n    /**\n     * Gets all available snapshots from the repository for the given device.\n     * @param device The device for which the snapshots should be prepared.\n     * @param configurationType Selected configuration type.\n     */\n    getSnapshotsFromRepository(device: any, configurationType: any): Promise<IManagedObject[]>;\n    /**\n     * Returns a binary object.\n     * @param binaryId binary ID\n     * @param options The object with additional options:\n     * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`\n     */\n    private getInternalBinaryResponse;\n    /**\n     * Returns a binary object.\n     * @param binaryUrl The URL to find binary\n     * @param options The object with additional options:\n     * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`\n     */\n    private getExternalBinaryResponse;\n    private createEntry;\n    private updateEntry;\n    private getBaseVersionResultListForLegacyEntry;\n    private getDeviceSoftwareChangesFromSoftwareListOperation;\n    private getDeviceSoftwareChangesFromSoftwareOperation;\n}\n"]}