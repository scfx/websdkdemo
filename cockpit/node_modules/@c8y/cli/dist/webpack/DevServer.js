"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DevServer = void 0;
const path = require("path");
const _1 = require("./");
const express = require("express");
const logUpdate = require("log-update");
const proxyServer = require("http-proxy-middleware");
const fs = require("fs");
const https = require("https");
const chalk_1 = require("chalk");
const lodash_1 = require("lodash");
const Utils_1 = require("../utils/Utils");
/**
 * Provides a Development Server.
 */
class DevServer {
    /**
     * Creates a new Webpack-Dev-Server configuration.
     *
     * @param proxy Specify the proxy to use.
     * @param port Specify another port to use
     */
    constructor(proxy = _1.BUILD_DEFAULTS.DEFAULT_PROXY, port = _1.BUILD_DEFAULTS.DEFAULT_PORT, ssl = false, localDomain = 'localhost', customProxyPaths = '^(/apps/public/).*$', ci = false, shell) {
        this.port = port;
        this.ssl = ssl;
        this.localDomain = localDomain;
        this.customProxyPaths = customProxyPaths;
        this.ci = ci;
        this.shell = shell;
        this.config = {
            contentBase: path.resolve('dist'),
            proxy: {
                target: _1.BUILD_DEFAULTS.DEFAULT_PROXY,
                changeOrigin: true,
                ws: true,
                secure: process.env.NODE_TLS_REJECT_UNAUTHORIZED !== '0',
                logLevel: 'error',
                cookieDomainRewrite: this.localDomain,
                onProxyRes: proxyResponse => {
                    if (!this.ssl && proxyResponse.headers['set-cookie']) {
                        const cookies = proxyResponse.headers['set-cookie'].map(cookie => cookie.replace(/;\s{0,}secure/gi, ''));
                        proxyResponse.headers['set-cookie'] = cookies;
                    }
                }
            },
            publicPath: `http${this.ssl ? 's' : ''}://${this.localDomain}:${this.port}/${_1.BUILD_DEFAULTS.DEFAULT_PUBLIC_PATH}/`
        };
        this.expressApp = express();
        this.middleware = {};
        this.log = logUpdate.create(process.stdout);
        this.config.proxy.target = proxy;
    }
    /**
     * Starts a C8Y development server
     *
     * @param apps An array of applications.
     */
    startDevServer(apps, staticFolders = []) {
        Utils_1.setLocationHref();
        console.info(`Proxying requests to remote instance ${chalk_1.default.blueBright(this.config.proxy.target)}`);
        this.apps = apps;
        this.shellRemotes = this.collectMFRemotesForShell(this.apps);
        this.staticFolders = staticFolders;
        this.appsMap = {};
        apps.forEach(app => {
            this.appsMap[app.contextPath] = app;
            app.events.on('build.watch.run', e => {
                this.log(e);
                this.log.done();
            });
            app.events.on('build.progress', () => this.logStatus());
            app.events.on('build.done', doneMsg => {
                setTimeout(() => {
                    this.log.done();
                    this.logStatus();
                    if (this.shell) {
                        this.getModuleFederationShellLog();
                    }
                });
            });
        });
        if (this.apps.length === 1) {
            this.addMiddleware(this.apps[0]);
        }
        this.staticFolders.forEach(staticFolder => {
            const staticFolderContextPath = this.getStaticFolderContextPath(staticFolder);
            const staticFolderUrl = `/${_1.BUILD_DEFAULTS.DEFAULT_PUBLIC_PATH}/${staticFolderContextPath}`;
            this.expressApp.use(staticFolderUrl, express.static(staticFolder.path));
        });
        // set custom proxy path
        this.addAdditionalProxyServer();
        this.expressApp.use(`/${_1.BUILD_DEFAULTS.DEFAULT_PUBLIC_PATH}/:contextPath`, this.serveWebpackBuild.bind(this));
        const dontProxyIfCurrentApps = this.apps
            .map(app => `/${_1.BUILD_DEFAULTS.DEFAULT_PUBLIC_PATH}/${app.contextPath}`)
            .join('|');
        const doProxyRegexStr = `^((?!(${dontProxyIfCurrentApps})|__webpack_hmr|favicon.ico).)*$`;
        this.expressApp.use(new RegExp(doProxyRegexStr, 'i'), proxyServer(this.config.proxy));
        this.expressApp.get(RegExp(`${_1.BUILD_DEFAULTS.DEFAULT_PUBLIC_PATH}\/[^\/]*$`, 'g'), this.redirectRootRequest);
        if (this.ssl) {
            let certPath = './tools/certs/localhost';
            if (typeof this.ssl === 'string') {
                certPath = this.ssl;
            }
            const options = {
                key: fs.readFileSync(`${certPath}.key`),
                cert: fs.readFileSync(`${certPath}.cert`),
                requestCert: false,
                rejectUnauthorized: false
            };
            const server = https.createServer(options, this.expressApp);
            server.listen(this.port);
        }
        else {
            this.expressApp.listen(this.port);
        }
        this.logStatus();
    }
    addAdditionalProxyServer() {
        if (this.customProxyPaths !== true && this.customProxyPaths) {
            const additionalProxyRegex = new RegExp(this.customProxyPaths, 'i');
            this.expressApp.use(additionalProxyRegex, proxyServer(Object.assign(Object.assign({}, this.config.proxy), { ws: false })));
        }
    }
    /**
     * Serve the Webpack build only on navigation.
     */
    serveWebpackBuild(req, res, next) {
        const application = this.appsMap[req.params.contextPath];
        if (application) {
            this.addMiddleware(application);
            next();
            return;
        }
        next();
        return;
    }
    /**
     * redirect every request which comes
     * -> from :9090/apps/appName  <- without slash!
     * -> to :9090/apps/appName/index.html <- with slash and index.html!
     */
    redirectRootRequest(req, res, next) {
        res.redirect(`${req.url}/index.html`);
    }
    /**
     * Adds the WebpackDevMiddleware to this route.
     *
     * @param app The application to add the dev middleware
     */
    addMiddleware(app) {
        const { middleware, expressApp, extraWebpackEnv } = this;
        const { contextPath } = app;
        if (!middleware[contextPath]) {
            const publicPath = `/${_1.BUILD_DEFAULTS.DEFAULT_PUBLIC_PATH}/${contextPath}/`;
            const appMiddleware = app.createDevelopmentMiddleware(expressApp, extraWebpackEnv, this.ci);
            expressApp.use(publicPath, appMiddleware);
            middleware[contextPath] = appMiddleware;
        }
    }
    /**
     * Logs the build status.
     */
    logStatus() {
        const appsStatusLog = this.getAppsStatusLog();
        const staticFoldersStatusLog = this.getStaticFoldersStatusLog();
        this.log(`\n${appsStatusLog}\n\n${staticFoldersStatusLog}\n`);
    }
    getAppsStatusLog() {
        return this.apps.map((app) => app.getLogMsg(this.config.publicPath)).join('\n');
    }
    getStaticFoldersStatusLog() {
        return this.staticFolders
            .map(staticFolder => `${this.config.publicPath}${this.getStaticFolderContextPath(staticFolder)}/`)
            .join('\n');
    }
    /**
     * Collects all applications exports and converts them into an remotes object used by the shell application.
     * @param applications An array of applications.
     * @returns shell remotes.
     *
     * **Example**
     * ```
     * const apps = [
     *   {
     *     contextpath: "plugin-contextpath-1",
     *     options: {
     *       exports: [
     *         {
     *           description: "...",
     *           name: "Module1 Name",
     *           module: "Module1",
     *           path: "...module-path"
     *         },
     *       ],
     *     },
     *   },
     *   {
     *     contextpath: "plugin-contextpath-2",
     *     options: {
     *       exports: [
     *         {
     *           description: "...",
     *           name: "Module2 Name",
     *           module: "Module2",
     *           path: "...module-path"
     *         },
     *       ],
     *     },
     *   },
     * ];
     *
     * const remotes = collectMFRemotesForShell(apps);
     * // remotes object:
     * // {
     * //  "plugin-contextpath-1": [
     * //      "Module1"
     * //  ],
     * //  "plugin-contextpath-2": [
     * //      "Module2"
     * //  ]
     * // }
     * ```
     */
    collectMFRemotesForShell(applications) {
        const shellRemotes = {};
        const applicationsExports = applications.map(app => ({
            [app.contextPath]: lodash_1.get(app, 'options.exports', []).map(remoteExport => remoteExport.module)
        }));
        applicationsExports.forEach(appExports => Object.assign(shellRemotes, appExports));
        return shellRemotes;
    }
    /**
     * Logs proxied shell URL with remotes included as URL options.
     */
    getModuleFederationShellLog() {
        const shellAppName = `Shell application: ${chalk_1.default.blue.bold(this.shell)}\n`;
        const encodedRemotes = encodeURIComponent(JSON.stringify(this.shellRemotes));
        const moduleFederationShellAppProxyUrl = chalk_1.default.blue.underline(`${this.config.publicPath}${this.shell}/index.html?remotes=${encodedRemotes}`);
        console.log(`${shellAppName}${moduleFederationShellAppProxyUrl}`);
    }
    getStaticFolderContextPath({ contextPath, contextPathPrefix }) {
        return `${contextPathPrefix || ''}${contextPath}`;
    }
}
exports.DevServer = DevServer;
//# sourceMappingURL=DevServer.js.map