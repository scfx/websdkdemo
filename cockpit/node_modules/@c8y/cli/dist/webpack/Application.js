"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Application = void 0;
const events_1 = require("events");
const path = require("path");
const chalk_1 = require("chalk");
const BuildDefaults_1 = require("./BuildDefaults");
const util_1 = require("util");
const options_1 = require("../options");
/**
 * A description for an Cumulocity application.
 */
// tslint:disable-next-line:max-classes-per-file
class Application {
    /**
     * Create a new Cumulocity application.
     */
    constructor(options, entry) {
        this.options = options;
        this.entry = entry;
        this.events = new events_1.EventEmitter();
        this.percentage = 0;
        this.msg = '';
        options.globalTitle = options.globalTitle || options_1.options['TXT.GLOBAL_TITLE'];
    }
    get contextPath() {
        return this.options.contextPath;
    }
    get branding() {
        const { brandingEntry } = this.normalizePathOptions(this.options);
        return brandingEntry ? path.resolve(brandingEntry) : BuildDefaults_1.BUILD_DEFAULTS.DEFAULT_BRANDING_PATH;
    }
    createDevelopmentMiddleware(expressApp, extraWebpackEnv, ci = false) {
        let webpackDevMiddleware;
        let webpackHotMiddleware;
        try {
            webpackDevMiddleware = require('webpack-dev-middleware');
        }
        catch (e) {
            throw new Error('Webpack dev middleware is not installed');
        }
        try {
            webpackHotMiddleware = require('webpack-hot-middleware');
        }
        catch (e) {
            throw new Error('Webpack dev hot middleware is not installed');
        }
        this.createWebpack(extraWebpackEnv, ci);
        const { compiler } = this;
        if (extraWebpackEnv.hmr) {
            expressApp.use(webpackHotMiddleware(compiler));
        }
        return webpackDevMiddleware(compiler, {
            stats: extraWebpackEnv.stats || {
                colors: true,
                entrypoints: true,
                chunks: false,
                chunkModules: false,
                chunkOrigins: false,
                chunkGroups: true,
                assets: false,
                modules: false
            }
        });
    }
    async build(env, fast) {
        this.createWebpack(env, fast);
        const compilerRun = util_1.promisify(this.compiler.run.bind(this.compiler));
        return await compilerRun();
    }
    createWebpack(extraEnv, ci) {
        let webpack;
        try {
            webpack = require('webpack');
        }
        catch (e) {
            throw new Error('Webpack is not installed');
        }
        const env = Object.assign({ app: this.options, entry: this.entry, branding: this.branding }, extraEnv);
        const normalizedEnv = Object.assign(Object.assign({}, env), { app: this.normalizePathOptions(env.app) });
        // Only load here so that the CLI can be used without the peer dependencies
        const webpackConfig = require('./config/index').configFactory();
        const config = webpackConfig(normalizedEnv);
        this.compiler = webpack(config);
        this.compiler.hooks.watchRun.tap('WatchRunPlugin', (comp) => {
            const changes = [`\n --- ${chalk_1.default.yellow('File change detected')} ---`];
            if (comp.modifiedFiles) {
                changes.push(Array.from(comp.modifiedFiles, (file) => `\n${chalk_1.default.green('+')} ${chalk_1.default.gray(file.replace(process.cwd(), ''))}`).join(''));
            }
            if (comp.removedFiles) {
                changes.push(Array.from(comp.removedFiles, (file) => `\n ${chalk_1.default.red('-')}  ${chalk_1.default.gray(file.replace(process.cwd(), ''))}`).join(''));
            }
            if (changes.length > 1) {
                this.events.emit('build.watch.run', changes.join(''));
            }
        });
        if (!ci) {
            let startTime = process.hrtime();
            new webpack.ProgressPlugin((percent, msg, addInfo) => {
                this.percentage = Math.floor(percent * 100);
                if (this.percentage <= 1) {
                    startTime = process.hrtime();
                }
                addInfo = addInfo ? `- ${addInfo}` : '';
                this.msg = msg ? ` - ${msg} ${addInfo}` : ` - finished in ${this.elapsedTime(startTime)}`;
                if (this.percentage === 100) {
                    this.events.emit('build.done');
                }
                else {
                    this.events.emit('build.progress');
                }
            }).apply(this.compiler);
        }
    }
    /**
     * Returns the log msg
     */
    getLogMsg(prefix = '') {
        let status = chalk_1.default.yellow(`${this.percentage} %`);
        let app = chalk_1.default.underline(`${prefix}${this.options.contextPath}/`);
        if (!this.compiler) {
            status = chalk_1.default.yellow('waiting');
        }
        if (this.percentage === 100) {
            app = chalk_1.default.green(app);
            status = chalk_1.default.green.bold('done');
        }
        status = this.compiler ? `${status}${chalk_1.default.dim(this.msg)}` : status;
        return `${app} ${status}`;
    }
    normalizePathOptions(appOptions) {
        const pathOptionKeys = ['tsConfigPath', 'brandingEntry', 'entryModule', 'rootNodeModulesPath'];
        return pathOptionKeys.reduce((result, pathOptionKey) => {
            const pathOptionValue = result[pathOptionKey];
            if (pathOptionValue) {
                return Object.assign(Object.assign({}, result), { [pathOptionKey]: this.resolvePathOptionAtEntryPoint(pathOptionValue) });
            }
            return result;
        }, appOptions);
    }
    resolvePathOptionAtEntryPoint(pathOptionValue) {
        if (path.isAbsolute(pathOptionValue)) {
            return pathOptionValue;
        }
        return path.resolve(this.entry, pathOptionValue).replace(/\\/g, '/');
    }
    /**
     * Prints how much time was used for a build
     * @param start the start time
     */
    elapsedTime(start) {
        const precision = 3;
        const elapsed = process.hrtime(start)[1] / 1000000;
        return process.hrtime(start)[0] + ' s - ' + elapsed.toFixed(precision) + ' ms';
    }
}
exports.Application = Application;
//# sourceMappingURL=Application.js.map