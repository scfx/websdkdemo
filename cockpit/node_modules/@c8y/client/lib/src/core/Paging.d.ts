import { Service } from './Service';
import { IResultList } from './IResultList';
/**
 * Paging allows you to query the next and previous data chunks
 * in a convenient way. You can also go to a specific page or just read
 * page information about the current data chunk.
 * Note that page numbers are generated by backend
 * and may be used as offset rather than a continuous range of positive numbers
 * (e.g. in case of users with restricted permissions).
 */
export declare class Paging<TData> {
    /**
     * Holds the number of the current page, so in fact
     * the data chunk you are looking at.
     */
    currentPage: number;
    /**
     * Holds the number of the next page.
     */
    nextPage: number;
    /**
     * Holds the number of the previous page.
     */
    prevPage: number;
    /**
     * Holds the number of the maximum data that you will
     * get with the response.
     */
    pageSize: number;
    /**
     * Holds the number of total pages regarding to the
     * given page size.
     */
    totalPages: number;
    private service;
    private filter;
    constructor(service: Service<TData>, statistics: any, filter: object);
    /**
     * Gets the next page of available data from the server.
     * @param filter
     */
    next(filter?: object): Promise<IResultList<TData>>;
    /**
     * Gets the previous page of available data from server.
     * @param filter
     */
    prev(filter?: object): Promise<IResultList<TData>>;
    /**
     * Method used by next(), prev() and goto() to call the service.list method.
     * It is public so it can be overriden in special cases (like children objects
     * in inventory).
     * @param filter
     */
    list(filter?: object): Promise<IResultList<TData>>;
    /**
     * Goes to the page that you define as page parameter.
     * @param page
     * @param filter
     */
    goto(page: number, filter?: object): Promise<IResultList<TData>>;
    private getFilter;
}
