var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Service } from '../core';
import FormData from 'form-data';
export class ApplicationBinaryService extends Service {
    constructor(client, applicationOrId) {
        super(client);
        this.listUrl = 'binaries';
        this.propertyName = 'attachments';
        this.baseUrl = `application/applications/${this.getIdString(applicationOrId)}`;
    }
    upload(binary, fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.listUrl;
            const method = 'POST';
            const body = this.createBinaryRequestBody(binary, fileName);
            let bodyHeaders;
            if (typeof body.getHeaders === 'function') {
                bodyHeaders = body.getHeaders();
            }
            const headers = Object.assign({
                accept: 'application/json'
            }, bodyHeaders);
            const res = yield this.fetch(url, { method, body, headers });
            const data = yield res.json();
            return { res, data };
        });
    }
    uploadWithProgressXhr(binary, onProgress, fileName) {
        const url = `/${this.baseUrl}/${this.listUrl}`;
        const method = 'POST';
        const body = this.createBinaryRequestBody(binary, fileName);
        let bodyHeaders;
        if (typeof body.getHeaders === 'function') {
            bodyHeaders = body.getHeaders();
        }
        const headers = this.client.getFetchOptions().headers;
        Object.assign(headers, {
            Accept: 'application/json'
        });
        Object.assign(headers, bodyHeaders);
        const xhr = new XMLHttpRequest();
        xhr.open(method, url, true);
        for (const key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
        xhr.upload.addEventListener('progress', onProgress);
        xhr.send(body);
        return xhr;
    }
    getXMLHttpResponse(xhr) {
        return new Promise((res, rej) => {
            xhr.addEventListener('loadend', () => {
                xhr.readyState === 4 && (xhr.status === 200 || xhr.status === 201)
                    ? res(JSON.parse(xhr.responseText))
                    : rej(xhr.responseText ? { data: JSON.parse(xhr.responseText) } : 'Could not upload file.');
            });
        });
    }
    list(filter) {
        const _super = Object.create(null, {
            list: { get: () => super.list }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.list.call(this, filter);
        });
    }
    delete(binaryOrId) {
        const _super = Object.create(null, {
            delete: { get: () => super.delete }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.delete.call(this, binaryOrId);
        });
    }
    listPlugins() {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = { accept: 'application/json' };
            const url = `${this.listUrl}/plugins`;
            const res = yield this.fetch(url, { headers });
            const data = yield res.json();
            return { res, data };
        });
    }
    addPlugin(pluginName, pluginFile) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.listUrl}/plugins/${encodeURIComponent(pluginName)}`;
            const method = 'POST';
            const body = new FormData();
            const bufferOrStream = pluginFile instanceof ArrayBuffer ? Buffer.from(pluginFile) : pluginFile;
            body.append('file', bufferOrStream);
            let bodyHeaders;
            if (typeof body.getHeaders === 'function') {
                bodyHeaders = body.getHeaders();
            }
            const headers = Object.assign({
                accept: 'application/json'
            }, bodyHeaders);
            const res = yield this.fetch(url, { method, body, headers });
            const data = yield res.json();
            return { res, data };
        });
    }
    removePlugin(pluginName) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = 'DELETE';
            const headers = { accept: 'application/json' };
            const url = `${this.listUrl}/plugins/${pluginName}`;
            const res = yield this.fetch(url, { method, headers });
            const data = yield res.json();
            return { res, data };
        });
    }
    updateFiles(files) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.listUrl}/files`;
            const method = 'POST';
            const body = new FormData();
            files.forEach(file => {
                const bufferOrStream = file.contents instanceof ArrayBuffer ? Buffer.from(file.contents) : file.contents;
                body.append(file.path, bufferOrStream);
            });
            let bodyHeaders;
            if (typeof body.getHeaders === 'function') {
                bodyHeaders = body.getHeaders();
            }
            const headers = Object.assign({
                accept: 'application/json'
            }, bodyHeaders);
            const res = yield this.fetch(url, { method, body, headers });
            const data = yield res.json();
            return { res, data };
        });
    }
    downloadArchive(binaryId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.listUrl}/${binaryId}`;
            return yield this.fetch(url);
        });
    }
    createBinaryRequestBody(binary, fileName) {
        const body = new FormData();
        const bufferOrStream = binary instanceof ArrayBuffer ? Buffer.from(binary) : binary;
        let uploadFileName = fileName;
        if (typeof File !== 'undefined' && binary instanceof File) {
            uploadFileName = binary.name;
        }
        body.append('file', bufferOrStream, uploadFileName);
        body.append('fileName', uploadFileName);
        return body;
    }
}
//# sourceMappingURL=ApplicationBinaryService.js.map