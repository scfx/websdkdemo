import { CometD } from 'isomorphic-cometd';
import { MetaChannel } from './MetaChannel';
export class Realtime {
    /**
     * Allows to set up a realtime (websocket or long-polling) connection to the platform.
     * @param client The fetch client instance to use
     * @param url The URL to connect to
     * @param handshakeCallback A function which is called on succeeded or failed handshake
     */
    constructor(client, url = '/notification/realtime', handshakeCallback) {
        this.client = client;
        this.url = url;
        this.cometd = new CometD();
        this.metaHandshake = msg => {
            if (!msg.successful) {
                throw new Error('Handshake failed');
            }
        };
        this.cometd.websocketEnabled = true;
        this.cometd.addListener(MetaChannel.HANDSHAKE, handshakeCallback || this.metaHandshake);
    }
    /**
     * Subscribes to a realtime channel to listen for data.
     * @param channel The channel to connect to
     * @param callback A function to call when data is received
     */
    subscribe(channel, callback) {
        this.checkConnection();
        return this.cometd.subscribe(channel, callback);
    }
    /**
     * Cancels the listening to a channel.
     * @param subscription The subscription object returned by subscribe()
     */
    unsubscribe(subscription) {
        return this.cometd.unsubscribe(subscription);
    }
    /**
     * Disconnects the current connection.
     */
    disconnect() {
        this.cometd.disconnect();
    }
    checkConnection() {
        const { cometd, client, url } = this;
        if (cometd.isDisconnected()) {
            const { headers } = client.getFetchOptions();
            const config = {
                url: client.getUrl(url),
                requestHeaders: headers
            };
            cometd.configure(config);
            this.handshake(client.getCometdHandshake());
        }
    }
    handshake(config) {
        this.cometd.handshake(config);
    }
}
//# sourceMappingURL=Realtime.js.map