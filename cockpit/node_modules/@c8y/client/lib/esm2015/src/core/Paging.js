var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Paging allows you to query the next and previous data chunks
 * in a convenient way. You can also go to a specific page or just read
 * page information about the current data chunk.
 * Note that page numbers are generated by backend
 * and may be used as offset rather than a continuous range of positive numbers
 * (e.g. in case of users with restricted permissions).
 */
export class Paging {
    constructor(service, statistics, filter) {
        this.filter = filter;
        this.service = service;
        this.currentPage = statistics.currentPage;
        this.nextPage = statistics.nextPage;
        this.prevPage = statistics.prevPage;
        this.pageSize = statistics.pageSize;
        this.totalPages = statistics.totalPages;
    }
    /**
     * Gets the next page of available data from the server.
     * @param filter
     */
    next(filter = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.list(this.getFilter(filter, this.nextPage));
        });
    }
    /**
     * Gets the previous page of available data from server.
     * @param filter
     */
    prev(filter = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.list(this.getFilter(filter, this.prevPage));
        });
    }
    /**
     * Method used by next(), prev() and goto() to call the service.list method.
     * It is public so it can be overriden in special cases (like children objects
     * in inventory).
     * @param filter
     */
    list(filter = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.list(filter);
        });
    }
    /**
     * Goes to the page that you define as page parameter.
     * @param page
     * @param filter
     */
    goto(page, filter = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.list(this.getFilter(filter, page));
        });
    }
    getFilter(filter, page) {
        return Object.assign(filter, this.filter, { currentPage: page });
    }
}
//# sourceMappingURL=Paging.js.map